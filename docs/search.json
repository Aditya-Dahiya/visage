[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visualizing Information and Spatial Analysis with ggplot2 Extensions",
    "section": "",
    "text": "Welcome to V.I.S.A.G.E., a resource for extending ggplot2 and the tidyverse to create stunning visualizations, perform geo-computation, and analyze complex data. Built using R and RStudio, this site demonstrates how packages like sf, various ggplot2 extensions, and other tools in the tidyverse enhance data manipulation and visualization. Explore dynamic graphs, interactive maps, and reproducible workflows built with Quarto to see how modern tools can turn data into insights."
  },
  {
    "objectID": "geocomputation.html",
    "href": "geocomputation.html",
    "title": "Geocomputation",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nFeb 11, 2025\n\n\nDifferent Packages to access Open Street Maps in R\n\n\nExploring {osmdata}, {osmextract}, {osmapiR}\n\n\n\n\nFeb 10, 2025\n\n\nExploring the package {rnaturalearth} in R\n\n\nVarious types of maps and geographic data available with {rnaturalearth}\n\n\n\n\nFeb 3, 2025\n\n\nShowing elevation in Maps (2) : {whitebox} & {terra}\n\n\nExploring {whitebox} & {terra} for shaded relief maps with {ggplot2} and {tidyterra}\n\n\n\n\nFeb 2, 2025\n\n\nShowing elevation in Maps (1) : {hillshader}\n\n\nExploring {hillshader} for shaded relief maps with {ggplot2}, {terra} and {tidyterra}\n\n\n\n\nJan 30, 2025\n\n\nExploring the package {climateR}\n\n\nExploring the various datasets available publicly and freely to use and analyze with R, {terra} and {sf} with the {climateR} package\n\n\n\n\nJan 27, 2025\n\n\nExploring the package {geodata}\n\n\nExploring the various datasets available publicly and freely to use and analyze with R, {terra} and {sf} with the {geodata} package\n\n\n\n\nJan 26, 2025\n\n\nMapping India’s Cuisines with R: {sf}, {ggpattern}, {magick} and more\n\n\nDiverse culinary heritage of India with a vibrant map created in R, blending spatial data from {sf}, creative patterns from {ggpattern}, and precise labeling from {ggrepel}. Images of iconic state cuisines were curated using {httr} and {magick}, seamlessly integrated into the visual using the power of {ggplot2}.\n\n\n\n\nJan 18, 2025\n\n\nCustomizing {geofacet} for plotting geographically faceted graphs\n\n\nExploring how faceted plots cn be re-arragned to roughly follow the geographical location of sub-units.\n\n\n\n\nJan 7, 2025\n\n\nCombining {ggmaps}, {terra} and {tidyterra} to produce raster maps.\n\n\nUsing {tidyverse} methods on images from Stadia Maps and Stamen Maps using {ggmap} by functions from {terra} and {tidyterra}\n\n\n\n\nDec 29, 2024\n\n\nCropping and Masking rasters with vectors using {sf} and {terra}\n\n\nShowing maps of various boroughs of London using rasters from open source Stadia Maps, and london boroughs from {spData}.\n\n\n\n\nDec 14, 2024\n\n\nVarious CRS projections for use with {sf} plots in {ggplot2}\n\n\nA ready reckoner for different projections that we can plot the World, Continents and Countries with using {ggplot2} in R.\n\n\n\n\nDec 10, 2024\n\n\nUsing {geodata} to get elevation raster maps\n\n\nExploring Global and Country-Specific Elevation Maps with {geodata}: high-resolution raster elevation data using functions like elevation_30s() and elevation_global(). Simplify geospatial analysis and visualization.\n\n\n\n\nNov 20, 2024\n\n\nUsing the power of {sf} to plot stores / outlets along a calculated route using sf::st_is_within_distance()\n\n\nHarnessing the power of {osmr} for route directions, store locations from www.alltheplaces.xyz, and raster base maps from {ggmaps}\n\n\n\n\nOct 26, 2024\n\n\nDriving Directions using Open Street Maps Routing Service\n\n\nUsing {tidygeocoder}, {osrm}, {sf}, {tidyverse} and {ggmap} along with Open Source Techniques to plot driving directions along various cities in Europe in the norther-Mediterranean region\n\n\n\n\nOct 25, 2024\n\n\n3 types of Cartograms in R with {sf} and {cartogram}\n\n\nCreating Cartograms – contiguous, non-contiguous and packed-circles – in R with {cartogram}, and making non-overlapping text annotations in maps, and custom callouts in Quarto.\n\n\n\n\nOct 20, 2024\n\n\nComputing shortest routes in the sea that avoid land\n\n\nUsing data from Killer Whales encounters in Salish Sea to plot routes of their recorded encounters, and showing those routes that dont intersect land - i.e., removing erroneous data.\n\n\n\n\nOct 16, 2024\n\n\nCreating Maps in R with ggplot2 having background Raster Images using ggmap\n\n\nLearning how to create maps in R using the {ggmap} package, integrating custom raster base maps with {ggplot2} for geospatial data visualization. This page covers the setup, API authentication, and plotting functions to map data effectively.\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Welcome to my little corner of the internet! I’m Dr. Aditya Dahiya, your friendly neighborhood data enthusiast. With an MBBS from AIIMS, New Delhi and a Master of Public Health from Harvard University, I’ve always had a penchant for diving deep into the intricacies of data—and what better way to do that than with ggplot2, its myriad extensions and other open-source packages.\nWhen I’m not navigating the labyrinth of Haryana’s bureaucracy (don’t worry, I have a map!), I channel my experiences as a Fulbright Fellow into making data visualization a captivating storytelling tool. Think of me as your data-wrangling, file-taming, bureaucracy-battling guide with a slightly skewed sense of humor. Need more bureaucratic banter or data insights? Connect with me on LinkedIn or shoot me an email — I promise it won’t be as formal as a government memo!"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About Me",
    "section": "Education",
    "text": "Education\nHarvard University | Boston, MA | MPH in Global Health | Aug 2021 - May 2022\nAll India Institute of Medical Sciences | New Delhi, India | M.B.B.S. | Aug 2005-Dec 2010"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About Me",
    "section": "Experience",
    "text": "Experience\nIndian Administrative Service | Director | Aug 2011 - present\nNeuro-Radiology, AIIMS New Delhi | Junior Resident Doctor | Jan 2011 - Aug 2011"
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html",
    "href": "geocomputation/ggmap_rasters.html",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "",
    "text": "On this page, we’ll explore how to create visually appealing maps in R using the ggmap package (ggmap?), a popular extension of ggplot2 designed for easy integration of raster map tiles from online mapping services. Let us see how to set up the required tools and generate maps with custom base layers, using both ggmap and functions like get_stadiamap().\nggmap is an extension of the ggplot2 package that enables users to overlay data on geographic maps. It retrieves raster map tiles from sources such as Google Maps, Stamen Maps, and Stadia Maps, making it easier to create maps and integrate geospatial data visualization with familiar ggplot2 workflows.\nCode\nlibrary(tidyverse)\nlibrary(ggmap)\nlibrary(sf)\n\nsysfonts::font_add_google(\"Saira Condensed\", \"caption_font\")\nsysfonts::font_add_google(\"Saira\", \"body_font\")\nshowtext::showtext_auto()\nAbout the Sample Dataset: The lnd dataset, part of the spData package (Bivand, Nowosad, and Lovelace 2024) in R, contains polygons representing the large administrative boroughs of London. This dataset includes attributes such as the borough name (NAME), official code (GSS_CODE), land area in hectares (HECTARES), and geometry data in the sfc_MULTIPOLYGON format. You can explore the dataset’s source here.\nCode\n# Data on The boroughs of London\ng &lt;- spData::lnd |&gt; \n  ggplot(\n    aes(\n      fill = NAME,\n      label = NAME,\n      size = HECTARES\n    )\n  ) +\n  geom_sf(\n    alpha = 0.75\n  ) +\n  geom_sf_text(\n    check_overlap = TRUE,\n    family = \"caption_font\"\n  ) +\n  scale_size_continuous(\n    range = c(8, 15)\n  ) +\n  coord_sf() +\n  labs(x = NULL, y = NULL) +\n  theme_grey(\n    base_size = 20\n  ) +\n  theme(\n    legend.position = \"none\",\n    axis.ticks.length = unit(0, \"mm\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"ggmap_rasters_1.png\")\n)"
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#getting-started-with-ggmap",
    "href": "geocomputation/ggmap_rasters.html#getting-started-with-ggmap",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Getting Started with ggmap",
    "text": "Getting Started with ggmap\nBefore creating maps, you’ll need to install the ggmap package, which is available through CRAN.\ninstall.packages(\"ggmap\")\nTo ensure that you can access map tiles from Stadia Maps, you will need an API key. This key allows you to authenticate and use their map services within your R scripts.\nSetting Up API Key Authentication: To access Stadia Maps, follow these steps:\n\nSign up for a free Stadia Maps account and generate an API key.\nSave the API key securely in your environment using the register_stadiamaps() function.\n\nregister_stadiamaps(\"YOUR-API-KEY-HERE\", write = TRUE)\nBy saving the key in your .Renviron file, you ensure it will automatically load in new R sessions, avoiding the need to hard code it into your script."
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#retrieving-a-base-map-with-get_stadiamap",
    "href": "geocomputation/ggmap_rasters.html#retrieving-a-base-map-with-get_stadiamap",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Retrieving a Base-map with get_stadiamap()",
    "text": "Retrieving a Base-map with get_stadiamap()\nOnce your API key is set, you can start generating maps using functions such as get_stadiamap() etc. This function allows you to fetch base maps by specifying the bounding box coordinates of your area of interest. The function will return a ggmap object that you can further customize using ggplot2 syntax."
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#exploring-various-ggmap-functions",
    "href": "geocomputation/ggmap_rasters.html#exploring-various-ggmap-functions",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Exploring various ggmap Functions",
    "text": "Exploring various ggmap Functions\n\nBase functions: get_stadiamap() & ggmap()\nFetches map tiles from Stadia Maps and Stamen Design, after choosing the design from Map Style Library, for a specified bounding box or region and zoom level, and displays them using ggmap(). The various map styles available under the get_stadiamap(maptype = \"your-map-type-here\") argument are: —\n\n\n\n\n\n\n\nMap Type\nDescription\n\n\n\n\nstamen_terrain\nA detailed terrain map highlighting elevation and natural features like hills and rivers.\n\n\nstamen_toner\nA bold, high-contrast map design with stark black-and-white features, ideal for print or urban areas.\n\n\nstamen_toner_lite\nA lighter version of the toner map, providing clearer backgrounds with less emphasis on contrast.\n\n\nstamen_watercolor\nA unique, artistic map style that looks like a watercolor painting, perfect for creative visualizations.\n\n\nstamen_terrain_background\nA terrain map focusing only on the background without labels, useful for overlaying custom data.\n\n\nstamen_toner_background\nA simplified toner map background without labels, ideal for adding data layers on top.\n\n\nstamen_terrain_lines\nTerrain map with added contour lines to emphasize elevation changes.\n\n\nstamen_terrain_labels\nTerrain map that includes place labels, enhancing context for geographic features.\n\n\nstamen_toner_lines\nToner map with a focus on roads and paths, outlined clearly against the background.\n\n\nstamen_toner_labels\nA toner map style with added labels for places, roads, and other key features.\n\n\n\nNote: It is very important is to add the inherit.aes = FALSE argument in geom_sf() if overlaying sf objects on the the {ggmap} raster tiles.\nThe R code below demonstrates how to overlay spatial geometries from sf objects onto raster base maps using ggmap and geom_sf(). The get_stadiamap() function from Stadia Maps is used to fetch raster tiles (specifically with the stamen_toner_lines style) for the London area, which are then transformed into EPSG:3857 (Web Mercator) using a custom function ggmap_bbox() (credits: andyteuchner on stackoverflow post) to ensure the map tiles align correctly with the CRS of the spatial data. The London Boroughs dataset (spData::lnd) is similarly projected to EPSG:3857, and the boroughs are visualized with semi-transparent polygons and labeled with their names using geom_sf() and geom_sf_text(). This approach ensures the raster background and vector geometries are properly aligned.\n\n\nCode\n# Obtain the bounding box of London Boroughs\nlondon_bbox &lt;- sf::st_bbox(spData::lnd)\n\n# A bounding box in the format c(lowerleftlon, lowerleftlat, upperrightlon, upperrightlat)\nlondon_bbox &lt;- c(\n  left = london_bbox$xmin,\n  right = london_bbox$xmax,\n  bottom = london_bbox$ymin,\n  top = london_bbox$ymax\n)\nnames(london_bbox) &lt;- c(\"left\", \"right\", \"bottom\", \"top\")\n\n\n# Getting the map tiles\nlondon_base1 &lt;- get_stadiamap(\n  bbox = london_bbox,\n  zoom = 10,\n  maptype = \"stamen_toner_lines\"\n)\n\nst_crs(london_base1)\n# As we can see the raster images have no CRS system\n# Empirically we know that the coordinate refence system is 3857\n\n# Getting London Boroughs Data\ndf &lt;- spData::lnd |&gt;\n  st_transform(crs = st_crs(3857))\n\n\n# Starting the process of Overlaying the geom_sf() data on this\n# Most important is to add the inherit.aes = FALSE argument.\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nlondon_base2 &lt;- ggmap_bbox(london_base1)\n\n# Plotting the actual map\n\n# Starting with base map tiles\ng &lt;- ggmap(london_base2) +\n  \n  # Plotting the actual sf object data on london boroughs\n  geom_sf(\n    data = df,\n    aes(fill = NAME),\n    inherit.aes = FALSE,\n    alpha = 0.5,\n    colour = alpha(\"white\", 0.5)\n  ) +\n  \n  # Plotting names of London Boroughs on top of the geom_sf\n  geom_sf_text(\n    data = df,\n    aes(label = NAME),\n    inherit.aes = FALSE,\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = TRUE\n  ) +\n  \n  # Forcing the ggplot2 map to be in CRS: 3857\n  coord_sf(\n    crs = st_crs(3857)\n  ) +\n  \n  # Some theme elements\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"none\"\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \n                        \"ggmap_rasters\", \n                        \"fig_2.png\"),\n  plot = g\n)\n\n\n\n\n\n\n\n\nFigure 2: Overlapping a geom_sf() object over and above ggmap raster tiles obtained from Stadia Maps\n\n\n\n\n\n\nqmplot(): Similar to qplot(), but automatically adds a background map. It simplifies mapping by automatically computing the bounding box.\n\n\nWork-in-Progress: Other ggmap() functions\n\nmake_bbox(): Computes a bounding box for a dataset based on latitude and longitude columns.\ngeom_hdr() and geom_labeldensity2d(): Useful for plotting density and contour maps on top of ggmap layers, commonly used for visualizing spatial data like crime maps.\nget_googlemap(): Retrieves maps from Google Maps by specifying a location and zoom level. Different map types are supported (e.g., satellite, terrain, hybrid).\ngeocode() and revgeocode(): Provides geocoding and reverse geocoding services using Google Maps API to convert addresses to coordinates and vice versa.\nmutate_geocode(): Works like mutate() in dplyr, adding latitude and longitude columns to a data frame based on an address.\ntrek() and route(): Calculates routes between locations using Google’s routing API, which can be plotted as paths on a map using geom_path().\nmapdist(): Computes distances and travel times between multiple locations. It’s vectorized for multiple origin-destination pairs.\nregister_google(): Registers a Google Maps API key for use with the ggmap package, allowing access to various Google Maps services. The key can be saved for future sessions."
  },
  {
    "objectID": "geocomputation/computing_sea_routes.html",
    "href": "geocomputation/computing_sea_routes.html",
    "title": "Computing shortest routes in the sea that avoid land",
    "section": "",
    "text": "Dataset used: This #TidyTuesday dataset comes from the Center for Whale Research (CWR), which monitors Southern Resident killer whales in the Salish Sea, part of the Pacific Northwest. The dataset, scraped by Jadey Ryan and documented here, contains information on encounters from 2017 to 2024. Each encounter involves photographing and identifying individual whales. The data can be accessed via the {orcas} R package and includes variables like encounter duration, location, and pod. While the dataset is mostly tidy, some inconsistencies such as missing values and negative durations remain. | Source | Data.\nHere’s my #TidyTuesday Visualization for this project in Figure 1, and the code used and the visualization webpage.\n\n\n\n\n\n\nFigure 1: This map visualizes the movements of Southern Resident killer whales, with arrows marking the starting and ending points of each recorded encounter. The concentration of arrows within a small area highlights the key regions in the Salish Sea where these encounters occur most frequently. Background map images provided by StadiaMaps.\n\n\n\n\n\nMethod 1: Using {geosphere} and {sf}\n\nStep 1: Loading libraries, getting the data and cleaning it\n\n\nCode\n# Loading the Libraries\nlibrary(tidyverse)       # Data wrangling\nlibrary(sf)              # SF objects\nlibrary(showtext)        # Using google fonts in R\nlibrary(geosphere)       # Spherical trigonometry for geography\n\n# Set fonts for including in all graphics\nfont_add_google(\"Saira Semi Condensed\", \"body_font\")\nfont_add_google(\"Saira Extra Condensed\",\"caption_font\")\nshowtext_auto()\n\n# Load orcas data\norcas &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-15/orcas.csv')\n\nsessioninfo::session_info()$packages |&gt; \n  as_tibble() |&gt; \n  dplyr::select(package, \n         version = loadedversion, \n         date, source) |&gt;\n  filter(package %in% .packages()) |&gt; \n  arrange(package) |&gt; \n  janitor::clean_names(\n    case = \"title\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive(\n    use_search = TRUE\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 1: List of packages used during this analysis and their versions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Clean the data, make it in {sf} format\n\n\nCode\n# A cleaner tibble to use for our visualization\ndf_sf &lt;- orcas |&gt; \n  as_tibble() |&gt;\n  dplyr::select(year, duration, \n         begin_latitude, begin_longitude,\n         end_latitude, end_longitude) |&gt; \n\n  # Convert the duration of encounter into seconds\n  mutate(\n    # remove parenthesis content from duration\n    duration = str_remove(duration, \"\\\\s*\\\\(.*\\\\)\"),\n    \n    # remove the \"s\" for seconds\n    duration = str_extract(duration, \"-?\\\\d+\"),\n    \n    # convert the duration into number\n    duration = as.numeric(duration)\n  ) |&gt; \n  \n  # Remove aberrant observation with durations less than zero\n  filter(duration &gt;= 0) |&gt; \n  \n  # Remove observations with missingness\n  drop_na() |&gt; \n  \n  # Allot an ID number to each finally selected observation\n  mutate(id = row_number()) |&gt; \n  dplyr::relocate(id, .before = everything())\n\n########################################################\n# Get a bounding box on the coordinates of encounters\nbbox_orcas &lt;- bind_rows(\n  \n  # Geometry column of starting coordiantes\n    sf::st_as_sf(\n      df_sf |&gt; dplyr::select(begin_latitude, begin_longitude),\n      coords = c(\"begin_longitude\",\"begin_latitude\"),\n      crs = 'EPSG:4326'\n    ) |&gt;\n    mutate(type = \"start_coords\"),\n    \n\n  # Geometry column of starting coordiantes\n    sf::st_as_sf(\n      df_sf |&gt; dplyr::select(end_latitude, end_longitude),\n      coords = c(\"end_longitude\",\"end_latitude\"),\n      crs = 'EPSG:4326'\n    ) |&gt;\n    mutate(type = \"end_coords\")\n) |&gt; \n  st_bbox()\n\n######################################################\n# Display cleaned data\n\ndf_sf |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    columns = -c(year, id),\n    decimals = 2\n  ) |&gt; \n  gt::tab_header(\n    title = \"Cleaned Data on starting and ending coordinates\",\n    subtitle = \"Recorded Encounters of Orcas (Southern Killer Whales) in the Salish Sea (2017-2024)\"\n  )\n\n\n\n\nTable 2: A table of clean data that shows id, year, duration and starting and ending coordinates of each Killer Whale encounter as an {sf} class column\n\n\n\n\n\n\nCleaned Data on starting and ending coordinates\nRecorded Encounters of Orcas (Southern Killer Whales) in the Salish Sea (2017-2024)\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Computing routes using geosphere::gcIntermediate()\n\n\nCode\n# Technique Credits: https://github.com/xmc811/flightplot/blob/master/R/main.R\n# Credits: Mingchu Xu\n# https://www.linkedin.com/in/mingchu-xu-467a0946/\n# On Twitter: @xmc811\n\nroutes &lt;- geosphere::gcIntermediate(\n  p1 = df_sf |&gt; dplyr::select(begin_longitude, begin_latitude),\n  p2 = df_sf |&gt; dplyr::select(end_longitude, end_latitude),\n  n = 100,\n  addStartEnd = TRUE,\n  sp = TRUE) |&gt; \n  sf::st_as_sf()\n\n# Check whether it works\nggplot() +\n  geom_sf(data = routes)\n\n\n\n\n\n\n\n\nFigure 2: The routes computed by the {geosphere} package’s gcIntermediate() function\n\n\n\n\n\n\n\nStep 4: Getting background maps for the Salish Sea area: USA and Canada\nFor this, we first convert our sf object on Map of USA and Canada, shown in Figure 3 (a) into a SpatVector. In the {terra} package in R, a SpatVector is the main class used to represent and work with vector data in geographic information system (GIS) contexts. A SpatVector can store points, lines, polygons, or any combination of these geometries, along with associated attributes (data linked to these geometries). We can create a SpatVector from:\n\nShapefiles (widely used for vector data in GIS)\nOther vector file formats like GeoJSON, KML, or GPKG.\nR objects such as data frames or matrices that contain coordinate information.\n\nThe reason to create a SpatVector is for performing spatial operations like buffering, intersecting, or spatial joins.The terra::vect() is the method to create these objects from various file formats or other R objects.\nThen, we use the terra::crop() to crop USA and Canada map to a specified geographic extent Figure 3 (b) defined by bounding box of the sf objects of orcas created in previous step. When applied to a SpatVector object (vector data), terra::crop() trims the geometries (points, lines, or polygons) so that only the portions within a specified spatial extent remain. Lastly, we re-convert the cropped SpatVector back into an sf object, shown in ?@fig-basemap1-3\n\n\nCode\n# Extract country borders data\nbase_map &lt;- rgeoboundaries::gb_adm0(country = c(\"USA\", \"Canada\")) %&gt;% \n  rmapshaper::ms_simplify(0.5)\n\n# checking the size\n# object.size(base_map) |&gt; print(units = \"Mb\")\n# 4.3 Mb\n\nggplot(base_map) +\n  geom_sf() +\n  coord_sf(\n    crs = usmap::usmap_crs()\n  )\n\nsea &lt;- terra::crop(terra::vect(base_map), bbox_orcas)\n\n# Finally, reconvert the Cropped area back into an sf object\nsea_sf &lt;- sea |&gt; \n  st_as_sf()\n\nggplot(sea_sf) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n(a) Map of entire USA and Canada from {rgeoboundaries}\n\n\n\n\n\n\n\n\n\n\n\n(b) Using the terra::crop() from {terra} to focus on Salish Sea area. The Salish Sea area plotted as an sf object\n\n\n\n\n\n\nFigure 3: Background Map of the Salish Sea Area in 2 steps: (4.1) Getting map of USA and Canada from {rgeoboundaries}, and (4.2) Cropping out the map of Salish Sea area\n\n\n\n\n\n\nStep 5: Computing and Removing routes intersecting with land (i.e., erroneous data)\n\n\nCode\n# Test if path is only sea. Each logical test if for each ID in the \n# df1 tibble\ntest_intersect &lt;- lengths(\n  st_intersects(\n    st_transform(routes, st_crs(base_map)), base_map\n  )\n) &gt; 0\n\n# Compute distance for each \ndist_encounter &lt;- st_length(routes)\n\n# Create a second tibble of distance & paths for each encounter\ndf_routes &lt;- routes |&gt; \n  st_transform(st_crs(base_map)) |&gt; \n  bind_cols(id = df_sf$id) |&gt; \n  bind_cols(whether_intersect_land = test_intersect) |&gt; \n  bind_cols(dist_encounter = as.numeric(dist_encounter)) |&gt; \n  left_join(df_sf |&gt; dplyr::select(year, id, duration)) |&gt; \n  mutate(speed = dist_encounter / duration)\n  \n# A vector of IDs whose paths dont intersect land\nids_to_plot &lt;- df_routes |&gt; \n  filter(whether_intersect_land == FALSE) |&gt; \n  pull(id)\n\ndf_routes |&gt; \n  dplyr::relocate(geometry, .after = everything()) |&gt; \n  gt::gt() |&gt; \n  # gt::cols_hide(geometry) |&gt; \n  gt::fmt_number(\n    columns = c(dist_encounter, speed),\n    decimals = 1\n  ) |&gt; \n  gt::fmt(\n    columns = geometry,\n    fns = function(x) {str_sub(x, 1, 20)}\n  ) |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 3: A table of intersecting and non-intersecting routes\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 6: Plotting the non-intersecting routes in Figure 4\n\n\nCode\n# ggmap::register_stadiamaps(\"YOUR-KEY-HERE\")\n\nbbox_stadiamap &lt;- c(left = bbox_orcas[\"xmin\"],\n  right = bbox_orcas[\"xmax\"],\n  top = bbox_orcas[\"ymax\"],\n  bottom = bbox_orcas[\"ymin\"])\nnames(bbox_stadiamap) &lt;- c(\"left\", \"right\", \"top\", \"bottom\")\n\n# Getting the Stamen Maps for the background tiles as raster\nstamen_tiles_lowres &lt;- ggmap::get_stadiamap(\n   bbox_stadiamap,\n   zoom = 8,\n   maptype = \"stamen_terrain\"\n)\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nstamen_tiles_lowres2 &lt;- ggmap_bbox(stamen_tiles_lowres)\n\ng &lt;- ggmap::ggmap(stamen_tiles_lowres2) +\n  geom_sf(\n    data = df_routes |&gt; \n            filter(!whether_intersect_land) |&gt; \n            st_transform(crs = 3857),\n    mapping = aes(\n      geometry = geometry\n    ),\n    color = \"grey10\",\n    alpha = 0.5,\n    inherit.aes = FALSE,\n    arrow = arrow(\n      angle = 20,\n      length = unit(0.5, \"mm\")\n    ),\n    linewidth = 0.2\n  ) +\n  coord_sf(\n    expand = F\n  ) +\n  labs(\n    x = \"Longitude\", y = \"Latitude\"\n  ) +\n  theme_minimal()\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"computing_sea_routes_1.png\"),\n  width = 900,\n  height = 700,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: This map visualizes the movements of Southern Resident killer whales, with arrows marking the starting and ending points of each recorded encounter. The concentration of arrows within a small area highlights the key regions in the Salish Sea where these encounters occur most frequently. Background map images provided by StadiaMaps.\n\n\n\n\n\n\n\nMethod 2: Using raster and gdistance package\nThe following code for computing sea routes is inspired from Code by Benjamin Nowak hosted on GitHub as a part of #TidyTuesday visualizations.\n\nStep 1: Getting the data and cleaning it\nThe packages used in this analysis are shown in the Table 4\n\n\nCode\n# Loading the Libraries\nlibrary(tidyverse)       # Data wrangling\nlibrary(rgeoboundaries)  # Getting country & admin boundaries.\nlibrary(rmapshaper)      # For multi-polygon simplification\nlibrary(sf)              # SF objects\nlibrary(terra)           # Spatial data analysis\nlibrary(tidyterra)       # Tidyverse methods for terra objects\nlibrary(gdistance)       # Distances and Routes on Geographical Grids\nlibrary(showtext)        # Using google fonts in R\n\n# Set fonts for including in all graphics\nfont_add_google(\"Saira Semi Condensed\", \"body_font\")\nfont_add_google(\"Saira Extra Condensed\",\"caption_font\")\nshowtext_auto()\n\n# Load orcas data\norcas &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-15/orcas.csv')\n\nsessioninfo::session_info()$packages |&gt; \n  as_tibble() |&gt; \n  dplyr::select(package, \n         version = loadedversion, \n         date, source) |&gt; \n  filter(package %in% .packages()) |&gt; \n  arrange(package) |&gt; \n  janitor::clean_names(\n    case = \"title\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive(\n    use_search = TRUE\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 4: List of packages used during this analysis and their versions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Clean the data\n\n\nCode\n# A cleaner tibble to use for our visualization\ndf1 &lt;- orcas |&gt; \n  as_tibble() |&gt;\n  dplyr::select(year, duration, \n         begin_latitude, begin_longitude,\n         end_latitude, end_longitude) |&gt; \n\n  # Convert the duration of encounter into seconds\n  mutate(\n    # remove parenthesis content from duration\n    duration = str_remove(duration, \"\\\\s*\\\\(.*\\\\)\"),\n    \n    # remove the \"s\" for seconds\n    duration = str_extract(duration, \"-?\\\\d+\"),\n    \n    # convert the duration into number\n    duration = as.numeric(duration)\n  ) |&gt; \n  \n  # Remove aberrant observation with durations less than zero\n  filter(duration &gt;= 0) |&gt; \n  \n  # Remove observations with missingness\n  drop_na() |&gt; \n  \n  # Allot an ID number to each finally selected observation\n  mutate(id = row_number()) |&gt; \n  dplyr::relocate(id, .before = everything())\n\ndf1 |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    columns = -c(year, id),\n    decimals = 2\n  )\n\n\n\n\nTable 5: A table of clean data that shows id, year, duration and starting and ending coordinates of each Killer Whale encounter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Creating data is specific formats needed by {sf} {terra}\n\n\nCode\n# The starting Coordinates as an sf object\nstart_coordinates &lt;- df1 |&gt; \n  dplyr::select(id, begin_latitude, begin_longitude) |&gt; \n  sf::st_as_sf(\n    coords = c(\"begin_longitude\",\"begin_latitude\"),\n    crs = 'EPSG:4326'\n  ) |&gt; \n  mutate(type = \"start\")\n\n# The ending Coordinates as an sf object  \nend_coordinates &lt;- df1 |&gt; \n  dplyr::select(id, end_latitude, end_longitude) |&gt; \n  sf::st_as_sf(\n    coords = c(\"end_longitude\",\"end_latitude\"),\n    crs = 'EPSG:4326'\n  ) |&gt; \n  mutate(type = \"end\")\n\n# Compiling starting and ending coordinates into a tibble\norcas_sf &lt;- start_coordinates |&gt; \n  bind_rows(end_coordinates)\n\n# Extracting the bounding box of that tibble to get our map\nbb_orcas &lt;- st_bbox(orcas_sf)\n\norcas_sf |&gt; \n  print(n = 10)\n\n\nSimple feature collection with 1168 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -125.6233 ymin: 47.85333 xmax: -122.0445 ymax: 49.55733\nGeodetic CRS:  WGS 84\n# A tibble: 1,168 × 3\n      id             geometry type \n * &lt;int&gt;          &lt;POINT [°]&gt; &lt;chr&gt;\n 1     1  (-124.6925 48.5105) start\n 2     2  (-123.1578 48.4765) start\n 3     3    (-123.2 48.57167) start\n 4     4 (-123.3367 49.09267) start\n 5     5 (-123.0368 48.79683) start\n 6     6 (-122.9295 48.43633) start\n 7     7 (-123.8992 48.84733) start\n 8     8  (-123.592 48.02783) start\n 9     9    (-123.4358 48.87) start\n10    10 (-123.3302 48.80333) start\n# ℹ 1,158 more rows\n\n\n\n\nStep 4: Getting background maps for the Salish Sea area: USA and Canada\nFor description of the actions performed, please see Step 4 of the Method 1 above.\n\n\nCode\n# Extract country borders data\nbase_map &lt;- rgeoboundaries::gb_adm0(country = c(\"USA\", \"Canada\")) %&gt;% \n  rmapshaper::ms_simplify(0.5)\n\n# checking the size\n# object.size(base_map) |&gt; print(units = \"Mb\")\n# 4.3 Mb\n\nggplot(base_map) +\n  geom_sf() +\n  coord_sf(\n    crs = usmap::usmap_crs()\n  )\n\nsea &lt;- terra::crop(terra::vect(base_map), bb_orcas)\n\nggplot(sea) +\n  geom_sf()\n\n# Finally, reconvert the Cropped area back into an sf object\nsea_sf &lt;- sea |&gt; \n  st_as_sf()\n\nggplot(sea_sf) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n(a) Map of entire USA and Canada from {rgeoboundaries}\n\n\n\n\n\n\n\n\n\n\n\n(b) Using the terra::crop() from {terra} to focus on Salish Sea area\n\n\n\n\n\n\n\n\n\n\n\n(c) The same Salish Sea area plotted as an sf object\n\n\n\n\n\n\nFigure 5: Background Map of the Salish Sea Area in 2 steps: (4.1) Getting map of USA and Canada from {rgeoboundaries}, and (4.2) Cropping out the map of Salish Sea area\n\n\n\n\n\n\nStep 5: Converting into rasters to plot compute distances and intersections\nterra::rast() function is used to create a raster object or load an existing raster dataset (e.g., GeoTIFF, ASCII, or other raster formats). A raster is a grid of cells (pixels) where each cell has a value representing information such as elevation, temperature, land cover, etc. We use it here to Create an empty raster, defining the number of rows, columns, extent, and coordinate reference system (CRS) to create a raster template.\nterra::rasterize() function is then used to convert vector data (points, lines, polygons) into raster format. This process assigns values from vector geometries to raster cells, typically based on whether the geometries overlap with the cells or using attributes from the vector data. For example, here we are Rasterizing polygons: i.e., for each land types: USA, Canada or other, we can rasterize it so that each raster cell represents one of these three.\n\n\nCode\n# Convert vector to raster and set highly diffferent pixel values based on whether an area is sea or land (i.e. not sea)\n\n# Step 5.1: Generate an empty raster defining the resolution by\n#           number of rows and columns, and a CRS from sea_sf\nr &lt;- terra::rast(sea_sf, ncols = 500, nrows = 500)\n\nggplot() +\n  geom_spatraster(data = r)\n\nrr &lt;- terra::rasterize(sea_sf, r, \"shapeISO\") %&gt;%\n  mutate(shapeISO = case_when(\n    shapeISO %in% c('CAN', 'USA') ~ 1,  # assign value 1 to land\n    TRUE ~ 1000                         # assign value 1000 to sea\n  ))\n\nggplot() +\n  geom_spatraster(data = rr)\n\n\n\n\n\n\n\n\nFigure 6: The empty raster of 500 X 500 created using terra::rast()\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: The raster is enhanced by adding the polygons data from the salish sea area map we cropped in the last step.\n\n\n\n\n\n\n\nStep 6: Computing the distance between starting and ending coordinates\n\nThe gdistance::transition() function is used to create a transition matrix from raster data. The Transition Matrix is a sparse matrix where each element represents the movement “cost” or “resistance” from one cell to its neighboring cells. The transition matrix enables the calculation of the most efficient path (e.g., the least-cost path) from one location to another. Thus, it is used for calculating least-cost paths, commute distances, and other kinds of spatial movement analyses.\nThe transition matrix helps in Movement Modeling: It is used to model movement across a landscape, such as wildlife migration, water flow, or human navigation, where each raster cell’s value might represent an obstacle or ease of travel. Note that we had assigned different value to land and sea raster points.\nAfter creating a transition layer using gdistance::transition(), the gdistance::geoCorrection() function is used to apply geographic corrections to account for the varying distances between raster cells due to the curvature of the Earth or grid layout. This step is crucial when working with spatial data in a geographic coordinate system (e.g., latitude and longitude) where distances between cells are not uniform.\nThe gdistance::shortestPath() is then used to compute the shortest (or least-cost) path between two points on a raster grid, based on a transition matrix that describes the “cost” or “resistance” of moving from one cell to another. The function calculates this path by minimizing the total cost or resistance, taking into account the values in the transition matrix, which typically represent the difficulty or ease of moving through each cell.\n\n\n\nCode\n# For quick rendering of this .qmd file, I have not evaluated \n# this chunk of code, and rather saved the results of \"distance\"\n# as an .rds file and reloaded it.\n\n# Compute transition matrix from raster pixels\nr_trans &lt;- gdistance::transition(\n  x = raster(rr), \n  transitionFunction = mean, \n  directions = 16\n)\n# object.size(r_trans) |&gt; print(units = \"Mb\")\n# 24.7 Mb\n\nr_trans &lt;- geoCorrection(r_trans)\n# object.size(r_trans) |&gt; print(units = \"Mb\")\n# 24.7 Mb\n\n# Compute the shortest path between start and end for the \n# first line of the transition matrix, and convert into sf object:\n\ndistance &lt;- gdistance::shortestPath(\n  r_trans, \n  c(df1 |&gt; filter(id == 1) |&gt; pull(begin_longitude),\n    df1 |&gt; filter(id == 1) |&gt; pull(begin_latitude)), \n  c(df1 |&gt; filter(id == 1) |&gt; pull(end_longitude),\n    df1 |&gt; filter(id == 1) |&gt; pull(end_latitude)), \n  output = \"SpatialLines\"\n) |&gt; \n  st_as_sf()\n\n# Repeat the process for the other points / IDs\nfor (i in 2:nrow(df1)) {\n  \n  temp &lt;- gdistance::shortestPath(\n  r_trans, \n  c(df1 |&gt; filter(id == i) |&gt; pull(begin_longitude),\n    df1 |&gt; filter(id == i) |&gt; pull(begin_latitude)), \n  c(df1 |&gt; filter(id == i) |&gt; pull(end_longitude),\n    df1 |&gt; filter(id == i) |&gt; pull(end_latitude)), \n  output = \"SpatialLines\"\n) |&gt; \n  st_as_sf()\n  \n  distance &lt;- distance |&gt; \n    bind_rows(temp)\n\n}\n\n# Add a CRS to the newly created sf object \ndistance &lt;- distance |&gt; \n  st_set_crs(st_crs(base_map))\n\nsaveRDS(distance, file = here::here(\"data\", \"orcas_distance.rds\"))\n\n\n\n\nCode\ndistance &lt;- readRDS(here::here(\"data\", \"orcas_distance.rds\"))\n\n# Displaying the shortest paths\nggplot() +\n  \n  geom_sf(\n    data = sea_sf, \n    alpha = 0.75, \n    fill = \"#725428\") +\n\n  geom_sf(\n    data = distance\n  ) +\n  coord_sf(expand = FALSE) +\n  \n  theme(\n    panel.background = element_rect(fill = \"#b6e3db\")\n  )\n\n\n\n\n\n\n\n\nFigure 8: The shortest paths computed using {gdistance} show us that many of them are passing over land - these seem to be errors in the data\n\n\n\n\n\n\n\nStep 7: Check whether paths intersect land, and retain only non-intersecting routes\nThe sf::st_intersects() function is used to determine whether two spatial geometries intersect. It checks if any part of one geometry touches or overlaps with another.\nThe sf::st_length() function is then used to calculate the length of geometries represented in sf (simple features) objects. It returns the length of each geometry in the specified unit of measurement.\n\n\nCode\n# Test if path is only sea. Each logical test if for each ID in the \n# df1 tibble\ntest_intersect &lt;- lengths(st_intersects(distance, base_map)) &gt; 0\n\n# Compute distance for each \ndist_encounter &lt;- st_length(distance)\n\n# Create a second tibble of distance & paths for each encounter\ndf2 &lt;- distance |&gt; \n  bind_cols(id = start_coordinates$id) |&gt; \n  bind_cols(whether_intersect_land = test_intersect) |&gt; \n  bind_cols(dist_encounter = as.numeric(dist_encounter)) |&gt; \n  left_join(df1 |&gt; dplyr::select(year, id, duration)) |&gt; \n  mutate(speed = dist_encounter / duration)\n  \n# A vector of IDs whose paths dont intersect land\nids_to_plot &lt;- df2 |&gt; \n  filter(whether_intersect_land == FALSE) |&gt; \n  pull(id)\n\ndf2 |&gt; \n  dplyr::relocate(geometry, .after = everything()) |&gt; \n  slice_head(n = 10) |&gt; \n  mutate(geometry = as.character(geometry)) |&gt; \n  gt::gt() |&gt; \n  # gt::cols_hide(geometry) |&gt; \n  gt::fmt_number(\n    columns = c(dist_encounter, speed),\n    decimals = 2\n  ) |&gt; \n  gt::fmt(\n    columns = geometry,\n    fns = function(x) {str_sub(x, 1, 50)}\n  )\n\n\n\n\n\n\n\n\nid\nwhether_intersect_land\ndist_encounter\nyear\nduration\nspeed\ngeometry\n\n\n\n\n1\nFALSE\n12,981.52\n2024\n5580\n2.33\nc(-124.689260978699, -124.703576316833, -124.71789\n\n\n2\nFALSE\n757.91\n2024\n2460\n0.31\nc(-123.157519798279, -123.157519798279, -123.15751\n\n\n3\nFALSE\n1,845.91\n2024\n9900\n0.19\nc(-123.200465812683, -123.193308143616, -123.18615\n\n\n4\nFALSE\n11,256.39\n2024\n5460\n2.06\nc(-123.336461524963, -123.336461524963, -123.33646\n\n\n5\nFALSE\n6,932.37\n2024\n2460\n2.82\nc(-123.035839424133, -123.035839424133, -123.03583\n\n\n6\nFALSE\n11,305.02\n2024\n6300\n1.79\nc(-122.928474388123, -122.921316719055, -122.91415\n\n\n7\nTRUE\n7,742.05\n2024\n6360\n1.22\nc(-123.901917381287, -123.901917381287, -123.90191\n\n\n8\nTRUE\n130,922.24\n2024\n2340\n55.95\nc(-123.594137611389, -123.594137611389, -123.59413\n\n\n9\nFALSE\n7,738.62\n2024\n3900\n1.98\nc(-123.436668891907, -123.443826560974, -123.45098\n\n\n10\nFALSE\n2,816.18\n2024\n840\n3.35\nc(-123.329303855896, -123.329303855896, -123.32930\n\n\n\n\n\n\n\n\n\nStep 8: Plotting the final routes with ggplot2\n\n\nCode\nland &lt;- \"#725428\"\nsea &lt;- \"#b6e3db\"\norc &lt;- \"grey10\"\n\nggplot() +\n  geom_sf(\n    data = sea_sf,\n    mapping = aes(geometry = geometry),\n    fill = land, color = NA,\n    alpha = 0.9\n  ) +\n  geom_sf(\n    df2 |&gt; filter(!whether_intersect_land),\n    mapping = aes(\n      alpha = speed,\n      geometry = geometry\n    ),\n    color = orc\n  ) + \n  coord_sf(\n    expand = F\n  ) +\n  scale_alpha(range = c(0.5, 0.9)) +\n  guides(alpha = \"none\") +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = sea, color = NA)\n  )\n\n\n\n\n\n\n\n\nFigure 9: The final map with routes shown that don’t intersect land. The alpha (transparency) of each route is mapped to speed."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html",
    "href": "geocomputation/osm_driving_directions.html",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "",
    "text": "This code provides a detailed methodology for creating a visually informative route map for a driving trip along the northern Mediterranean, integrating data visualization, spatial data handling, and Open Street Maps (OSM) routing services in R. Utilizing several packages, including {sf} (Pebesma and Bivand 2023) for spatial data and {tidygeocoder} (Cambon et al. 2021) for geocoding, the code transforms a dataset of locations into spatial coordinates. By accessing OSRM (Open Source Routing Machine) through the {osrm} (Giraud 2022)package, the code calculates and visualizes optimized driving routes between selected cities. Distances and travel durations are formatted using custom functions, enhancing the map’s usability and clarity.\nThe geospatial data is presented using {ggplot2} (Wickham 2016) with additional styling from {ggrepel} (Slowikowski 2024) for labels and {patchwork} (Pedersen 2024) to arrange plots. Base map layers are sourced from {rnaturalearth} (Massicotte and South 2023) and a refined background layer is added using {ggmap} with Stadia map tiles, adjusted to EPSG:3857 using custom bounding box functions. This layering enables effective visualization of routes on custom raster maps. The code’s structure allows for modifications, such as changing cities or map styling, demonstrating the adaptability of R’s spatial data packages in route mapping and driving directions creation.\nInspired from this tutorial (Heiss 2023) titled “How to make fancy road trip maps with R and OpenStreetMap”."
  },
  {
    "objectID": "geocomputation/cartogram_types.html",
    "href": "geocomputation/cartogram_types.html",
    "title": "3 types of Cartograms in R with {sf} and {cartogram}",
    "section": "",
    "text": "Introduction\nOn this webpage, we’ll explore how to create cartograms in R, using population data from the CIA World Factbook. Cartograms are a unique type of thematic map that reshape geographic regions to represent data variables rather than their actual geographic area. By resizing areas to reflect variables like population, cartograms reveal spatial patterns and disparities in a more visually striking way, making them a powerful tool for storytelling with data.\nUnlike traditional maps, where region size is based solely on geographical area, cartograms alter these sizes to communicate insights about underlying data trends. This approach offers several advantages: it enhances visualization by making patterns more apparent, communicates complex data to a broad audience effectively, and highlights disparities between regions, drawing attention to areas of interest. Additionally, cartograms facilitate comparative analysis by allowing viewers to easily compare regions resized according to a single variable.\nTo create cartograms in R, we’ll use a combination of packages, including {cartogram} (Jeworutzki 2023)for cartogram-specific functions, {sf} (Pebesma and Bivand 2023) for handling spatial data, {ggplot2} (Wickham 2016) for flexible mapping and plotting, and {tidyverse} (Wickham et al. 2019) for streamlined data manipulation. The {cartogram} package provides various cartogram types, including\n\nDorling cartograms (Figure 5) that represent regions as resized circles,\nContiguous area cartograms (Figure 3) that maintain topological relationships between regions, and\nNon-contiguous area cartograms (Figure 4) that allow flexibility in resizing by ignoring boundaries.\n\n\nAbout the Data\nThe dataset used in this tutorial is sourced from the CIA World Factbook, specifically the Country Comparisons from 2014. This resource provides essential statistics on population, area, and other key indicators for 265 global entities. Through the {openintro} and {usdatasets} R packages, we access population metrics that allow us to create cartograms—maps where countries’ sizes are distorted according to population values rather than geographic area. This dataset, which required no additional cleaning, enables the visualization of demographic distributions, highlighting countries’ population density and size in an intuitive way for mapping exercises in R.\n\n\n\n\n\n\nKey Learnings\n\n\n\n\nCreating Cartograms with {cartogram}, such as contiguous, non-contiguous, and Dorling cartograms to visually communicate data through shape transformations.\nCustom Callouts in Quarto with the Custom Callout Extension, which enhances document structure and readability, such as the present call-out.\nRepelling Overlapping Text Labels with {ggrepel} with geom_sf() and geom_sf_text() for improved clarity on maps.\n\n\n\n\n\nStep 1: Getting libraries and raw data\nIn this step, we are setting up our workspace to create a population-based cartogram using data from the CIA World Factbook. We begin by loading essential libraries, including {tidyverse} for data manipulation and visualization, {sf} for handling spatial data, and {cartogram} for creating cartograms. We load the cia_factbook dataset and use the {countrycode} package to add ISO3 country codes for mapping. The world_map object is created using the {rnaturalearth} package, which provides geographic data in sf format. Additionally, we set up custom fonts using {showtext} and define color palettes for filling and labeling countries, enhancing the map’s readability and aesthetic.\n\n\nCode\n# Load essential libraries\nlibrary(tidyverse)         # For data wrangling and visualization\nlibrary(sf)                # For handling spatial objects in R\nlibrary(ggrepel)           # For repelling overlapping labels in plots\nlibrary(cartogram)         # For creating different types of cartograms\nlibrary(showtext)          # For using custom Google Fonts in plots\n\n# Load and prepare the CIA Factbook data\ncia_data &lt;- openintro::cia_factbook |&gt; \n  mutate(\n    # Convert country names to ISO3 codes for easy matching with \n    # Geographical Maps data\n    iso_a3 = countrycode::countrycode(country, \"country.name\", \"iso3c\") \n  )\n\n# Retrieve the world map data\nworld_map &lt;- rnaturalearth::ne_countries(\n  scale = \"small\",      # Use small scale for manageable detail\n  returnclass = \"sf\"    # Return as an 'sf' object for spatial handling\n  )\n\n# Add a custom Google font for captions\nfont_add_google(\"Saira Extra Condensed\", \"caption_font\")\nshowtext_auto()           # Automatically apply custom fonts\n\n# Display the size of the world_map object in KB\n# object.size(world_map) |&gt; print(units = \"Kb\")\n\n# Define colors for country fill and text\n# Fill color palette for countries\nfill_palette &lt;- paletteer::paletteer_d(\"khroma::stratigraphy\")\n\n# Define a darker color palette for text labels\ncolour_palette &lt;- fill_palette |&gt; \n  str_sub(start = 1, end = 7) |&gt;  # Truncate hex codes to 6 characters\n  colorspace::darken(0.5)         # Darken colors by 50% for better contrast\n\n\n\n\nStep 2: Converting the data into a “tidy” tibble.\nIn this code snippet, we refine the world_map data and visualize it in the Mercator projection using the ggplot2 package. We start by selecting relevant columns, grouping by country name, and keeping the entry with the highest population estimate for countries with multiple entries. After joining this map data with the cia_data dataset, we filter out any countries without population data and apply the Pseudo-Mercator projection (CRS 3857) using {sf}’s st_transform() function. Finally, we use ggplot2 to plot the world map with geom_sf() and set a minimal theme and informative title and caption.\n\n\n\nTable 1\n\n\n\nCode\n# Filter, join, and transform world map data for plotting\n\nworld_map &lt;- world_map |&gt; \n  select(name, geometry, pop_est, iso_a3) |&gt;      # Select relevant columns\n  group_by(name) |&gt;                               # Group by country name\n  slice_max(order_by = pop_est, n = 1) |&gt;         # Retain country entry with max population estimate\n  left_join(cia_data) |&gt;                          # Join with CIA Factbook data\n  filter(!is.na(population)) |&gt;                   # Filter out entries without population data\n  st_transform(crs = 3857) |&gt;                     # Transform to Psuedo-Mercator projection (CRS = 3857)\n  ungroup()\n\n\n\n\n\n\n\n\nTable 2: The sf object morld map to be used in the susequent analysis\n\n\n\n\n\n\n\n\n\nName\nPop Est\nIso a 3\nCountry\nArea\nBirth Rate\nDeath Rate\nInfant Mortality Rate\nInternet Users\nLife Exp at Birth\nMaternal Mortality Rate\nNet Migration Rate\nPopulation\nPopulation Growth Rate\n\n\n\n\nAfghanistan\n38,041,754\nAFG\nAfghanistan\n652,230\n38.8\n14.1\n117.2\n1,000,000.0\n50.5\n460.0\n−1.8\n31,822,848\n2.3\n\n\nAlbania\n2,854,191\nALB\nAlbania\n28,748\n12.7\n6.5\n13.2\n1,300,000.0\n78.0\n27.0\n−3.3\n3,020,209\n0.3\n\n\nAlgeria\n43,053,054\nDZA\nAlgeria\n2,381,741\n24.0\n4.3\n21.8\nNA\n76.4\n97.0\n−0.9\n38,813,722\n1.9\n\n\nAngola\n31,825,295\nAGO\nAngola\n1,246,700\n39.0\n11.7\n80.0\nNA\n55.3\n450.0\n0.5\n19,088,106\n2.8\n\n\nArgentina\n44,938,712\nARG\nArgentina\n2,780,400\n16.9\n7.3\n10.0\n13,694,000.0\n77.5\n77.0\n0.0\n43,024,374\n0.9\n\n\nArmenia\n2,957,731\nARM\nArmenia\n29,743\n13.9\n9.3\n14.0\n208,200.0\n74.1\n30.0\n−5.9\n3,060,631\n−0.1\n\n\nAustralia\n25,364,307\nAUS\nAustralia\n7,741,220\n12.2\n7.1\n4.4\n15,810,000.0\n82.1\n7.0\n5.7\n22,507,617\n1.1\n\n\nAustria\n8,877,067\nAUT\nAustria\n83,871\n8.8\n10.4\n4.2\n6,143,000.0\n80.2\n4.0\n1.8\n8,223,062\n0.0\n\n\nAzerbaijan\n10,023,318\nAZE\nAzerbaijan\n86,600\n17.0\n7.1\n26.7\n2,420,000.0\n71.9\n43.0\n0.0\n9,686,210\n1.0\n\n\nBahamas\n389,482\nBHS\nBahamas, The\n13,880\n15.6\n7.0\n12.5\n115,800.0\n71.9\n47.0\n0.0\n321,834\n0.9\n\n\nBangladesh\n163,046,161\nBGD\nBangladesh\n143,998\n21.6\n5.6\n45.7\n617,300.0\n70.7\n240.0\n0.0\n166,280,712\n1.6\n\n\nBelarus\n9,466,856\nBLR\nBelarus\n207,600\n10.9\n13.5\n3.6\n2,643,000.0\n72.2\n4.0\n0.8\n9,608,058\n−0.2\n\n\nBelgium\n11,484,055\nBEL\nBelgium\n30,528\n10.0\n10.8\n4.2\n8,113,000.0\n79.9\n8.0\n1.2\n10,449,361\n0.0\n\n\nBelize\n390,353\nBLZ\nBelize\n22,966\n25.1\n6.0\n20.3\n36,000.0\n68.5\n53.0\n0.0\n340,844\n1.9\n\n\nBenin\n11,801,151\nBEN\nBenin\n112,622\n36.5\n8.4\n57.1\nNA\n61.1\n350.0\n0.0\n10,160,556\n2.8\n\n\nBhutan\n763,092\nBTN\nBhutan\n38,394\n18.1\n6.8\n37.9\n50,000.0\n69.0\n180.0\n0.0\n733,643\n1.1\n\n\nBolivia\n11,513,100\nBOL\nBolivia\n1,098,581\n23.3\n6.6\n38.6\n1,103,000.0\n68.5\n190.0\n−0.7\n10,631,486\n1.6\n\n\nBosnia and Herz.\n3,301,000\nBIH\nBosnia and Herzegovina\n51,197\n8.9\n9.6\n5.8\n1,422,000.0\n76.3\n8.0\n−0.4\n3,871,643\n−0.1\n\n\nBotswana\n2,303,697\nBWA\nBotswana\n581,730\n21.3\n13.3\n9.4\n120,000.0\n54.1\n160.0\n4.6\n2,155,784\n1.3\n\n\nBrazil\n211,049,527\nBRA\nBrazil\n8,514,877\n14.7\n6.5\n19.2\n75,982,000.0\n73.3\n56.0\n−0.1\n202,656,788\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\nKey Learning: Using geom_text_repel() in place of geom_text_sf() with stat = \"sf_coordinates\"\nIn this code, we generate two versions of a world map using the Mercator projection (CRS = 3857). The first plot demonstrates how using geom_sf_text() without any adjustment can lead to overlapping labels, particularly in densely populated areas. The second plot corrects this with geom_text_repel() from the {ggrepel} package (Slowikowski 2024), which dynamically adjusts label positions to prevent overlap and improve readability. Each map includes labels based on country name, and the label sizes vary by population, offering a clear contrast between the two approaches for displaying map text labels.\n\n\nCode\n# Plot the transformed world map data with overlapping labels\ng &lt;- ggplot(world_map) +\n  \n  # Draws the base map with country shapes\n  geom_sf(\n    linewidth = 0.1\n  ) +    \n  \n  # Adds country names as labels, without overlap prevention\n  geom_sf_text(\n    mapping = aes(\n      label = country\n    )\n  ) +\n  \n  # Applies a minimal theme for a clean visual layout\n  theme_minimal() +           \n  \n  # Sets title, subtitle, and caption for the plot\n  labs(\n    title = \"World Map: Labels Overlapping when using geom_sf_text()\",\n    subtitle = \"Map in the Mercator Projection (CRS = 3857)\",\n    caption = \"Source: {rnaturalearth} package data retrieved with ne_countries() function\"\n  ) +\n  \n  theme(\n    panel.grid = element_line(\n      linewidth = 0.1\n    )\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"cartogram_types_1.png\"),\n  plot = g,\n  height = 600,\n  width = 800,\n  units = \"px\"\n)\n\n# Plot the transformed world map data with repelled labels\ng &lt;- ggplot(world_map) +\n  \n  # Draws the base map with country shapes\n  geom_sf(\n    linewidth = 0.1,       # Sets line width for label positioning\n    colour = \"grey10\"\n  ) +    \n  \n  # Adds country names as labels with repel effect to prevent overlap\n  geom_text_repel(\n    mapping = aes(\n      label = country,\n      geometry = geometry,\n      size = population\n    ),\n    stat = \"sf_coordinates\",   # Sets the stat for spatial coordinates\n    family = \"caption_font\",   # Sets the font family for labels\n    force_pull = 100,\n    force = 0.01,\n    linewidth = 0.01\n  ) +\n  \n  # Scales the size of labels based on population\n  scale_size_continuous(\n    range = c(5, 25)\n  ) +\n  \n  # Applies a minimal theme for a clean visual layout\n  theme_minimal(\n    base_size = 80\n  ) +    \n    \n  # Sets title, subtitle, and caption for the plot\n  labs(\n    title = \"World Map: Labels with geom_text_repel() with stat = \\\"sf_coordinates\\\"\",\n    caption = \"Source: {rnaturalearth} package data retrieved with ne_countries() function\",\n    x = NULL, y = NULL\n  ) +\n  \n  # Removes the legend for size\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_line(\n      linewidth = 0.01\n    )\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"cartogram_types_2.png\"),\n  plot = g,\n  height = 3700,\n  width = 4900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Basic World Map: With no effort to prevent overlapping of labels\n\n\n\n\n\n\n\n\n\nFigure 2: Labels Repelled from each other to prevent overlapping, using geom_text_repel() from package {ggrepel}\n\n\n\n\n\nStep 3: Converting geometry into Cartograms geometry using {cartogram}\nIn this step, we generate three types of cartograms based on population data, each offering a unique way to represent global population distribution using the {cartogram} package. First, we transform the world map data to the Mercator projection (EPSG 3857), which is the standard projection for web maps. We then create three cartograms:\n\na contiguous cartogram that distorts countries proportionally to population while maintaining geographic adjacency,\na Dorling cartogram that represents each country as a circle sized by population, and\na non-contiguous cartogram that allows countries to resize independently, resulting in more accurate shapes but less geographic continuity.\n\n\n# Transforming the data to different cartogram types based on population\n\n# Create a contiguous cartogram where countries maintain adjacency\nworld_map_cont &lt;- cartogram::cartogram_cont(world_map, \"population\")\n\n# Create a Dorling cartogram where each country is represented by a circle\nworld_map_dorling &lt;- cartogram::cartogram_dorling(world_map, \"population\")\n\n# Create a non-contiguous cartogram where countries resize independently\nworld_map_ncont &lt;- cartogram::cartogram_ncont(world_map, \"population\")\n\n\n\n\nResults\n\nType 1: A Continuous Cartogram\nIn this code, we generate a contiguous cartogram plot, shown in Figure 3, using {ggplot2} and {sf} libraries, with countries sized according to population. The code begins by arranging world_map_cont in descending order of population (so that the countries with larger population are displayed first, while we use the argument check_overlap = TRUE with geom_sf_text(). The cartogram plot is created using geom_sf() for shapes and geom_sf_text() for country labels, with label sizes reflecting population. Manual scales are applied to align fill and text colors with predefined palettes. The plot includes a centered title and minimal theme.\n\n\nCode\n# Arrange the cartogram data by population in descending order\ng &lt;- world_map_cont |&gt; \n  arrange(desc(population)) |&gt; \n\n# Initialize ggplot, mapping fill and color aesthetics to country\n  ggplot(\n    mapping = aes(\n      fill = country,\n      colour = country\n    )\n  ) +\n\n# Add the country shapes without borders\n  geom_sf(\n    colour = \"transparent\"\n  ) +\n\n# Add text labels for each country with size proportional to population\n  geom_sf_text(\n    mapping = aes(\n      label = country,\n      size = population,\n      geometry = geometry\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = TRUE\n  ) +\n\n# Set continuous scale for text size within a specified range\n  scale_size_continuous(\n    range = c(1, 10)\n  ) +\n\n# Apply manual color scale for fill and outline of countries\n  scale_fill_manual(\n    values = fill_palette\n  ) +\n  scale_colour_manual(\n    values = colour_palette\n  ) +\n\n# Add plot title and remove x and y axis labels\n  labs(\n    x = NULL, y = NULL,\n    title = \"A contiguous Cartogram of countries' population\"\n  ) +\n\n# Apply a minimal theme with custom font and size\n  theme_minimal(\n    base_family = \"caption_font\",\n    base_size = 16\n  ) +\n\n# Customize plot appearance with centered title and invisible legend\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_line(\n      colour = \"grey90\",\n      linetype = 3,\n      linewidth = 0.1\n    ),\n    plot.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\"),\n      size = 32\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# Save the plot as a PNG with defined size and white background\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"cartogram_types_3.png\"),\n  height = 900,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 3: A World Map Cartogram, with countries sized by population, using data from CIA World Factbook. The contiguous cartogram ensures that neighbousing countries keep touching each other, although shapes are distorted.\n\n\n\n\n\nType 2: A Non-continuous Cartogram\nThe next code chunk generates a non-contiguous cartogram, shown in Figure 4, where countries are resized according to population but maintain their original shapes, making it easier to recognize familiar geographic forms.. It uses two layers of geom_sf() to add the original world map with a grey outline for context and the resized cartogram countries with a semi-transparent overlay. Text labels are added for each country, sized by population, without overlapping.\n\n\nCode\n# Arrange the non-contiguous cartogram data by population in descending order\ng &lt;- world_map_ncont |&gt; \n  arrange(desc(population)) |&gt; \n\n# Initialize ggplot, mapping fill and color aesthetics to country\n  ggplot(\n    mapping = aes(\n      fill = country,\n      colour = country\n    )\n  ) +\n\n# Add the original world map with grey borders and white fill\n  geom_sf(\n    data = world_map,\n    fill = \"white\",\n    colour = \"grey60\",\n    linewidth = 0.1\n  ) +\n\n# Add the non-contiguous cartogram countries with transparency\n  geom_sf(\n    colour = \"transparent\",\n    alpha = 0.75\n  ) +\n\n# Add text labels for each country with size proportional to population\n  geom_sf_text(\n    mapping = aes(\n      label = country,\n      size = population,\n      geometry = geometry\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = FALSE\n  ) +\n\n# Set continuous scale for text size within a specified range\n  scale_size_continuous(\n    range = c(1, 10)\n  ) +\n\n# Apply manual color scale for fill and outline of countries\n  scale_fill_manual(\n    values = fill_palette\n  ) +\n  scale_colour_manual(\n    values = colour_palette\n  ) +\n\n# Add plot title and remove x and y axis labels\n  labs(\n    x = NULL, y = NULL,\n    title = \"A non-contiguous Cartogram of countries' population - preserves the country shapes\"\n  ) +\n\n# Apply a minimal theme with custom font and size\n  theme_minimal(\n    base_family = \"caption_font\",\n    base_size = 16\n  ) +\n\n# Customize plot appearance with centered title and invisible legend\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_line(\n      colour = \"grey90\",\n      linetype = 3,\n      linewidth = 0.1\n    ),\n    plot.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\"),\n      size = 28\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# Save the plot as a PNG with defined size and white background\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"cartogram_types_4.png\"),\n  height = 900,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: A non-contiguous cartogram of countries population, using data from CIA Factbook, shows that while shapes of countries are preserved, their neighbouring countries don’t touch each others’ borders anymore.\n\n\n\n\n\nType 3: A non-overlapping circles Cartogram\nThis code snippet creates a Dorling cartogram, shown in Figure 5, where countries are represented as non-overlapping circles sized according to their populations. The ggplot function is used to set up the aesthetic mappings for fill and color based on the country. The geom_sf() function is employed to add the circular representations of countries without outlines, while geom_sf_text() adds text labels for each country, sized according to their populations.\n\n\nCode\n# Arrange the Dorling cartogram data by population in descending order\ng &lt;- world_map_dorling |&gt; \n  arrange(desc(population)) |&gt; \n\n# Initialize ggplot, mapping fill and color aesthetics to country\n  ggplot(\n    mapping = aes(\n      fill = country,\n      colour = country\n    )\n  ) +\n\n# Add the non-overlapping circles representing countries\n  geom_sf(\n    colour = \"transparent\"\n  ) +\n\n# Add text labels for each country, sized by population\n  geom_sf_text(\n    mapping = aes(\n      label = country,\n      size = population,\n      geometry = geometry\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\"\n  ) +\n\n# Set continuous scale for text size within a specified range\n  scale_size_continuous(\n    range = c(1, 10)\n  ) +\n\n# Apply manual color scale for fill and Text of countries\n  scale_fill_manual(\n    values = fill_palette\n  ) +\n  scale_colour_manual(\n    values = colour_palette\n  ) +\n\n# Add plot title and remove x and y axis labels\n  labs(\n    x = NULL, y = NULL,\n    title = \"A non-overlapping circles Cartogram of countries' population.\"\n  ) +\n\n# Apply a map theme with custom font and size\n  ggthemes::theme_map(\n    base_family = \"caption_font\",\n    base_size = 16\n  ) +\n\n# Customize plot appearance with centered title and invisible legend\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\"),\n      size = 28\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# Save the plot as a PNG with defined size and white background\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"cartogram_types_5.png\"),\n  height = 900,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\n\n\n\n\nReferences\n\nJeworutzki, Sebastian. 2023. “Cartogram: Create Cartograms with r.” https://CRAN.R-project.org/package=cartogram.\n\n\nPebesma, Edzer, and Roger Bivand. 2023. “Spatial Data Science: With Applications in r.” https://doi.org/10.1201/9780429459016.\n\n\nSlowikowski, Kamil. 2024. “Ggrepel: Automatically Position Non-Overlapping Text Labels with ’Ggplot2’.” https://CRAN.R-project.org/package=ggrepel.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the Tidyverse” 4: 1686. https://doi.org/10.21105/joss.01686."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-1-setting-up-basics",
    "href": "geocomputation/osm_driving_directions.html#step-1-setting-up-basics",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 1: Setting up basics",
    "text": "Step 1: Setting up basics\nThis code initializes an R project for geospatial data analysis and visualization, utilizing multiple packages for enhanced map presentation, styling, and data wrangling:\n\nData Handling & Visualization: Packages like tidyverse provide core data manipulation tools and ggplot2 for visualizations.\nSpatial Data Management: sf simplifies handling spatial objects in a tidy framework, and osrm connects R to the Open Source Routing Machine for geospatial route calculations.\nGeocoding: tidygeocoder automates address-based geocoding.\nMap Enhancements: ggspatial adds visual elements like scale bars; ggrepel prevents overlapping labels for clear visuals.\nCustom Fonts: sysfonts and showtext allow use of Google Fonts, applied through a custom theme.\nPlot Layouts & Tables: patchwork enables combining ggplot plots, and gt produces elegant HTML tables.\n\nThe code defines custom fonts for plot titles and body text using Google Fonts (e.g., “Barlow”) and sets up a theme function, theme_drive, for applying a modern, minimal aesthetic in ggplot2. It also specifies text color and font-family defaults for labels in plots.\n\n\nCode\nlibrary(tidyverse)     # Data Wrangling and ggplot2\nlibrary(sf)            # Handle spatial data in R in a tidy way\nlibrary(tidygeocoder)  # Automated geocoding of addresses\nlibrary(osrm)          # Access OSRM through R\nlibrary(ggrepel)       # Nicer non-overlapping labels\nlibrary(glue)          # Easier string interpolation\nlibrary(scales)        # Nicer labeling functions\nlibrary(patchwork)     # Combine plots made in ggplot2\nlibrary(ggspatial)     # Nicer map features like scale bars\nlibrary(showtext)      # Displaying google fonts\nlibrary(sysfonts)      # Getting google fonts into R\nlibrary(gt)            # Displaying beautiful HTML tables \n\n# A font for the titles and major points\nsysfonts::font_add_google(\"Barlow\", \"title_font\")\n\n# A font for the body and text\nsysfonts::font_add_google(\"Barlow Condensed\", \"body_font\")\n\n# Allow R graphics devices to display these fonts\nshowtext::showtext_auto()\n\n# Text colour\ntext_col &lt;- \"grey20\"\n\n# Custom ggplot theme to make pretty plots\n# Get the font at https://fonts.google.com/specimen/Overpass\n\ntheme_drive &lt;- function(...) {\n  theme_void(\n    base_family = \"body_font\",\n    base_size = 14\n  ) +\n  theme(\n    text = element_text(\n      colour = text_col,\n      family = \"body_font\",\n      hjust = 0.5\n    ),\n    ...\n  )\n}\n\n# Make labels use the fonts specified by default\nupdate_geom_defaults(\"label_repel\", list(family = \"body_font\",\n                                         colour = text_col))\nupdate_geom_defaults(\"label\", list(family = \"body_font\",\n                                         colour = text_col))\nupdate_geom_defaults(\"text_repel\", list(family = \"body_font\",\n                                         colour = text_col))\nupdate_geom_defaults(\"text\", list(family = \"body_font\",\n                                         colour = text_col))"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-2-a-road-trip-plan",
    "href": "geocomputation/osm_driving_directions.html#step-2-a-road-trip-plan",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 2: A Road Trip Plan",
    "text": "Step 2: A Road Trip Plan\nLet us plan a road trip along the northern shores of the Mediterranean Sea, hopping along the famous sites in the capitals and important cities of some countries. This code snippet uses R to create a table of famous attractions across several European countries, geocodes each location to obtain its latitude and longitude, and displays the data in a formatted table with map coordinates:\n\nData Setup: A sample dataset is created with columns for country, capital, attraction, and address using dplyr.\nGeocoding: The tidygeocoder package is used to automatically retrieve latitude and longitude coordinates based on the address, using OpenStreetMap’s geocoding service.\nSpatial Transformation: Once coordinates are obtained, sf converts them into a simple feature (SF) object, setting the coordinate system to EPSG:4326 for geographic data.\nTabular Display: The data is formatted as a stylish HTML table using gt and gtExtras for theme styling.\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(gt)\n\nrawdata &lt;- dplyr::tribble(\n  ~id, ~country,               ~capital,    ~attraction,                   ~address,\n  1,   \"Greece\",               \"Athens\",    \"Acropolis Museum\",            \"15 Dionysiou Areopagitou St, Athens 11742\",\n  2,   \"Albania\",              \"Tirana\",    \"Skanderbeg Square\",           \"Sheshi Skënderbej, Tirana 1001\",\n  3,   \"Montenegro\",           \"Podgorica\", \"Millennium Bridge\",           \"Cetinjski Put, Podgorica 81000\",\n  4,   \"Bosnia and Herzegovina\",\"Sarajevo\", \"Baščaršija (Old Bazaar)\",     \"Baščaršija, Sarajevo 71000\",\n  5,   \"Croatia\",              \"Zagreb\",    \"Ban Jelačić Square\",          \"Trg bana Josipa Jelačića, Zagreb 10000\",\n  6,   \"Slovenia\",             \"Ljubljana\", \"Ljubljana Castle\",            \"Grajska planota 1, Ljubljana 1000\",\n  7,   \"Italy\",                \"Venice\",    \"St. Mark's Basilica\",         \"Piazza San Marco, Venice 30124\",\n  8,   \"Italy\",                \"Florence\",  \"Piazza del Duomo\",            \"Piazza del Duomo, Florence 50122\",\n  9,   \"Italy\",                \"Rome\",      \"Trevi Fountain\",              \"Piazza di Trevi, Rome 00187\"\n)\n\n\n# Convert latitude and longitudes into SF Coordinates\n\n\ndf &lt;- rawdata |&gt; \n  \n  # Compile a full address to be used for finding the coordinates\n  # mutate(\n  #   address = paste(\n  #     destination,\n  #     capital, \n  #     country,\n  #     sep = \", \"\n  #   )\n  # ) |&gt; \n  tidygeocoder::geocode(\n    address = address,\n    # country = country,\n    # city = capital,\n    method = \"osm\"\n  ) |&gt; \n  st_as_sf(\n    coords = c(\"long\", \"lat\"),\n    crs = st_crs(\"EPSG:4326\")\n  )\n\n\n\n\n\n\nTable 1: The data to be used for further analysis\n\n\n\n\n\n\n\n\n\nid\ncountry\ncapital\nattraction\naddress\ngeometry\n\n\n\n\n1\nGreece\nAthens\nAcropolis Museum\n15 Dionysiou Areopagitou St, Athens 11742\nc(23.7302954, 37.9303789)\n\n\n2\nAlbania\nTirana\nSkanderbeg Square\nSheshi Skënderbej, Tirana 1001\nc(19.8182412, 41.3271148)\n\n\n3\nMontenegro\nPodgorica\nMillennium Bridge\nCetinjski Put, Podgorica 81000\nc(19.2436765, 42.4413965)\n\n\n4\nBosnia and Herzegovina\nSarajevo\nBaščaršija (Old Bazaar)\nBaščaršija, Sarajevo 71000\nc(18.430885, 43.8590435)\n\n\n5\nCroatia\nZagreb\nBan Jelačić Square\nTrg bana Josipa Jelačića, Zagreb 10000\nc(15.9765701, 45.8130054)\n\n\n6\nSlovenia\nLjubljana\nLjubljana Castle\nGrajska planota 1, Ljubljana 1000\nc(14.5085094926128, 46.0488354)\n\n\n7\nItaly\nVenice\nSt. Mark's Basilica\nPiazza San Marco, Venice 30124\nc(12.3385088944988, 45.4342591)\n\n\n8\nItaly\nFlorence\nPiazza del Duomo\nPiazza del Duomo, Florence 50122\nc(11.2554773666595, 43.7731014)\n\n\n9\nItaly\nRome\nTrevi Fountain\nPiazza di Trevi, Rome 00187\nc(12.4836123990993, 41.90089955)"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-3-some-custom-functions",
    "href": "geocomputation/osm_driving_directions.html#step-3-some-custom-functions",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 3: Some Custom Functions",
    "text": "Step 3: Some Custom Functions\nThis code defines a set of custom functions in R to format durations, distances, and handle conversions between different units, useful for working with geographic and travel data:\n\nFormatting Durations: fmt_duration() takes an input in minutes and converts it into a readable string format. Durations are rounded to the nearest 15 minutes and formatted to display in hours and minutes. When durations exceed 24 hours, days are factored into the calculation by converting them to hours for accurate display.\nDistance Formatting:\n\nfmt_miles and fmt_km utilize scales::label_number() to format distances in miles and kilometers, respectively, with suffixes and thousand separators for clarity.\n\nDistance Conversions: Functions for converting between miles, meters, and kilometers:\n\nmiles_to_meters() converts miles to meters.\nmeters_to_miles() and km_to_miles() handle conversions from meters and kilometers to miles.\n\n\n\n\nCode\n# Credits: Andrew Weiss\n# URL: https://www.andrewheiss.com/blog/2023/06/01/\n#      geocoding-routing-openstreetmap-r/#packages-and-functions\n\n# Format duration in minutes and hours\n# This function takes a numeric input of a duration in minutes,\n# rounds it to the nearest 15 minutes, and formats the result as a string\n# indicating the number of hours and minutes in the duration.\n\nfmt_duration &lt;- function(x) {\n  \n  # Round to the nearest 15 minutes\n  n_seconds &lt;- round(seconds(x * 60) / (15 * 60)) * (15 * 60)\n  n_seconds &lt;- seconds_to_period(n_seconds)\n  \n  out &lt;- map_chr(n_seconds, \\(n) {\n    if (seconds(n) &lt;= 59) {\n      # If this is less than an hour, don't format anything with hours\n      glue(\"{MM} minutes\", MM = minute(n))\n    } else {\n      # The formatting is required in terms of hours only. When the \n      # duration exceeds 24 hours, `seconds_to_period()` converts the \n      # duration into days (e.g., `seconds_to_period(60 * 60 * 24)` returns \n      # \"1d 0H 0M 0S\") and displays zero hours. Therefore, the day portion \n      # of the period is extracted, multiplied by 24, and added to the \n      # hour component intended for display. \n      extra_day_hours &lt;- day(n) * 24\n  \n      glue(\"{HH} hour{s} {MM} minutes\",\n        HH = scales::label_comma()(hour(n) + extra_day_hours),\n        MM = minute(n),\n        s = ifelse(hour(n) == 1, \"\", \"s\")\n      )\n    }\n  })\n  \n  return(out)\n}\n\nfmt_miles &lt;- scales::label_number(\n  accuracy = 10, \n  suffix = \" miles\", \n  big.mark = \",\"\n  )\n\nfmt_km &lt;- scales::label_number(\n  accuracy = 10, \n  suffix = \" km\", \n  big.mark = \",\"\n  )\n\n\nmiles_to_meters &lt;- function(x) {\n  x * 1609.344\n}\n\nmeters_to_miles &lt;- function(x) {\n  x / 1609.344\n}\n\nkm_to_miles &lt;- function(x) {\n  meters_to_miles(x * 1000)\n}"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-4-the-base-map-and-the-driving-locations",
    "href": "geocomputation/osm_driving_directions.html#step-4-the-base-map-and-the-driving-locations",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 4: The base map and the driving locations",
    "text": "Step 4: The base map and the driving locations\nThis code creates a custom map showing key tourist attractions within the calculated bounding box of selected European countries:\n\nBounding Box Calculation:\n\nThe bounding box for mapped points is set with an additional degree of expansion (edi), extending the box slightly around all locations. This is calculated with st_bbox() using geometries in df.\n\nBasemap Creation:\n\nA basemap of European countries is created using rnaturalearth data, filtering out small states like Vatican City and San Marino. The map’s area data is computed for further customization if needed.\n\nMap Plotting:\n\nggplot2 and sf add visual layers:\n\nCountry boundaries as background with geom_sf().\nCountry names with partially transparent, bold labels via geom_sf_text().\nTourist attraction points and city names using red markers and labels.\n\n\n\n\n\nCode\n# Compute the bounding box for the maps\n# Expansion outside bounding box in degrees = edi\nedi = 0.5\ndrive_bbox &lt;- st_bbox(df$geometry) + c(-2 * edi, -2.5 * edi, edi, edi)\n\n\nbasemap &lt;- rnaturalearth::ne_countries(scale = 50) |&gt;\n  select(name, iso_a3, geometry) |&gt; \n  filter(!(name %in% c(\"Vatican\", \"San Marino\"))) |&gt; \n  st_crop(drive_bbox) |&gt; \n  mutate(area = as.numeric(st_area(geometry)))\n\ng &lt;- ggplot(basemap) +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(\n      label = name\n    ),\n    alpha = 0.5,\n    fontface = \"bold\",\n    nudge_y = +0.3\n  ) +\n  geom_sf(\n    data = df,\n    colour = \"darkred\",\n    size = 2,\n    alpha = 0.5\n  ) +\n  geom_sf_text(\n    data = df,\n    mapping = aes(label = capital),\n    colour = \"darkred\",\n    nudge_y = -0.2\n  ) +\n  labs(x = NULL, y = NULL)\n\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_4.png\"),\n  plot = g,\n  height = 900,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: A basic map showing the selected cities and the map of selected countries using data available in {rnaturalearth} and ne_countries()"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-5-getting-the-routes-and-a-raw-map-of-the-routes",
    "href": "geocomputation/osm_driving_directions.html#step-5-getting-the-routes-and-a-raw-map-of-the-routes",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 5: Getting the Routes and a raw map of the routes",
    "text": "Step 5: Getting the Routes and a raw map of the routes\nThis code generates a visual map illustrating the shortest driving routes between selected European cities, based on OpenStreetMap data:\n\nRoute Data Preparation:\n\nStarting with df (containing cities and their coordinates), cities are paired sequentially as origins and destinations using lead(). The data is trimmed to exclude the final unpaired row.\nosrmRoute() retrieves the shortest driving route between each origin and destination pair, with the computed route details stored in a nested column named route.\n\nUnnesting and Formatting:\n\nThe route column is expanded to reveal route-specific data (geometry, distance, duration). Route geometry is then set as the primary spatial feature.\nCustom functions fmt_km() and fmt_duration() format the route’s distance and duration for clear labeling.\n\nMap Plotting:\n\nggplot2 visualizes the data in layers:\n\nA basemap of European countries, created earlier, serves as the background.\nCities are marked in red, with labels for capital cities slightly adjusted for readability.\nDriving routes between cities are drawn as connecting lines using the computed route_geometry.\n\n\n\n\n\nCode\ndfroutes &lt;- df|&gt; \n  rename(\n    origin_geometry = geometry,\n    origin_city = capital\n  ) |&gt;  \n  mutate(\n    destination_geometry = lead(origin_geometry),\n    destination_city = lead(origin_city)\n  )  |&gt; \n  slice_head(n = (nrow(df) - 1)) |&gt; \n  \n  # Let functions compute on our data frame a row-at-a-time\n  rowwise() |&gt; \n  \n  # Getting the shortest route between the two cities\n  mutate(route = osrmRoute(\n    src = origin_geometry, \n    dst = destination_geometry)\n  ) |&gt; \n\n# The route details are stored in a nested list column called `route`, # which we’ll unnest. This produces a data frame with three geometry \n# columns—for origin, destination, and route—so we’ll set the route \n# column as the primary geometry (allowing us to use `geom_sf(data = routes_geocoded)` directly).\n  \n  unnest(route, names_sep = \"_\") |&gt; \n  st_set_geometry(\"route_geometry\") |&gt; \n  mutate(\n    distance_text = fmt_km(route_distance),\n    duration_text = fmt_duration(route_duration)\n  )\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = basemap\n  ) +\n  geom_sf(\n    data = df,\n    colour = \"red\",\n    size = 3\n  ) +\n  geom_sf_text(\n    data = df,\n    aes(label = capital),\n    nudge_y = -0.3,\n    size = 5\n  ) +\n  geom_sf(\n    data = dfroutes,\n    mapping = aes(\n      geometry = route_geometry\n    )\n  ) +\n  labs(\n    x = NULL, y = NULL\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_2.png\"),\n  plot = g,\n  height = 900,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 2: A simple map of the country boundaries [from {rnaturalearth} and function ne_countries()] with the route computed by osrmRoute() from {osrm} and selected destination cities as red dots."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-6-a-nice-stadia-map-background-map",
    "href": "geocomputation/osm_driving_directions.html#step-6-a-nice-stadia-map-background-map",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 6: A nice Stadia Map background map",
    "text": "Step 6: A nice Stadia Map background map\nThis code retrieves and customizes a basemap using Stadia Maps, overlaying it with geospatial data in EPSG:3857, a coordinate reference system commonly used for web mapping.\n\nAPI Setup:\n\nThe Stadia Maps API is registered with the register_stadiamap() function, allowing access to map tiles.\n\nBounding Box Definition:\n\nA bounding box (dv_bbox) is defined using the limits of the area of interest. The bounding box is adjusted to Stadia Maps’ format, setting boundaries based on longitude and latitude.\n\nFetching Map Tiles:\n\nget_stadiamap() retrieves map tiles with terrain background style (maptype = \"stamen_terrain_background\"), appropriate for visualizing geographic contexts.\n\nCoordinate System Transformation:\n\nA custom function, ggmap_bbox(), redefines the map’s bounding box to EPSG:3857, necessary for layering sf objects over the raster map. This transformation is critical for accurate overlay alignment.\n\nMap Overlay and Export:\n\nUsing ggmap(), the transformed Stadia basemap is displayed. The map, including overlaid geospatial features, is saved as a high-resolution image (osm_driving_directions_3.png) with ggsave().\n\n\n\n\nCode\n# ggmap::register_stadiamap(\"YOUR API KEY HERE\")\n\n# A bounding box in the format c(lowerleftlon, lowerleftlat, upperrightlon, upperrightlat)\ndv_bbox &lt;- drive_bbox\nnames(dv_bbox) &lt;- c(\"left\", \"bottom\", \"right\", \"top\")\n\n\n# Getting the map tiles\nbasemap2 &lt;- ggmap::get_stadiamap(\n  bbox = dv_bbox,\n  zoom = 7,\n  maptype = \"stamen_terrain_background\"\n)\nobject.size(basemap2) |&gt; print(units = \"Mb\")\n\nggmap::ggmap(basemap2)\n\n# Starting the process of Overlaying the geom_sf() data on this\n# Most important is to add the inherit.aes = FALSE argument.\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nbasemap_sf &lt;- ggmap_bbox(basemap2)\n\ng &lt;- ggmap::ggmap(basemap2) +\n  labs(x = NULL, y = NULL)\n\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_3.png\"),\n  plot = g,\n  height = 900,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 3: The base map retrieved in the form of raster tiles, from {ggmap} using get_stadia_maps() with the map style “Stamen Terrain Background”"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-7-the-overall-visualization",
    "href": "geocomputation/osm_driving_directions.html#step-7-the-overall-visualization",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 7: The overall visualization",
    "text": "Step 7: The overall visualization\nThis code snippet enhances the base map by overlaying spatial data, labels, and route details, creating a rich, layered map visualization with ggplot2 and ggmap. Here’s a breakdown of each step:\n\nBasemap Layer:\n\nUses ggmap::ggmap(basemap_sf) to display the raster map tiles retrieved and adjusted to EPSG:3857, enabling overlays of geospatial objects.\n\nCountry Boundaries and Names:\n\ngeom_sf() with transparency and thin lines adds country outlines, while geom_sf_text() displays country names proportionally sized by area.\n\nDriving Route:\n\nThe dfroutes dataset, containing route geometries between destinations, is layered with geom_sf(), color-coded for visibility.\n\nCity Locations and Labels:\n\ngeom_sf() highlights cities in red, while geom_text_repel() labels each city’s name, ensuring labels do not overlap with other map features.\n\nRoute Details:\n\ngeom_sf_label() displays distance labels along the route with partially transparent backgrounds, enhancing readability without cluttering.\n\nCoordinate System and Styling:\n\ncoord_sf() is set to EPSG:3857, matching the basemap. The theme_void() removes unnecessary plot elements for a clean map-focused look, with additional styling adjustments.\n\n\n\n\nCode\n# The base map raster tiles\ng &lt;- ggmap::ggmap(basemap_sf) +\n  \n  # Country boundaries\n  geom_sf(\n    data = basemap,\n    fill = \"transparent\",\n    colour = alpha(text_col, 0.3),\n    inherit.aes = F,\n    linewidth = 0.3\n  ) +\n  \n  # Country names\n  geom_sf_text(\n    data = basemap,\n    mapping = aes(label = name, size = area),\n    alpha = 0.5,\n    fontface = \"bold\",\n    inherit.aes = F\n  ) +\n  scale_size_continuous(range = c(5, 12)) +\n  \n  # The driving route\n  geom_sf(\n    data = dfroutes,\n    mapping = aes(\n      geometry = route_geometry\n    ),\n    inherit.aes = F,\n    colour = alpha(text_col, 0.8),\n    linewidth = 0.5\n  ) +\n  \n  # The cities to be visited\n  geom_sf(\n    data = df,\n    colour = \"red\",\n    size = 3, \n    inherit.aes = F,\n    alpha = 0.5\n  ) +\n  \n  # Names of cities\n  geom_text_repel(\n    data = df,\n    aes(\n      label = capital,\n      geometry = geometry\n    ),\n    inherit.aes = F,\n    stat = \"sf_coordinates\",\n    fontface = \"bold\",\n    size = 8\n  ) +\n  \n  # Route times and distances\n  geom_sf_label(\n    data = dfroutes,\n    mapping = aes(\n      label = paste0(distance_text)\n    ),\n    fill = alpha(\"white\", 0.5),\n    lineheight = 0.3,\n    inherit.aes = F,\n    label.size = unit(0, \"mm\")\n    \n  ) +\n  \n  # Coordinates and Scales\n  coord_sf(\n    crs = 3857\n  ) +\n  theme_void(\n    base_size = 40,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_1.png\"),\n  plot = g,\n  height = 9.25,\n  width = 10,\n  unit = \"cm\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: The completed overall visualization - with a base map of raster tiles from {ggmap} get_stadia_map(), overlaid country names and boundaries from {rnaturalearth} ne_countries(), and routes from {osrm} package."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-8-each-leg-of-the-trip-visualized-separately",
    "href": "geocomputation/osm_driving_directions.html#step-8-each-leg-of-the-trip-visualized-separately",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 8: Each leg of the trip visualized separately",
    "text": "Step 8: Each leg of the trip visualized separately\nThis code snippet generates individual map visualizations for each driving route using ggmap and ggplot2. Here’s an explanation of the process, which effectively creates a series of images showcasing routes between pairs of cities:\n\nLoop through Routes:\n\nThe for loop iterates over each row of the dfroutes dataframe, which contains driving route data between origin and destination cities.\n\nDefine Temporary Bounding Box:\n\nFor each route, a temporary bounding box is created using the st_bbox() function and expanded slightly to ensure that the route is well-framed in the map view.\n\nRetrieve Map Tiles:\n\nThe get_stadiamap() function fetches map tiles based on the temporary bounding box, specifying a zoom level and map type (e.g., “outdoors”).\n\nCrop Basemap:\n\nA cropped version of the original country basemap is created to match the bounding box of the current route, ensuring the country boundaries align with the area of interest.\n\nCreate Map Visualization:\n\nggmap::ggmap(temp_basemap) initializes the base map, onto which various layers are added:\n\nCountry Names: Displayed using geom_sf_text(), showing the names of countries within the bounding box.\nDriving Route: The specific route for the current iteration is drawn using geom_sf().\nCities: Both the origin and destination cities are represented with red points using geom_sf().\nCity Labels: City names are added with geom_text_repel(), ensuring that they do not overlap with each other or other elements.\nRoute Details: Distance and duration information are displayed using geom_sf_label(), formatted neatly for clarity.\n\n\nFinalizing the Map:\n\nCoordinate System: Set to EPSG:3857 for compatibility with the base map.\nTheme Adjustments: theme_void() is used to create a clean look, removing axes and grid lines.\n\n\nThis approach results in a series of visually consistent maps, each illustrating a distinct driving route between two cities, complete with detailed annotations and clear geographic context. The display is done using the Tabset Panels layout available in Quarto.\n\n\nCode\nfor (i in 1: nrow(dfroutes)) {\n \n  # A bounding box in the format (left, right, top, bottom) for {ggmap}\n  temp_bbox &lt;- st_bbox(\n    dfroutes |&gt; \n    slice(i)\n    ) + c(-1, -1, 1, 1)\n  names(temp_bbox) &lt;- c(\"left\", \"bottom\", \"right\", \"top\")\n  \n  # Getting the map tiles\n  temp_basemap &lt;- ggmap::get_stadiamap(\n    bbox = temp_bbox,\n    zoom = 8,\n    maptype = \"outdoors\"\n  )  \n  \n  temp_basemap &lt;- ggmap_bbox(temp_basemap)\n  \n  object.size(temp_basemap) |&gt; print(units = \"Mb\")\n  \n  temp_baselinemap &lt;- st_crop(basemap, temp_bbox)\n  \n  # The base map raster tiles\n  g &lt;- ggmap::ggmap(temp_basemap) +\n    \n    # Country boundaries\n    # geom_sf(\n    #   data = temp_baselinemap,\n    #   fill = \"transparent\",\n    #   colour = alpha(text_col, 0.3),\n    #   inherit.aes = F,\n    #   linewidth = 0.3\n    # ) +\n    \n    # Country names\n    geom_sf_text(\n      data = temp_baselinemap,\n      mapping = aes(label = name, size = area),\n      alpha = 0.5,\n      fontface = \"bold\",\n      inherit.aes = F\n    ) +\n    scale_size_continuous(range = c(5, 12)) +\n    \n    # The driving route\n    geom_sf(\n      data = slice(dfroutes, i),\n      mapping = aes(\n        geometry = route_geometry\n      ),\n      inherit.aes = F,\n      colour = alpha(text_col, 0.8),\n      linewidth = 0.5\n    ) +\n    \n    # The cities to be visited: origin\n    geom_sf(\n      data = slice(dfroutes, i),\n      mapping = aes(geometry = origin_geometry),\n      colour = \"red\",\n      size = 3, \n      inherit.aes = F,\n      alpha = 0.4\n    ) +\n    # The cities to be visited: destination\n    geom_sf(\n      data = slice(dfroutes, i),\n      mapping = aes(geometry = destination_geometry),\n      colour = \"red\",\n      size = 3, \n      inherit.aes = F,\n      alpha = 0.4\n    ) +\n    \n    # Names of cities: Origin\n    geom_text_repel(\n      data = slice(dfroutes, i),\n      aes(\n        label = origin_city,\n        geometry = origin_geometry\n      ),\n      inherit.aes = F,\n      stat = \"sf_coordinates\",\n      fontface = \"bold\",\n      size = 8\n    ) +\n    # Names of cities: Destination\n    geom_text_repel(\n      data = slice(dfroutes, i),\n      aes(\n        label = destination_city,\n        geometry = destination_geometry\n      ),\n      inherit.aes = F,\n      stat = \"sf_coordinates\",\n      fontface = \"bold\",\n      size = 8\n    ) +\n    \n    \n    # Route times and distances\n    geom_sf_label(\n      data = slice(dfroutes, i),\n      mapping = aes(\n        label = paste0(\n          distance_text,\n          \"\\n\",\n          \"(\",\n          duration_text,\n          \")\"\n        )\n      ),\n      fill = alpha(\"white\", 0.5),\n      lineheight = 0.3,\n      inherit.aes = F,\n      label.size = unit(0, \"mm\"),\n      size = 5,\n      fontface = \"bold\"\n    ) +\n    \n    # Coordinates and Scales\n    coord_sf(\n      crs = 3857\n    ) +\n    \n    theme_void(\n      base_size = 40,\n      base_family = \"body_font\"\n    ) +\n    theme(\n      legend.position = \"none\",\n      plot.margin = margin(0,0,0,0, \"mm\")\n    )\n  \n  ggsave(\n    filename = here::here(\"geocomputation\", \"images\",\n                          paste0(\"osm_driving_directions_leg\", i, \".png\")),\n    plot = g,\n    height = 6,\n    width = 6,\n    unit = \"cm\",\n    bg = \"white\"\n  )\n   \n}\n\n\n\nLeg 1Leg 2Leg 3Leg 4Leg 5Leg 6Leg 7Leg 8\n\n\n\n\n\n\n\n\nFigure 5: Day 1: Drive from Athens to Tirana.\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Day 2: Drive from Tirana to Padogorica.\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Day 3: Drive from Padogorica to Sarajevo.\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Day 4: Drive from Sarajevo to Zagreb.\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Day 5: Drive from Zagreb to Ljubljana.\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Day 6: Drive from Ljubljana to Venice.\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Day 7: Drive from Venice to Florence.\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Day 8: Drive from Florence to Rome."
  },
  {
    "objectID": "ggplot2_ext.html",
    "href": "ggplot2_ext.html",
    "title": "ggplot2 Extensions",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "geocomputation/chapter1.html",
    "href": "geocomputation/chapter1.html",
    "title": "Chapter 2: Geocomputation with R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter1.html#introduction",
    "href": "geocomputation/chapter1.html#introduction",
    "title": "Chapter 2: Geocomputation with R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter1.html#vector-data",
    "href": "geocomputation/chapter1.html#vector-data",
    "title": "Chapter 2: Geocomputation with R",
    "section": "2.2 Vector Data",
    "text": "2.2 Vector Data\n\nVector Data: Represents geographic features using points, lines, and polygons based on coordinate reference systems (CRS).\n\nExample: London’s coordinates c(-0.1, 51.5) in geographic CRS or c(530000, 180000) in projected CRS (British National Grid).\n\nCRS Overview:\n\nGeographic CRS uses lon/lat (0° longitude and latitude origin).\nProjected CRS, like the British National Grid, is based on Easting/Northing coordinates with positive values.\n\nKey dependencies / libraries used by the sf Package:\n\nGDAL: Handles geographic data formats\nPROJ: For CRS transformations\nGEOS: Supports planar geometry for projected data\nS2: Manages spherical geometry for unprojected data (e.g., lon/lat), toggleable with sf::sf_use_s2(FALSE).\n\nGeometry Engines:\n\nPlanar (GEOS): For 2D projected data.\nSpherical (S2): For 3D unprojected data.\n\n\n\n2.2.1 Introduction to Simple Features\n\nSimple Features (SF): Hierarchical model by OGC; supports multiple geometry types.\nCore Types: sf package in R supports 7 core geometry types (points, lines, polygons, and “multi” versions).\nLibrary Integration: sf replaces sp, rgdal, rgeos; unified interface for GEOS (geometry), GDAL (data I/O), PROJ (CRS).\nNon-Planar Support: Integrates s2 for geographic (lon/lat) operations, used by default for accuracy on spherical geometries.\nData Storage: SF objects are data frames with a spatial column (geom).\nVignettes: Documentation accessible with vignette(package = \"sf\") for practical use and examples.\nPlotting: plot(sf_object) maps all variables, unlike single-map GIS tools.\nSummary: summary() gives spatial and attribute data insights.\nSubset: SF objects subsettable like data frames, retaining spatial metadata.\n\n\n\nCode\n# See which vignettes are available\n# vignette(package = \"sf\")\n\nworld\n## Simple feature collection with 177 features and 10 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\n## # A tibble: 177 × 11\n##    iso_a2 name_long continent region_un subregion type  area_km2     pop lifeExp\n##  * &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n##  1 FJ     Fiji      Oceania   Oceania   Melanesia Sove…   1.93e4  8.86e5    70.0\n##  2 TZ     Tanzania  Africa    Africa    Eastern … Sove…   9.33e5  5.22e7    64.2\n##  3 EH     Western … Africa    Africa    Northern… Inde…   9.63e4 NA         NA  \n##  4 CA     Canada    North Am… Americas  Northern… Sove…   1.00e7  3.55e7    82.0\n##  5 US     United S… North Am… Americas  Northern… Coun…   9.51e6  3.19e8    78.8\n##  6 KZ     Kazakhst… Asia      Asia      Central … Sove…   2.73e6  1.73e7    71.6\n##  7 UZ     Uzbekist… Asia      Asia      Central … Sove…   4.61e5  3.08e7    71.0\n##  8 PG     Papua Ne… Oceania   Oceania   Melanesia Sove…   4.65e5  7.76e6    65.2\n##  9 ID     Indonesia Asia      Asia      South-Ea… Sove…   1.82e6  2.55e8    68.9\n## 10 AR     Argentina South Am… Americas  South Am… Sove…   2.78e6  4.30e7    76.3\n## # ℹ 167 more rows\n## # ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nnames(world)\n##  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n##  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nclass(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nCode\nworld |&gt; names()\n\nclass(world)\n\nggplot(world) + geom_sf()\n\nplot(world)\n\nworld[1:2, 1:3]\n\nvignette(\"sf1\")\n\nrbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\n\nlist(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\n\nsf_use_s2()\n\nraster_filepath = system.file(\n  \"raster/srtm.tif\", \n  package = \"spDataLarge\"\n  )\n\nmy_rast = rast(raster_filepath)\n\n?rast\n\nclass(my_rast)\nprint(my_rast)\nmy_rast\nobject.size(my_rast)\n?srtm.tif\nncell(my_rast)\n457*465\nres(my_rast)\ninMemory(my_rast)\nplot(my_rast)\n\n\nnew_raster = rast(nrows = 36, ncols = 36, \n                  xmin = -15, xmax = 15, ymin = -15, ymax = 15,\n                  vals = round(rnorm(n = 36*36) * 100, 1))\n\nplot(new_raster)\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\n\nmulti_rast |&gt; \n  plot()\n\nnlyr(multi_rast)"
  },
  {
    "objectID": "geocomputation/chapter2.html",
    "href": "geocomputation/chapter2.html",
    "title": "Chapter 2: Geographic data in R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter2.html#introduction",
    "href": "geocomputation/chapter2.html#introduction",
    "title": "Chapter 2: Geographic data in R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter2.html#vector-data",
    "href": "geocomputation/chapter2.html#vector-data",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.2 Vector Data",
    "text": "2.2 Vector Data\n\nVector Data: Represents geographic features using points, lines, and polygons based on coordinate reference systems (CRS).\n\nExample: London’s coordinates c(-0.1, 51.5) in geographic CRS or c(530000, 180000) in projected CRS (British National Grid).\n\nCRS Overview:\n\nGeographic CRS uses lon/lat (0° longitude and latitude origin).\nProjected CRS, like the British National Grid, is based on Easting/Northing coordinates with positive values.\n\nKey dependencies / libraries used by the sf Package:\n\nGDAL: Handles geographic data formats\nPROJ: For CRS transformations\nGEOS: Supports planar geometry for projected data\nS2: Manages spherical geometry for unprojected data (e.g., lon/lat), toggleable with sf::sf_use_s2(FALSE).\n\nGeometry Engines:\n\nPlanar (GEOS): For 2D projected data.\nSpherical (S2): For 3D unprojected data.\n\n\n\n2.2.1 Introduction to Simple Features\n\nSimple Features (SF): Hierarchical model by OGC (Open Geospatial Consortium); supports multiple geometry types.\nCore Types: sf package in R supports 7 core geometry types (points, lines, polygons, and their “multi” versions).\nLibrary Integration: sf replaces sp, rgdal, rgeos; unified interface for GEOS (geometry), GDAL (data I/O), PROJ (CRS).\nNon-Planar Support: Integrates s2 for geographic (lon/lat) operations, used by default for accuracy on spherical geometries.\nData Storage: SF objects are data frames with a spatial column (geometry or geom).\nVignettes: Documentation accessible with vignette(package = \"sf\") for practical use and examples.\nPlotting: plot(sf_object) maps all variables, unlike single-map GIS tools.\nSummary: summary() gives spatial and attribute data insights.\nSubset: SF objects subsettable like data frames, retaining spatial metadata.\n\n\nworld\n\nSimple feature collection with 177 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n# A tibble: 177 × 11\n   iso_a2 name_long continent region_un subregion type  area_km2     pop lifeExp\n * &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 FJ     Fiji      Oceania   Oceania   Melanesia Sove…   1.93e4  8.86e5    70.0\n 2 TZ     Tanzania  Africa    Africa    Eastern … Sove…   9.33e5  5.22e7    64.2\n 3 EH     Western … Africa    Africa    Northern… Inde…   9.63e4 NA         NA  \n 4 CA     Canada    North Am… Americas  Northern… Sove…   1.00e7  3.55e7    82.0\n 5 US     United S… North Am… Americas  Northern… Coun…   9.51e6  3.19e8    78.8\n 6 KZ     Kazakhst… Asia      Asia      Central … Sove…   2.73e6  1.73e7    71.6\n 7 UZ     Uzbekist… Asia      Asia      Central … Sove…   4.61e5  3.08e7    71.0\n 8 PG     Papua Ne… Oceania   Oceania   Melanesia Sove…   4.65e5  7.76e6    65.2\n 9 ID     Indonesia Asia      Asia      South-Ea… Sove…   1.82e6  2.55e8    68.9\n10 AR     Argentina South Am… Americas  South Am… Sove…   2.78e6  4.30e7    76.3\n# ℹ 167 more rows\n# ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nnames(world)\n\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n\nclass(world)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n########### THE GEOMETRY COLUMN IS STICKY ################\nsummary(world[\"lifeExp\"])\n\n    lifeExp                 geom    \n Min.   :50.62   MULTIPOLYGON :177  \n 1st Qu.:64.96   epsg:4326    :  0  \n Median :72.87   +proj=long...:  0  \n Mean   :70.85                      \n 3rd Qu.:76.78                      \n Max.   :83.59                      \n NA's   :10                         \n\n\n\n\nCode\nplot(world)\n\n\n\n\n\n\n\n\nFigure 1: The basic plot() function on a sf object produced multiple plots, one for each of the non-geometry variables (columns) in the plotted dataset.\n\n\n\n\n\n\n\n2.2.2 Why Simple Features?\n\nCross-Compatibility: SF model is compatible with many GIS tools (e.g., QGIS, PostGIS), enabling easy data transfer.\nAdvantages of sf in R:\n\nData Handling: Fast reading/writing of spatial data.\nPlotting: Improved plotting speed and performance.\nData Frame-Like: sf objects behave like data frames.\nConsistent Naming: sf functions are intuitive, starting with st_.\nTidyverse-Friendly: Works well with |&gt; and integrates with tidyverse packages.\n\nData Import Options:\n\nread_sf(): Imports data as a tidy tibble (quietly).\nst_read(): Imports data as a base R data frame (verbose).\n\nPopularity: sf is the primary package for spatial vector data in R, preferred over alternatives like spatstat and terra.\n\n\nworld_dfr &lt;- st_read(system.file(\"shapes/world.shp\", package = \"spData\"))\n## Reading layer `world' from data source \n##   `C:\\Users\\dradi\\AppData\\Local\\R\\win-library\\4.3\\spData\\shapes\\world.shp' \n##   using driver `ESRI Shapefile'\n## Simple feature collection with 177 features and 10 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\nworld_dfr &lt;- read_sf(system.file(\"shapes/world.shp\", package = \"spData\"))\n\nclass(world_dfr)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n2.2.3 Basic Maps\n\nPlotting in sf:\n\nplot() creates multi-panel plots for multiple variables or a single-panel plot for one variable.\nSupports fixed color customization using col and border arguments.\n\n\n\n\nCode\nplot(world)\n\n\n\n\n\n\n\n\nFigure 2: The base plot() function creates a faceted output with a map for each variable other than geometry\n\n\n\n\n\n\nLayering Plots: Add layers to existing plots with add = TRUE. Use reset = FALSE for plots with a key.\nOverlaying Data: Circles representing population size can be plotted using cex and st_centroid().\nBounding Box Expansion: expandBB adjusts the plot boundaries (bottom, left, top, right).\nLimitations: Base plot() is simple but limited in functionality; use tmap for advanced maps.\n\n\n\n2.2.4 Geometry Types\n\nGeometry Basics:\n\nCore components of simple features; sf supports 18 types.\nFocus on 7 common types: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.\n\nEncoding Standards:\n\nWKB (Well-known binary): Hexadecimal, computer-friendly format.\nWKT (Well-known text): Human-readable format, often shown for explanation.\n\nCommon Geometries:\n\nPOINT: Single coordinate (e.g., POINT (5 2)).\nLINESTRING: Connected sequence of points (e.g., LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)).\nPOLYGON: Closed ring of points (e.g., POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))).\n\nMulti-Geometries:\n\nMULTIPOINT: Multiple points (e.g., MULTIPOINT (5 2, 1 3, 3 4, 3 2)).\nMULTILINESTRING: Multiple linestrings (e.g., MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))).\nMULTIPOLYGON: Multiple polygons (e.g., MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))).\n\nGeometry Collection:\n\nMix of geometry types (e.g., GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))).\n\n\n\n\n2.2.5 The sf Class\n\nStructure of sf Objects: Composed of geometries (sfc object) and non-geographic attributes (data.frame or tibble).\nCreation of sf Objects: Steps:\n\nCreate geometry (sfg) with functions like st_point()\nConvert to geometry column (sfc) with CRS using function st_sfc(..., crs = \"...\")\nCombine attributes (data.frame) with sfc using function st_sf(..., geometry = ...)\n\n\n\n\nCharacteristics:\n\nsf objects have dual class: sf and data.frame.\nSpatial attributes stored in a geometry column.\nsf behaves like a data.frame but with spatial extension.\n\n\n\n\n2.2.6 Simple Feature Geometries (sfg)\nAn sfg object represents a single simple feature geometry. A simple feature geometry column (sfc) is a collection of sfg objects and can also include information about the coordinate reference system (CRS) being used.\nGeometries can be created using st_ functions or imported from existing spatial files.\n\nsfg Creation Functions:\n\nst_point(): Create a single point.\nst_linestring(): Create a linestring.\nst_polygon(): Create a polygon.\nst_multipoint(): Create a multipoint.\nst_multilinestring(): Create a multilinestring.\nst_multipolygon(): Create a multipolygon.\nst_geometrycollection(): Create a geometry collection.\n\nInput Data Types:\n\nNumeric Vector: Single points.\nMatrix: Sets of points for multipoint or linestring.\nList: Complex structures for multilinestrings, (multi)polygons, or geometry collections.\n\nExamples:\n\n\nCode\n\n# Create a point\npoint &lt;- st_point(c(8, 3))  # POINT (8 3)\nprint(point)\nggplot(point) +\n  geom_sf()\n\n# Create a multipoint\nmultipoint_matrix &lt;- rbind(c(8, 3), c(2, 5), c(5, 7), c(7, 3))\nmultipoint &lt;- st_multipoint(multipoint_matrix)  # MULTIPOINT ((8 3), (2 5), (5 7), (7 3))\nprint(multipoint)\nggplot(multipoint) +\n  geom_sf()\n\n# Create a linestring\nlinestring_matrix &lt;- rbind(c(2, 8), c(6, 6), c(7, 2), c(5, 3), c(8, 4))\nlinestring &lt;- st_linestring(linestring_matrix)  # LINESTRING (2 8, 6 6, 7 2, 5 3, 8 4)\nprint(linestring)\nggplot(linestring) +\n  geom_sf()\n\n# Create a polygon\npolygon_list &lt;- list(rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8)))\npolygon &lt;- st_polygon(polygon_list)  # POLYGON ((2 8, 4 3, 7 2, 6 7, 2 8))\nprint(polygon)\nggplot(polygon) +\n  geom_sf()\n\n# Polygon with a hole\npolygon_border &lt;- rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8))\npolygon_hole &lt;- rbind(c(4, 6), c(5, 6), c(5, 5), c(4, 5), c(4, 6))\npolygon_with_hole_list &lt;- list(polygon_border, polygon_hole)\npolygon_with_hole &lt;- st_polygon(polygon_with_hole_list)  # POLYGON with a hole\nprint(polygon_with_hole)\nggplot(polygon_with_hole) +\n  geom_sf()\n\n# Create a multilinestring\nmultilinestring_list = list(\n  rbind(c(2, 8), c(6, 6), c(7, 2), c(5, 3), c(8, 4)),\n  rbind(c(3, 2), c(5, 8))\n)\nmultilinestring = st_multilinestring(multilinestring_list)  # MULTILINESTRING\nprint(multilinestring)\nggplot(multilinestring) +\n  geom_sf()\n\n# Create a multipolygon\nmultipolygon_list = list(\n  list(rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8))),\n  list(rbind(c(0, 3), c(2, 3), c(2, 4), c(0, 4), c(0, 3)))\n)\nmultipolygon = st_multipolygon(multipolygon_list)  # MULTIPOLYGON\nprint(multipolygon)\nggplot(multipolygon) +\n  geom_sf()\n\n# Create a geometry collection\ngeometrycollection_list = list(st_multipoint(multipoint_matrix), st_linestring(linestring_matrix))\ngeometry_collection = st_geometrycollection(geometrycollection_list)  # GEOMETRYCOLLECTION\nprint(geometry_collection)\nggplot(geometry_collection) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) A point\n\n\n\n\n\n\n\n\n\n\n\n(b) A multipoint\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) A linestring\n\n\n\n\n\n\n\n\n\n\n\n(d) A polygon\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e) Polygon with a hole\n\n\n\n\n\n\n\n\n\n\n\n(f) Multilinestring\n\n\n\n\n\n\n\n\n\n\n\n\n\n(g) Multipolygon\n\n\n\n\n\n\n\n\n\n\n\n(h) Geometry Collection\n\n\n\n\n\n\n\nFigure 3: Creating different sample geometry objects in R with {sf}\n\n\n\n\n\n2.2.8 The sfheaders Package\n\nOverview:\n\nsfheaders (Cooley 2024) is an R package designed to efficiently create and manipulate sf objects from vectors, matrices, and data frames.\nIt does not rely on the sf library and instead uses underlying C++ code, enabling faster operations and the potential for further development with compiled code.\n\nCompatibility:\n\nAlthough separate from sf, it is fully compatible, producing valid sf objects like sfg, sfc, and sf.\n\nKey Functionality:\n\nConverts:\n\nVector → sfg_POINT\nMatrix → sfg_LINESTRING\nData Frame → sfg_POLYGON\n\nCreates sfc and sf objects using similar syntax.\n\nAdvantages:\n\nsfheaders is optimized for high-speed ‘deconstruction’ and ‘reconstruction’ of sf objects and casting between geometry types, offering faster performance than sf in many cases.\n\n\n\n\n2.2.9 Spherical Geometry Operations with S2\n\nConcept:\n\nSpherical geometry operations acknowledge Earth’s roundness, as opposed to planar operations that assume flat surfaces.\nSince sf version 1.0.0, R integrates with Google’s S2 spherical geometry engine, enabling accurate global spatial operations.\nS2 supports operations like distance, buffer, and area calculations, allowing accurate geocomputation on a spherical Earth model.\nKnown as a Discrete Global Grid System (DGGS), S2 is similar to other systems like H3, which is a global hexagonal index.\n\nS2 Mode:\n\nBy default, S2 is enabled in sf. Verify with:\nsf_use_s2()\nTurning Off S2:\nsf_use_s2(FALSE)\n\nS2 Limitations and Edge Cases:\n\nSome operations may fail due to S2’s stricter definitions, potentially affecting legacy code. Error messages such as Error in s2_geography_from_wkb ... might require turning off S2.\n\nRecommendation:\n\nKeep S2 enabled for accurate global calculations unless specific operations necessitate its deactivation."
  },
  {
    "objectID": "geocomputation/chapter2.html#raster-data",
    "href": "geocomputation/chapter2.html#raster-data",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.3 Raster Data",
    "text": "2.3 Raster Data\n\nThe raster data model represents the world as a continuous grid of cells (pixels). Focuses on regular grids, where each cell is of constant size, though other grid types (e.g., rotated, sheared) exist.\nStructure:\n\nComprises a raster header and a matrix of equally spaced cells.\nThe raster header includes:\n\nCRS (Coordinate Reference System)\nExtent (geographical area covered)\nOrigin (starting point, often the lower left corner; the terra package defaults to the upper left).\n\nExtent is defined by:\n\nNumber of columns (ncol)\nNumber of rows (nrow)\nCell size resolution\n\n\nCell Access and Modification:\n\nCells can be accessed and modified by:\n\nCell ID\nExplicitly specifying row and column indices.\n\nThis matrix representation is efficient as it avoids storing corner coordinates (unlike vector polygons).\n\nData Characteristics:\n\nEach cell can hold a single value, which can be either:\n\nContinuous (e.g., elevation, temperature)\nCategorical (e.g., land cover classes).\n\n\nApplications:\n\nRaster maps are useful for continuous phenomena (e.g., temperature, population density) and can also represent discrete features (e.g., soil classes).\n\n\n\n2.3.1 R Packages for Working with Raster Data\n\nSeveral R packages for reading and processing raster datasets have emerged over the last two decades. The raster package was the first significant advancement in R’s raster capabilities when launched in 2010. It was the premier package until the development of terra and stars, both offering powerful functions for raster data.\nThis book emphasizes terra, which replaces the older, slower raster package.\nComparison of terra and stars:\n\n\n\n\n\n\n\n\n\nFeature\nterra\nstars\n\n\n\n\nPrimary Focus\nRegular grids\nSupports regular, rotated, sheared, rectilinear, and curvilinear grids\n\n\nData Structure\nOne or multi-layered rasters\nRaster data cubes with multiple layers, time steps, and attributes\n\n\nMemory Management\nUses C++ code and pointers for data storage\nUses lists of arrays for smaller rasters; file paths for larger ones\n\n\nVector Data Integration\nUses its own class SpatVector but supports sf objects\nClosely related to vector objects/functions in sf\n\n\nFunctions & Methods\nLarge number of built-in, purpose-specific functions (e.g., re-sampling, cropping)\nMix of built-in functions (st_ prefix), existing dplyr functions, and custom methods for R functions\n\n\nConversion Between Packages\nConversion to stars with st_as_stars()\nConversion to terra with rast()\n\n\nPerformance\nGenerally optimized for speed and memory efficiency\nFlexible, but performance varies based on data type and structure\n\n\nBest Use Cases\nSingle or multi-layer rasters; fast processing\nComplex data cubes with layers over time and multiple attributes\n\n\nProgramming Language Basis\nPrimarily C++\nR with some C++ integration\n\n\n\n\n\n2.3.2 Introduction to terra\n\nThe terra package is designed for handling raster objects in R, supporting a range of functions to create, read, export, manipulate, and process raster datasets.\n\nWhile its functionality is similar to the older raster package, terra offers improved computational efficiency.\nDespite terra’s advantages, the raster class system remains popular due to its widespread use in other R packages.\nterra provides seamless translation between the two object types using functions like raster(), stack(), and brick() for backward compatibility.\n\nKey Features:\n\nLow-Level Functionality: Includes functions that help in building new tools for raster data processing.\nMemory Management: Supports processing of large raster datasets by dividing them into smaller chunks for iterative processing, allowing operations beyond available RAM capacity.\n\n\n\n\nCode\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", \n                              package = \"spDataLarge\")\nmy_rast &lt;- rast(raster_filepath)\n\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\next(my_rast)\n## SpatExtent : -113.239583212784, -112.85208321281, 37.1320834298579, 37.5129167631658 (xmin, xmax, ymin, ymax)\n\nprint(my_rast)\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\n\nDedicated Reporting Functions:\n\ndim(): Number of rows, columns, and layers.\nncell(): Total number of cells (pixels).\nres(): Spatial resolution.\next(): Spatial extent.\ncrs(): Coordinate reference system (CRS).\ninMemory(): Checks if data is stored in memory or on disk.\nsources: Shows file location.\n\nAccessing Full Function List:\n\nRun help(\"terra-package\") to see all available terra functions.\n\n\n\n\n2.3.3 Basic Map-Making\n\nPlotting with terra:\n\nThe terra package offers a simple way to create basic visualizations using the plot() function, specifically designed for SpatRaster objects.\n\n\n\n\nCode\nplot(my_rast)\n\n\n\n\n\n\n\n\nFigure 4: An example raster data displayed with {terra} using plot()\n\n\n\n\n\n\nAdvanced Plotting Options:\n\nplotRGB(): A specialized function in terra for creating color composite plots using three layers (e.g., red, green, blue bands) from a SpatRaster object.\ntmap Package (Tennekes 2018): Useful for creating both static and interactive maps for raster and vector data.\nrasterVis Package (2023): Includes functions such as levelplot() to create advanced visualizations, including faceted plots for displaying changes over time.\n\n\n\n\n2.3.4 Raster Classes\n\nThe SpatRaster class in terra represents raster objects. Rasters are commonly created by reading a file using rast()\n\nterra supports reading various formats via GDAL, only loading the header and a file pointer into RAM.\n\nCreating Rasters from Scratch: Use rast() to make new raster objects:\n\nFills values row-wise from the top left corner.\nResolution depends on rows, columns, and extent; defaults to degrees (WGS84 CRS).\n\n\n\n\nCode\n# Create a new SpatRaster object: a checkerboard design\nnew_raster = rast(nrows = 50, ncols = 50, \n                  xmin = 0, xmax = 50, \n                  ymin = 0, ymax = 50,\n                  vals = rep(c(1, 0.25, 0.75, 0.5), \n                             times = 12)) \n\n\n# Plot the new raster\nplot(new_raster, \n     col = c(\"darkblue\", \n             \"white\",\n             \"blue\",\n             \"lightblue\"), # Use blue and white for the design\n     axes = TRUE, \n     box = FALSE)\n\n\n\n\n\n\n\n\nFigure 5: Creating a new raster from scratch\n\n\n\n\n\n\nHandling Multi-Layer Rasters:\n\nSpatRaster supports multi-layer rasters, such as satellite or time-series data:\n\nUse nlyr() to get the number of layers:\nAccess layers with [[ or $.\nUse subset() for layer extraction:\n\n\nCombining Raster Layers:\n\nMerge SpatRaster layers using c():\n\nSaving SpatRaster Objects:\n\nSince they often point to files, direct saving to .rds or .rda isn’t feasible.\nSolutions:\n\nwrap(): Creates a temporary object for saving or cluster use.\nwriteRaster(): Saves as a regular raster file."
  },
  {
    "objectID": "geocomputation/chapter2.html#coordinate-reference-systems",
    "href": "geocomputation/chapter2.html#coordinate-reference-systems",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.4 Coordinate Reference Systems",
    "text": "2.4 Coordinate Reference Systems\n\nCRSs (Coordinate Reference Systems) are essential for spatial data, defining how spatial elements correspond to the Earth’s surface (or other celestial bodies).\nTypes of CRSs:\n\nGeographic CRSs:\n\nRepresent data on a three-dimensional surface (e.g., latitude and longitude).\nCoordinate units are typically degrees.\n\nProjected CRSs:\n\nRepresent data on a two-dimensional, flat plane.\nTransform spherical Earth data into a flat map.\nCoordinate units can be in meters, feet, etc.\n\n\n\n\n2.4.1 Geographic Coordinate Reference Systems\n\nGeographic CRSs use longitude and latitude to identify locations on Earth.\n\nLongitude: Measures East-West position relative to the Prime Meridian.\nLatitude: Measures North-South position relative to the equatorial plane.\nDistances are measured in angular units (degrees), not meters, impacting spatial measurements (explored further in Section 7).\n\nThe Earth can be modeled as spherical or ellipsoidal.\n\nSpherical models: Simplify calculations by assuming Earth is a perfect sphere.\nEllipsoidal models: More accurately represent Earth with distinct equatorial and polar radii. The equatorial radius is about 11.5 km longer than the polar radius due to Earth’s compression.\n\nDatum refers to the model describing the relationship between coordinate values and actual locations on Earth. A datum consists of:\n\nEllipsoid: An idealized mathematical model of the Earth’s shape, which helps to approximate the Earth’s surface.\nOrigin Point: A fixed starting point for the coordinate system, where the ellipsoid is anchored to Earth.\nOffset and Orientation: How the ellipsoid is aligned with respect to the actual shape of the Earth.\n\n\n\n\nThe two types of Datums are: —\n\nGeocentric datum (e.g., WGS84): Centered at Earth’s center of gravity, providing global consistency but less local accuracy.\nLocal datum (e.g., NAD83): Adjusted for specific regions to better align with the Earth’s surface, accounting for local geographic variations (e.g., mountain ranges).\n\n\n\n\n2.4.2 Projected Coordinate Reference Systems\n\nProjected CRSs are based on geographic CRSs and use map projections to represent Earth’s three-dimensional surface in Easting and Northing (x and y) values. These CRSs rely on Cartesian coordinates on a flat surface, with an origin and linear units (e.g., meters).\nDeformations:\n\nThe conversion from 3D to 2D inherently introduces distortions. Projected CRSs can only preserve one or two of the following properties:\n\nArea: Preserved in equal-area projections.\nDirection: Preserved in azimuthal projections.\nDistance: Preserved in equidistant projections.\nShape: Preserved in conformal projections.\n\n\n\n\n\nTypes of Projections and Their Characteristics\n\n\n\n\n\n\n\n\n\nType of Projection\nDescription\nCommon Properties Preserved\nBest Used For\n\n\n\n\nConic\nProjects Earth’s surface onto a cone.\nArea, shape\nMaps of mid-latitude regions\n\n\nCylindrical\nProjects Earth’s surface onto a cylinder.\nDirection, shape\nWorld maps\n\n\nPlanar (Azimuthal)\nProjects onto a flat surface at a point or line.\nDistance, direction\nPolar region maps\n\n\n\n\n\nDeformations by Projection Type\n\n\n\n\n\n\n\n\nProperty\nDefinition\nProjection Type That Preserves It\n\n\n\n\nArea\nThe relative size of regions is maintained.\nEqual-area projections (e.g., Albers)\n\n\nDirection\nBearings from the center are accurate.\nAzimuthal projections (e.g., Lambert)\n\n\nDistance\nCorrect distances are preserved along specific lines or from specific points.\nEquidistant projections (e.g., Equirectangular)\n\n\nShape\nLocal angles and shapes are maintained, though areas are distorted.\nConformal projections (e.g., Mercator)\n\n\n\n\nUse the Map Projection Explorer for details.\nUse st_crs() for querying CRSs in sf objects and crs() for terra objects.\n\n\n\nCode\nsf_proj_info(type = \"proj\") |&gt; \n  as_tibble() |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 1: A list of the available projections supported by the PROJ library"
  },
  {
    "objectID": "geocomputation/chapter2.html#exercises",
    "href": "geocomputation/chapter2.html#exercises",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.6 Exercises",
    "text": "2.6 Exercises\n\n\nE1\nUsing summary() on the geometry column of the world data object in the spData package provides valuable information about the spatial characteristics of the dataset:\n\nGeometry Type:\n\nThe output will indicate the type of geometries present in the world data object. Here, it is MULTIPOLYGON suggesting that the dataset represents the outlines of countries or regions in MULTIPLOYGON formats.\n\nNumber of Countries:\n\nThe summary will show the number of geometries or features present, which corresponds to the number of countries or regions represented in the world dataset. Here, it is 177 countries.\n\nCoordinate Reference System (CRS):\n\nThe output will include details about the CRS, and in the present case it is EPSG:4326.\n\n\n\nsummary((spData::world$geom))\n\n MULTIPOLYGON     epsg:4326 +proj=long... \n          177             0             0 \n\n\n\n\n\nE2\nTo generate the world map, you can run the following code (as shown in Section 2.2.3):\n\nCode\nlibrary(spData)\nplot(world[3:6])\nplot(world[\"pop\"])\n\n\n\n\n\n\n\n\n\n\nFigure 6: Reproducing Figure 2.4 of the book\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Reproducing Figure 2.4 of the book\n\n\n\n\n\n\n\nSimilarities:\n\nThe map displays country boundaries and highlights the global population distribution as shown in the book.\nThe color scale representing population data is consistent with that described in the book, with larger populations shown with more intense colors.\n\nDifferences:\n\nThe aspect ratio or positioning of the map might vary depending on your screen resolution and window size.\nThe color theme and legend display may differ if your R setup or graphic device uses default settings different from those in the book.\n\ncex Argument: This parameter controls the size of plotting symbols in R. It is a numeric value that acts as a multiplier for the default size of symbols.\n\nSetting cex to values larger than 1 enlarges symbols, while values less than 1 shrink them.\n\nReason for cex = sqrt(world$pop) / 10000 : The code sets cex to sqrt(world$pop) / 10000 to scale the size of the points on the map in proportion to the population of each country. This square root transformation is used to moderate the variation in symbol sizes because population values can vary significantly between countries. Dividing by 10,000 helps to reduce the symbol size to a reasonable range for plotting.\n\nOther Ideas: —\n\nBubble Plot: Overlay a bubble plot on the map with points sized by population.\n\n\n\nCode\nplot(world[\"pop\"])\npoints(st_coordinates(st_centroid(world$geom)), \n       cex = sqrt(world$pop) / 5000, \n       col = \"red\", pch = 19)\n\n\n\n\n\n\n\n\n\n\nChoropleth Map: Use color gradients to represent population density.\n\n\n\nCode\nlibrary(tmap)\ntm_shape(world) +\n  tm_polygons(\"pop\", style = \"jenks\", \n              palette = \"Blues\", \n              title = \"Population\")\n\n\n\n\n\n\n\n\n\n\nLog Transformation: Visualize population using a log scale for better differentiation.\n\n\n\nCode\nworld$log_pop = log10(world$pop + 1)\nplot(world[\"log_pop\"])\n\n\n\n\n\n\n\n\n\n\n\n\nE3\nTo create a map of Nigeria in context and customize it using the plot() function, you can follow these steps:\nStep 1: Load Necessary Libraries and Data: Make sure you have the spData package loaded and access to the world spatial data.\nStep 2: Plotting Nigeria in Context: You can plot Nigeria by subsetting the world data and adjusting parameters such as lwd (line width), col (color), and expandBB (expanding the bounding box). Here’s an example code snippet:\nStep 3: Annotating the Map: To annotate the map with text labels, you can use the text() function. Here’s an example where we add the name of Nigeria and its capital, Abuja:\nStep 4: Exploring the text() Documentation\n\nlwd: This argument controls the line width for the borders of the countries.\ncol: This argument sets the fill color for the countries. You can customize it based on your preference.\nexpandBB: This argument expands the bounding box of the plot, which can help visualize nearby areas more clearly.\n\n\n\n\nE4\nTo create an empty SpatRaster object with 10 columns and 10 rows, assign random values between 0 and 10, and then plot it, you can use the terra package in R. Here’s how you can do it:\n\n\nCode\nlibrary(terra)\n\n# Create an empty SpatRaster object with 10 columns and 10 rows\nmy_raster &lt;- rast(nrows = 10, ncols = 10)\n\n# Assign random values between 0 and 10\nvalues(my_raster) &lt;- runif(ncell(my_raster), min = 0, max = 10)\n\n# Plot the raster\nplot(my_raster, main = \"Random Values Raster\")\n\n\n\n\n\n\n\n\n\n\n\n\nE5\nTo read in the raster/nlcd.tif file from the spDataLarge package and examine its properties, you can follow these steps in R:\n\nlibrary(spDataLarge)\nlibrary(terra)\n\n# Read the raster file\nnlcd_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\nInformation You Can Obtain: —\n\nBasic Properties: The print(nlcd_raster) command will provide you with information about the raster, including its dimensions, number of layers, and type of data.\n\n# Check the basic properties of the raster\nprint(nlcd_raster)\n\nclass       : SpatRaster \ndimensions  : 1359, 1073, 1  (nrow, ncol, nlyr)\nresolution  : 31.5303, 31.52466  (x, y)\nextent      : 301903.3, 335735.4, 4111244, 4154086  (xmin, xmax, ymin, ymax)\ncoord. ref. : NAD83 / UTM zone 12N (EPSG:26912) \nsource      : nlcd.tif \ncolor table : 1 \ncategories  : levels \nname        :   levels \nmin value   :    Water \nmax value   : Wetlands \n\n\nSummary Statistics: The summary(nlcd_raster) function will give you basic statistics about the raster values, such as minimum, maximum, and mean values. In this case, it tells the number of cells with Forest, Shrubland, Barren, Developed, Cultivated, Wetlands and Other land-use types.\n\n# Get summary statistics\nsummary(nlcd_raster)\n\n        levels     \n Forest    :52620  \n Shrubland :37463  \n Barren    : 7290  \n Developed : 1203  \n Cultivated:  596  \n Wetlands  :  443  \n (Other)   :  421  \n\n\nExtent: The ext(nlcd_raster) command will provide the geographical extent of the raster, showing the minimum and maximum x and y coordinates.\n\n# Check the extent of the raster\next(nlcd_raster)\n\nSpatExtent : 301903.344386758, 335735.354381954, 4111244.46098842, 4154086.47216415 (xmin, xmax, ymin, ymax)\n\n\nRows and Columns: You can find the number of rows and columns in the raster using nrow(nlcd_raster) and ncol(nlcd_raster).\n\n# Get the number of rows and columns\nnrow(nlcd_raster)\n\n[1] 1359\n\nncol(nlcd_raster)\n\n[1] 1073\n\n\nCoordinate Reference System (CRS): The crs(nlcd_raster) command will return the CRS of the raster, which is essential for spatial analyses.\n\n# Get the coordinate reference system (CRS)\nstr_view(crs(nlcd_raster))\n\n[1] │ PROJCRS[\"NAD83 / UTM zone 12N\",\n    │     BASEGEOGCRS[\"NAD83\",\n    │         DATUM[\"North American Datum 1983\",\n    │             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n    │                 LENGTHUNIT[\"metre\",1]]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433]],\n    │         ID[\"EPSG\",4269]],\n    │     CONVERSION[\"UTM zone 12N\",\n    │         METHOD[\"Transverse Mercator\",\n    │             ID[\"EPSG\",9807]],\n    │         PARAMETER[\"Latitude of natural origin\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8801]],\n    │         PARAMETER[\"Longitude of natural origin\",-111,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8802]],\n    │         PARAMETER[\"Scale factor at natural origin\",0.9996,\n    │             SCALEUNIT[\"unity\",1],\n    │             ID[\"EPSG\",8805]],\n    │         PARAMETER[\"False easting\",500000,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8806]],\n    │         PARAMETER[\"False northing\",0,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8807]]],\n    │     CS[Cartesian,2],\n    │         AXIS[\"(E)\",east,\n    │             ORDER[1],\n    │             LENGTHUNIT[\"metre\",1]],\n    │         AXIS[\"(N)\",north,\n    │             ORDER[2],\n    │             LENGTHUNIT[\"metre\",1]],\n    │     USAGE[\n    │         SCOPE[\"Engineering survey, topographic mapping.\"],\n    │         AREA[\"North America - between 114°W and 108°W - onshore and offshore. Canada - Alberta; Northwest Territories; Nunavut; Saskatchewan. United States (USA) - Arizona; Colorado; Idaho; Montana; New Mexico; Utah; Wyoming.\"],\n    │         BBOX[31.33,-114,84,-108]],\n    │     ID[\"EPSG\",26912]]\n\n\nResolution: You can check the resolution of the raster with the res(nlcd_raster) function, which will indicate the size of each pixel.\n\n# Check the resolution of the raster\nres(nlcd_raster)\n\n[1] 31.53030 31.52466\n\n\nValues: The values(nlcd_raster) command allows you to access the actual values contained in the raster. Here, I am printing only the first few values.\n\n# Get the values of the raster\nvalues(nlcd_raster) |&gt; head()\n\n     levels\n[1,]      4\n[2,]      4\n[3,]      5\n[4,]      4\n[5,]      4\n[6,]      4\n\n\n\n\n\n\nE6\nTo check the Coordinate Reference System (CRS) of the raster/nlcd.tif file from the spDataLarge package, you can use the following steps in R. The CRS provides essential information about how the spatial data is projected on the Earth’s surface.\n\nlibrary(spDataLarge)\nlibrary(terra)\n\n# Read the raster file\nnlcd_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\n# Check the coordinate reference system (CRS)\nnlcd_crs &lt;- crs(nlcd_raster)\nnlcd_crs |&gt; str_view()\n\n[1] │ PROJCRS[\"NAD83 / UTM zone 12N\",\n    │     BASEGEOGCRS[\"NAD83\",\n    │         DATUM[\"North American Datum 1983\",\n    │             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n    │                 LENGTHUNIT[\"metre\",1]]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433]],\n    │         ID[\"EPSG\",4269]],\n    │     CONVERSION[\"UTM zone 12N\",\n    │         METHOD[\"Transverse Mercator\",\n    │             ID[\"EPSG\",9807]],\n    │         PARAMETER[\"Latitude of natural origin\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8801]],\n    │         PARAMETER[\"Longitude of natural origin\",-111,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8802]],\n    │         PARAMETER[\"Scale factor at natural origin\",0.9996,\n    │             SCALEUNIT[\"unity\",1],\n    │             ID[\"EPSG\",8805]],\n    │         PARAMETER[\"False easting\",500000,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8806]],\n    │         PARAMETER[\"False northing\",0,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8807]]],\n    │     CS[Cartesian,2],\n    │         AXIS[\"(E)\",east,\n    │             ORDER[1],\n    │             LENGTHUNIT[\"metre\",1]],\n    │         AXIS[\"(N)\",north,\n    │             ORDER[2],\n    │             LENGTHUNIT[\"metre\",1]],\n    │     USAGE[\n    │         SCOPE[\"Engineering survey, topographic mapping.\"],\n    │         AREA[\"North America - between 114°W and 108°W - onshore and offshore. Canada - Alberta; Northwest Territories; Nunavut; Saskatchewan. United States (USA) - Arizona; Colorado; Idaho; Montana; New Mexico; Utah; Wyoming.\"],\n    │         BBOX[31.33,-114,84,-108]],\n    │     ID[\"EPSG\",26912]]\n\n\nUnderstanding the CRS Information: —\nThe output from the crs(nlcd_raster) command will typically include details such as:\n\nProjection Type: Indicates whether the CRS is geographic (latitude and longitude) or projected (a flat representation). Here, it is North American NAD83 / UTM Zone 12 N\nDatum: Information about the geodetic datum used, which is crucial for accurately locating points on the Earth’s surface. Here, it is North American Datum 1983.\nCoordinate Units: Specifies the units of measurement used for the coordinates, such as degrees (for geographic CRSs) or meters (for projected CRSs). Here, it is in metres, as shown in:\nLENGTHUNIT[\"metre\",1]\nEPSG Code: If applicable, the output might include an EPSG code, which is a standardized reference number for a specific CRS. This code can be used to look up more detailed information about the CRS. Here, it is: —\nID[\"EPSG\",26912]\nTransformation Parameters: If it’s a projected CRS, the output may include parameters related to the projection method, such as central meridian, standard parallels, and false easting/northing. Here, they are: —\n|         PRIMEM[\"Greenwich\",0,     \n│             ANGLEUNIT[\"degree\",0.0174532925199433]],     \n│         ID[\"EPSG\",4269]], \n|\n|\n│     CONVERSION[\"UTM zone 12N\",     \n│         METHOD[\"Transverse Mercator\",     \n│             ID[\"EPSG\",9807]],     \n│         PARAMETER[\"Latitude of natural origin\",0,     \n│             ANGLEUNIT[\"degree\",0.0174532925199433],     \n│             ID[\"EPSG\",8801]],     \n│         PARAMETER[\"Longitude of natural origin\",-111,     \n|             ANGLEUNIT[\"degree\",0.0174532925199433],     \n│             ID[\"EPSG\",8802]],     \n│         PARAMETER[\"Scale factor at natural origin\",0.9996,\n│             SCALEUNIT[\"unity\",1],     \n│             ID[\"EPSG\",8805]],     \n│         PARAMETER[\"False easting\",500000,     \n│             LENGTHUNIT[\"metre\",1],     \n│             ID[\"EPSG\",8806]],     \n│         PARAMETER[\"False northing\",0,     \n│             LENGTHUNIT[\"metre\",1],     \n│             ID[\"EPSG\",8807]]],"
  },
  {
    "objectID": "geocomputation/chapter2.html#units",
    "href": "geocomputation/chapter2.html#units",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.5 Units",
    "text": "2.5 Units\n\nCRSs include spatial units information, which is crucial for accurately interpreting distance and area.\nCartographic best practices suggest adding scale indicators on maps to show the relationship between map and ground distances.\nUnits in sf Objects:\n\nsf objects natively support units for geometric data, ensuring outputs from functions like st_area() come with a units attribute.\nThis feature, supported by the units package, avoids confusion across different CRSs, which may use meters, feet, etc.\nTo convert units, use units::set_units()\n\nUnits in Raster Data:\n\nUnlike sf, raster packages do not natively support units.\nUsers should be cautious when working with raster data to convert units properly.\nAn example to calculate the area of India in square meters and then, square kilometres\n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(units)\n\n# Calculate the area of India in square meters\nindia_area &lt;- rnaturalearth::ne_countries() |&gt; \n  filter(admin == \"India\") |&gt; \n  st_area()\nindia_area\n\n3.150428e+12 [m^2]\n\n# Convert area to square kilometers\nprint(paste(\"Area of India in square kilometers:\", format(set_units(india_area, km^2))))\n\n[1] \"Area of India in square kilometers: 3150428 [km^2]\"\n\n# Convert area to hectares\nprint(paste(\"Area of India in hectares:\", format(set_units(india_area, ha))))\n\n[1] \"Area of India in hectares: 315042827 [ha]\"\n\n# Convert area to acres\nprint(paste(\"Area of India in acres:\", format(set_units(india_area, acre))))\n\n[1] \"Area of India in acres: 778484666 [acre]\""
  },
  {
    "objectID": "geocomputation/chapter3.html",
    "href": "geocomputation/chapter3.html",
    "title": "Chapter 3: Attribute data operations",
    "section": "",
    "text": "sf for vector data manipulation (link)\nterra for raster data manipulation (link)\ndplyr for data frame operations (link)\nspData for example datasets (link)"
  },
  {
    "objectID": "geocomputation/chapter3.html#introduction",
    "href": "geocomputation/chapter3.html#introduction",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\n\nAttribute Data: Non-spatial info tied to geographic data (e.g., bus stop name or elevation).\n\nVector Example: A bus stop’s location as POINT (-0.098 51.495) with attributes like its name.\nRaster Example: Pixel values represent attributes (e.g., elevation); location defined by matrix indices and resolution.\n\nChapter Focus:\n\nManipulating geographic objects using attributes (e.g., names, elevations).\nTechniques: subsetting, aggregation, joining data, creating new variables.\nVector and raster data operations are similar and interchangeable (e.g., subsetting, spatial joins).\n\n\n\n\nCode\nlibrary(sf)        # Handling Simple Features in R\nlibrary(terra)     # Handling Rasters in R\nlibrary(tidyverse) # Data Wrangling\n\nlibrary(spData)    # Spatial Data-sets"
  },
  {
    "objectID": "geocomputation/chapter3.html#vector-attribute-manipulation",
    "href": "geocomputation/chapter3.html#vector-attribute-manipulation",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.2 Vector Attribute Manipulation",
    "text": "3.2 Vector Attribute Manipulation\n\nsf Package:\n\nExtends base R’s data.frame with a geometry column (sfc class) for spatial features (points, lines, polygons).\nGeometry column often named geometry or geom, but customizable.\n\nManipulation Methods:\n\n\nCode\nmethods(class = \"sf\") |&gt; \n  as_tibble() |&gt;\n  rename(methods = x) |&gt; \n  mutate(methods = str_replace_all(methods, \",sf\", \"  \")) |&gt; \n  mutate(methods = str_replace_all(methods, \".sf\", \"  \")) |&gt; \n  gt::gt() |&gt; \n  gt::tab_header(\n    title = \"Methods available\"\n  ) |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 1: Methods available for the class ‘sf’ in R using {sf} package\n\n\n\n\n\n\nMethods available\n\n\n\n\n\n\n\n\n\n\n\nMethods like aggregate(), cbind(), merge(), and rbind() work seamlessly with sf objects.\nCompatible with tidyverse functions (dplyr, tidyr) and can be used with data.table (partial compatibility noted in issue #2273).\nDropping geometry (st_drop_geometry()) can speed up attribute data operations when spatial data is not required.\n\n\n# Original 'world' dataset\ndim(world)\n## [1] 177  11\nclass(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Dropping the geometry column: Effects\nst_drop_geometry(world) |&gt; \n  dim()\n## [1] 177  10\nst_drop_geometry(world) |&gt; \n  class()\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nAdvantages:\n\nsf’s integration with the tidyverse allows robust, efficient data manipulation.\nCompatible with tidyverse functions (e.g., dplyr), making it versatile for data analysis.\n\n\n\n\n\n\n\n\nRelevant Topic\n\n\n\nMajor Pitfalls of Using Spatial Data with the Tidyverse\n\nName Clashes\n\nFunctions like select() from dplyr can mask similar functions from the raster package.\nUse fully qualified names (e.g., dplyr::select()) to avoid conflicts.\n\nCompatibility Issues with sp Package\n\nThe older sp package does not integrate well with tidyverse functions.\nRequires conversion between sp to sf object types using functions like st_as_sf().\n\nHandling Multipolygon Objects\n\nMultiple geometries in objects can cause unexpected plotting results.\nResolve issues by casting to simpler geometry types using st_cast(to = \"POLYGON\").\n\nSpatial Subsetting Challenges\n\nVerbose syntax when using tidyverse functions like filter() with spatial predicates like st_intersects().\nMay result in altered row names, complicating joins and comparisons.\nOther option is spatial subsetting using base R\n\nlnd_buff = lnd[1, ] %&gt;% \n  st_transform(crs = 27700) %&gt;%  # uk CRS\n  st_buffer(500000) %&gt;%\n  st_transform(crs = 4326)\nnear_lnd = world[lnd_buff, ]\nworld_poly = world %&gt;% \n  st_cast(to = \"POLYGON\")\nnear_lnd_new = world_poly[lnd_buff, ]\nnear_lnd_tidy = world %&gt;% \n  filter(st_intersects(., lnd_buff, sparse = FALSE))\n\n\nRow Name Alterations\n\nTidyverse operations may drop or alter row names, affecting joins and comparisons. See related discussion in tidyverse/dplyr#366.\n\nAttribute Alteration Pitfall\n\nResults from tidyverse functions may differ from base R operations due to row name discrepancies.\nExample functions: filter() vs base R subsetting ([]).\n\nIssues with bind_rows()\n\nbind_rows() fails on spatial objects; use alternatives like setting geometries to NULL with st_set_geometry() before combining.\n\nLimited Raster Data Support\n\nTidyverse integration with raster data is minimal.\nInitial efforts like tabularaster, sfraster, and stars aim to enhance support.\n\n\n\n\n\n3.2.1 Vector Attribute Sub-setting\n\nBase R Sub-setting:\n\nUses [ operator and subset() function for rows and columns selection.\nSyntax: object[i, j] returns rows indexed by i and columns by j.\n\ndplyr Sub-setting Functions:\n\nfilter() and slice() for rows, select() for columns.\nselect(): Subsets columns by name or position.\nHelper functions in select() like contains(), starts_with(), num_range().\n\nExtracting a Single Column:\n\nUse pull() (dplyr), $, or [[ (base R).\n\nRow Selection:\n\nslice(): Selects rows by index.\nfilter(): Filters rows based on conditions.\n\nComparison Operators:\n\nStandard operators can be used in filter(): &lt;, &gt;, &lt;=, &gt;=, ==, !=.\n\n\nThe dplyr functions (filter(), select(), pull()) are intuitive and integrate well with the tidyverse workflows.\n\n\n3.2.2 Chaining Commands with Pipes\n\nPipe Operator:\n\n%&gt;% (from the magrittr package) and native |&gt; (from R 4.1.0 onwards) enable chaining commands, improving readability and flow of code.\nThe output of one function becomes the input of the next.\nAlternative: Nested Function Calls: The same operation without pipes uses nested functions, which is harder to read.\n\nSplitting into Multiple Lines:\n\nUseful for debugging and inspecting intermediate results but can clutter the environment.\n\nKey Packages:\n\ndplyr: Provides verbs like filter(), select(), slice(), and supports pipe workflows.\nmagrittr: Provides %&gt;% operator for chaining functions.\n\n\n\n\n3.2.3 Vector Attribute Aggregation\n\nAggregation is summarizing data using one or more grouping variables, often leading to a smaller dataset. It is useful for data reduction, especially when working with large datasets.\nBase R Approach\n\nUsing aggregate():\n\naggregate() groups data and applies a function (e.g., sum). Result: A non-spatial data frame with two columns (continent, pop).\n\nUsing aggregate.sf():\n\nFor spatial objects (sf), use aggregate() with by argument. This results in an sf object with eight features representing continents.\n\n\ndplyr Approach\n\nUsing group_by() and summarize():\n\nEquivalent to aggregate(), but offers flexibility and control:\n\ngroup_by() defines grouping variables.\nsummarize() applies aggregation functions.\n\n\n\n\n\n\nCode\nlibrary(dplyr)\nworld |&gt;\n  group_by(continent) |&gt;\n  summarize(pop = sum(pop, na.rm = TRUE))\n\n\nSimple feature collection with 8 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n# A tibble: 8 × 3\n  continent                      pop                                        geom\n  &lt;chr&gt;                        &lt;dbl&gt;                              &lt;GEOMETRY [°]&gt;\n1 Africa                  1154946633 MULTIPOLYGON (((36.86623 22, 36.69069 22.2…\n2 Antarctica                       0 MULTIPOLYGON (((-180 -89.9, 180 -89.9, 180…\n3 Asia                    4311408059 MULTIPOLYGON (((36.14976 35.82153, 35.9050…\n4 Europe                   669036256 MULTIPOLYGON (((26.29 35.29999, 25.74502 3…\n5 North America            565028684 MULTIPOLYGON (((-82.26815 23.18861, -82.51…\n6 Oceania                   37757833 MULTIPOLYGON (((166.7932 -15.66881, 167.00…\n7 Seven seas (open ocean)          0 POLYGON ((68.935 -48.625, 68.8675 -48.83, …\n8 South America            412060811 MULTIPOLYGON (((-66.95992 -54.89681, -66.4…\n\n\n\nMore details on grouped data and summarize() from the dplyr package vignettes.\n\n\n\n\n\n\n\nRelevant Topic\n\n\n\ndplyr functions are highly effective when applied to grouped data frames (grouped_df objects). Here are the main points covered:\n\nGrouping Data: Use group_by() to create groups within a data frame based on one or more variables.\n\nTo count rows in each group, use tally().\n\nAccessing Group Metadata:\n\ngroup_keys(): Shows underlying group data. Details here.\ngroup_vars(): Retrieves names of the grouping variables. Details here.\n\nModifying Groups:\n\nTo overwrite or add grouping variables, use .add = TRUE with group_by(). Read more.\nTo remove groups, use ungroup().\n\nVerbs and Grouping:\n\nsummarise(): Computes summary statistics per group. The .groups argument controls grouping structure. More on summarise().\n\nColumn Manipulation:\n\nselect() retains grouping variables by default. More on select().\nrename() and relocate() function the same way for grouped and ungrouped data. Details here.\n\nSorting Groups:\n\narrange(): Sorts data, with .by_group = TRUE option to sort within groups. More on arrange().\n\n\n\n\n\nCheck out Chapter 5 of R for Data Science.\n\n\n\n3.2.4 Vector Attribute Joining\n\nJoining involves combining tables based on a shared key variable. In R, dplyr functions like left_join() and inner_join() are commonly used for this purpose.\n\nThe join functions in dplyr (left_join, inner_join, etc.) follow conventions from SQL, allowing easy and consistent data merging.\nThese functions work similarly for both non-spatial (data.frame) and spatial (sf) objects. The geometry list column in sf objects is the key difference.\n\nWhen merging an sf object with a data.frame\n\nThe resulting object remains an sf object, keeping its spatial features intact while adding new columns for coffee production.\n\nHandling Key Variables:\n\nIf datasets have key variables with matching names (e.g., name_long), joining works automatically.\nIf the key variables differ, either:\n\nRename the variable to match, or\nUse the by argument to specify the joining variables explicitly.\n\n\nInner Joins:\n\nAn inner join keeps only the rows with matching key variables in both datasets. This reduces the number of rows, depending on the overlap in key variables.\n\nTroubleshooting Joins:\n\nIf some rows are missing in the result (e.g., due to differing key names like “Congo, Dem. Rep. of”), identify mismatches using setdiff().\nUse regex matching from the stringr package to identify correct key names for adjustments.\n\nReversing Joins:\n\nYou can also join starting with a non-spatial dataset and adding spatial variables from an sf object.\nThe result will be a non-spatial data.frame (tibble), unless explicitly converted to an sf object using st_as_sf().\n\nFurther Resources:\n\nChapter 13 on Relational Data in R for Data Science by Grolemund and Wickham (2016)\nThe documentation describing joins with data.table package.\nThe join vignette in the geocompkg package, which is summarized below: —\n\n\n\n\n\n\n\n\nRelevant Topic\n\n\n\nSpatial Joins Extended\n\nSpatial Joins: Combines attributes from different datasets based on a common key, useful for integrating non-spatial (attribute) data with spatial data.\n\n\nLeft Join\n\nAdds attributes to all observations from the left dataset with matched values from the right.\n\n\n\nJoining by Different Column Names\n\nCase: If key columns have different names, use a named vector to specify the keys\nIssue: Duplicate columns (e.g., tbl_1_var.x and tbl_2_var.y). Resolved by specifying all keys.\n\n\n\nJoining with a Non-Spatial First Argument\n\nDropping Geometry: st_drop_geometry() removes spatial attributes, allowing joins with standard data frames.\n\n\n\nInner Join\n\nKeeps only rows with matching keys in both datasets.\n\n\n\n\n\n\n3.2.5 Creating attributes and removing spatial information\n\nCreating new attributes:\n\nCalculate a new attribute using mutate() from dplyr. Example: population / area.\nUse mutate() to add the new column without overwriting the geometry column.\n\nCombining columns:\n\nUse unite() from tidyr to merge two or more columns into one (e.g., continent and region_un).\nunite() allows setting a separator (e.g., :) and can optionally remove the original columns.\n\nSplitting columns:\n\nUse separate_wider_position() and separate_wider_delim()from tidyr to split a combined column back into its original components.\n\nRenaming columns:\n\nUse rename() from dplyr for renaming specific columns.\nFor renaming all columns, use setNames() with a character vector for new names.\n\nRemoving geometry:\n\nUse st_drop_geometry() to drop the spatial information while retaining the attributes in a non-spatial data.frame. This method is preferred over manually selecting non-geometry columns as it avoids unintended issues."
  },
  {
    "objectID": "geocomputation/chapter3.html#manipulating-raster-objects",
    "href": "geocomputation/chapter3.html#manipulating-raster-objects",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.3 Manipulating Raster Objects",
    "text": "3.3 Manipulating Raster Objects\n\nRaster Data Model:\n\nRepresents continuous surfaces, unlike vector data which use discrete entities (points, lines, polygons).\nUseful for representing spatial phenomena like elevation, temperature, and land cover.\n\nCreating a Raster Object:\n\nUse rast() function to create raster objects.\nThe vals argument assigns numeric values to each cell.\n\nCategorical Raster Values:\n\nCan hold logical or factor (categorical) values.\nExample: Creating a raster for soil types (clay, silt, sand).\n\nRaster Attribute Table (RAT):\n\nStores additional information about raster values, accessible with cats().\nEach layer’s attribute data can be modified with levels().\n\nColor Table:\n\nCategorical rasters can store color information using a color table with RGB (Red, Green, Blue) or RGBA (Red, Green, Blue, Alpha) columns.\nUse coltab() to view or set color tables.\nSaving the raster (e.g., as GeoTIFF) includes the color table information.\n\n\n\n3.3.1 Raster subsetting\n\nRaster Subsetting:\n\nInvolves selecting specific parts of a raster dataset using the base R subsetting operator [ , ].\nSubsetting Methods:\n\nRow-Column Indexing: Accesses cells using specific row and column coordinates.\nCell IDs: Accesses cells using unique numeric identifiers for each raster cell.\nCoordinates and Spatial Objects: These methods are used for spatial subsetting, using another spatial object to subset a raster.\n\n\nExamples:\n\nAccessing the top-left pixel value using row-column indexing:\n\n\n\n\nCode\n# A simple raster\n  elev &lt;- rast(\n    nrows = 10, ncols = 10,\n    xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n    vals = 1:100\n    ) \n\n# A raster with categorical levels\ngrain &lt;- rast(\n  nrows = 10, ncols = 10,\n  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n  vals = sample(\n    x = c(\"Wheat\", \"Rice\", \"Maize\", \"Others\"),\n    size = 100,\n    replace = TRUE\n  )\n)\n\n    # Print the \"elev\" object to visualize the design\n    print(elev)\n## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 0.3, 0.3  (x, y)\n## extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n## source(s)   : memory\n## name        : lyr.1 \n## min value   :     1 \n## max value   :   100\n\n    # Plot the raster object to visualize the matrix as an image\n    plot(\n      elev, \n      main = \"Raster Object with a Sequential Pattern\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n\n    # Accessing using row number and column number\n    elev[1, 1]\n##   lyr.1\n## 1     1\n\n    elev[10,5]\n##   lyr.1\n## 1    95\n\n    plot(\n      grain,\n      main = \"Raster Object with 4 categorical levels\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n\n    # Accessing using row number and column number\n\n    grain[1,1]\n##   lyr.1\n## 1 Wheat\n\n    grain[10, 10]\n##   lyr.1\n## 1  Rice\n\n    # A multilayered raster - combining both\n    two_layers &lt;- c(elev, grain)\n\n    print(two_layers)\n## class       : SpatRaster \n## dimensions  : 10, 10, 2  (nrow, ncol, nlyr)\n## resolution  : 0.3, 0.3  (x, y)\n## extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n## source(s)   : memory\n## names       : lyr.1, lyr.1 \n## min values  :     1, Maize \n## max values  :   100, Wheat\n    names(two_layers) &lt;- c(\"Continuous variable\", \n                           \"Categorical variable\")\n    plot(\n      two_layers\n    )\n\n\n\n\n\n\n\n\n\n\nAccessing the first cell using its Cell ID:\n\n\n\nCode\n# Accessing raster values using cell ID\nelev[1]\n##   lyr.1\n## 1     1\nelev[95]\n##   lyr.1\n## 1    95\n\n\n\nSubsetting Multi-layered Rasters:\n\nFor multi-layer raster objects (e.g., two_layers = c(grain, elev)), subsetting returns values from each layer:\n\n\n\ntwo_layers[1]\n\n  Continuous variable Categorical variable\n1                   1                Wheat\n\n\n\nTo extract all cell values from a raster:\n\n\n# Extracting all values - single layer raster\nelev[][1:10]  \n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# It is Equivalent to using the values() function\nvalues(elev)[1:10]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# Extracting all values - multi-layer raster\n# It returns a data.frame\nvalues(two_layers) |&gt; \n  as_tibble()\n\n# A tibble: 100 × 2\n   `Continuous variable` `Categorical variable`\n                   &lt;int&gt;                  &lt;int&gt;\n 1                     1                      4\n 2                     2                      1\n 3                     3                      3\n 4                     4                      2\n 5                     5                      2\n 6                     6                      2\n 7                     7                      4\n 8                     8                      3\n 9                     9                      2\n10                    10                      3\n# ℹ 90 more rows\n\n\n\nModifying Raster Values:\n\nChange specific cell values by combining subsetting with assignment:\n\n\n\nelev[5, 5] = 0  # Sets the value of the 1 central cells to 0\n\nplot(elev)\n\n\n\n\n\n\n\n\n\nModify multiple cells simultaneously:\n\n\nelev[5, c(5,6)] = 0  # Sets the value of the central 2 cells to 0\n\nplot(elev)\n\n\n\n\n\n\n\n\n\nReplacing Values in Multi-layered Rasters:\n\nModify cell values in a multi-layer raster using a matrix with corresponding layers and cell indices:\n\n\n\n# Assigns new values for Cell ID 1 in both layers\ntwo_layers[45] = cbind(c(1), c(4))  \n\nplot(two_layers)\n\n\n\n\n\n\n\n\nThis subsetting approach allows efficient extraction and manipulation of raster cell values, enabling the customization of raster datasets for specific analytical needs.\n\n\n3.3.2 Summarizing Raster Objects\n\nDescriptive Statistics:\n\nThe terra package provides functions for summarizing raster objects.\nPrinting a raster object directly shows the minimum and maximum values.\nThe summary() function provides detailed statistics:\n\nFor continuous rasters: Minimum, maximum, quartiles, and count of NAs.\nFor categorical rasters: Counts of each unique class.\n\n\n\n\nsummary(two_layers)\n##  Continuous.variable Categorical.variable\n##  Min.   :  1.00      Maize :18           \n##  1st Qu.: 24.75      Others:32           \n##  Median : 50.50      Rice  :22           \n##  Mean   : 50.06      Wheat :28           \n##  3rd Qu.: 75.25                          \n##  Max.   :100.00\n\n\nCustom Summary Statistics:\n\nThe global() function calculates additional statistics like standard deviation and can be used to apply custom summary statistics.\n\n\n\nglobal(two_layers, sum)\n\n                      sum\nContinuous variable  5006\nCategorical variable  260\n\nglobal(two_layers, mean)\n\n                      mean\nContinuous variable  50.06\nCategorical variable  2.60\n\n\n\nFrequency Table:\n\nThe freq() function generates a frequency table for categorical raster values, showing counts of each category.\n\n\n\n\nCode\nfreq(two_layers$`Categorical variable`) |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 2: Frequency table using freq() on raster objects\n\n\n\n\n\n\n\n\n\nlayer\nvalue\ncount\n\n\n\n\n1\nMaize\n18\n\n\n1\nOthers\n32\n\n\n1\nRice\n22\n\n\n1\nWheat\n28\n\n\n\n\n\n\n\n\n\n\n\nVisualization of Raster Statistics:\n\nSeveral functions like hist(), boxplot(), and density() work directly with raster objects to visualize statistics.\nIf visualization functions do not support raster objects, values can be extracted using values() for further plotting.\n\nHandling Function Name Clashes:\n\nSome functions (e.g., extract()) exist in multiple packages like terra and tidyr, leading to conflicts.\nTo avoid issues, call functions with full namespaces (e.g., tidyr::extract()).\n\nUse detach() to unload conflicting packages, but be cautious as it may impact dependent packages."
  },
  {
    "objectID": "geocomputation/chapter3.html#exercises",
    "href": "geocomputation/chapter3.html#exercises",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.4 Exercises",
    "text": "3.4 Exercises\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(terra)\nlibrary(spData)\ndata(us_states)\ndata(us_states_df)\n\n\nE1\nCreate a new object called us_states_name that contains only the NAME column from the us_states object using either base R ([) or tidyverse (select()) syntax. What is the class of the new object and what makes it geographic?\n\nus_states_name &lt;- us_states |&gt; \n  select(NAME)\n\nclass(us_states_name)\n\n[1] \"sf\"         \"data.frame\"\n\n\nThe new object of the class sf, and the stickiness of the geometry column makes it a geographical dataset.\n\n\n\nE2\nSelect columns from the us_states object which contain population data. Obtain the same result using a different command (bonus: try to find three ways of obtaining the same result). Hint: try to use helper functions, such as contains or matches from dplyr (see ?contains).\n\nus_states |&gt; \n  select(contains(\"pop\"))\n\nus_states |&gt; \n  select(where(is.double)) |&gt; \n  select(-AREA)\n\nus_states |&gt; \n  select(5:6)\n\nThe above three methods all select the columns total_pop_10 and total_pop_15 . Notice that the column geometry is sticky, and can be removed using st_drop_geometry().\n\n\n\nE3\nFind all states with the following characteristics (bonus: find and plot them):\n\nBelong to the Midwest region.\nThe code shown below gives out the names of all such states.\n\n\nus_states |&gt; \n  filter(REGION == \"Midwest\") |&gt; \n  pull(NAME) |&gt; \n  paste(collapse = \", \")\n\n[1] \"Indiana, Kansas, Minnesota, Missouri, North Dakota, South Dakota, Illinois, Iowa, Michigan, Nebraska, Ohio, Wisconsin\"\n\n\n\nBelong to the West region, have an area below 250,000 km2and in 2015 a population greater than 5,000,000 residents (hint: you may need to use the function units::set_units() or as.numeric()).\nOnly Washington State qualifies all three conditions. Code is shown below.\n\n\nus_states |&gt; \n  filter(REGION == \"West\") |&gt; \n  filter(total_pop_15 &gt; 5e6) |&gt; \n  filter(as.numeric(AREA) &lt; 250000)\n\nSimple feature collection with 1 feature and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 45.54774 xmax: -116.916 ymax: 49.00236\nGeodetic CRS:  NAD83\n  GEOID       NAME REGION          AREA total_pop_10 total_pop_15\n1    53 Washington   West 175436 [km^2]      6561297      6985464\n                        geometry\n1 MULTIPOLYGON (((-122.7699 4...\n\nus_states |&gt; \n  filter(REGION == \"West\") |&gt; \n  filter(total_pop_15 &gt; 5e6) |&gt; \n  filter(AREA &lt; units::set_units(250000, \"km2\"))\n\nSimple feature collection with 1 feature and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 45.54774 xmax: -116.916 ymax: 49.00236\nGeodetic CRS:  NAD83\n  GEOID       NAME REGION          AREA total_pop_10 total_pop_15\n1    53 Washington   West 175436 [km^2]      6561297      6985464\n                        geometry\n1 MULTIPOLYGON (((-122.7699 4...\n\n\n\nBelong to the South region, had an area larger than 150,000 km2 and a total population in 2015 larger than 7,000,000 residents.\nThe states that fulfil these conditions are Florida, Georgia and Texas.\n\n\n\nCode\nus_states |&gt; \n  filter(REGION == \"South\") |&gt; \n  filter(AREA &gt; units::set_units(150000, \"km2\")) |&gt; \n  filter(total_pop_15 &gt; 7e6) |&gt; \n  pull(NAME)\n\n\n[1] \"Florida\" \"Georgia\" \"Texas\"  \n\n\n\n\n\nE4\nWhat was the total population in 2015 in the us_states dataset? What was the minimum and maximum total population in 2015?\nThe total population in the us_states dataset in the year 2015 was 314,375,347. The minimum total population in 2015 was 579,679 (Wyoming), and the maximum total population was 38,421,464 (California).\n\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  summarise(\n    total_pop_15 = sum(total_pop_15)\n  )\n## # A tibble: 1 × 1\n##   total_pop_15\n##          &lt;dbl&gt;\n## 1    314375347\n\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  slice_min(order_by = total_pop_15, n = 1)\n##   GEOID    NAME REGION            AREA total_pop_10 total_pop_15\n## 1    56 Wyoming   West 253309.6 [km^2]       545579       579679\n\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  slice_max(order_by = total_pop_15, n = 1)\n##   GEOID       NAME REGION            AREA total_pop_10 total_pop_15\n## 1    06 California   West 409747.1 [km^2]     36637290     38421464\n\n\n\n\nE5\nHow many states are there in each region?\nThe number of states in each region are shown in Table 3 below.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  count(REGION, name = \"Number of States\") |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 3: Table showing number of states in each region.\n\n\n\n\n\n\n\n\n\nREGION\nNumber of States\n\n\n\n\nNorteast\n9\n\n\nMidwest\n12\n\n\nSouth\n17\n\n\nWest\n11\n\n\n\n\n\n\n\n\n\n\n\n\n\nE6\nWhat was the minimum and maximum total population in 2015 in each region? What was the total population in 2015 in each region?\nThe minimum and maximum total population in 2015 in each region is shown in Table 4 (a). The total population in each region in 2015 is shown in Table 4 (b).\n\n\nCode\nus_states |&gt; \n  as_tibble() |&gt; \n  group_by(REGION) |&gt; \n  slice_min(order_by = total_pop_15, n = 1) |&gt; \n  select(REGION, NAME, total_pop_15) |&gt; \n  ungroup() |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    columns = total_pop_15,\n    decimals = 0\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_538()\nus_states |&gt; \n  as_tibble() |&gt; \n  group_by(REGION) |&gt; \n  summarise(\n    total_population_2015 = sum(total_pop_15)\n  ) |&gt; \n  select(REGION, total_population_2015) |&gt; \n  ungroup() |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    columns = total_population_2015,\n    decimals = 0\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 4: Region-wise total and minimum-maximum populations\n\n\n\n\n\n\n\n\n\n(a) Minimum and maximum populations, region-wise, in 2015\n\n\n\n\n\nRegion\nName\nTotal Pop 15\n\n\n\n\nNorteast\nVermont\n626,604\n\n\nMidwest\nNorth Dakota\n721,640\n\n\nSouth\nDistrict of Columbia\n647,484\n\n\nWest\nWyoming\n579,679\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Total population, region-wise, in 2015\n\n\n\n\n\nRegion\nTotal Population 2015\n\n\n\n\nNorteast\n55,989,520\n\n\nMidwest\n67,546,398\n\n\nSouth\n118,575,377\n\n\nWest\n72,264,052\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE7\nAdd variables from us_states_df to us_states, and create a new object called us_states_stats. What function did you use and why? Which variable is the key in both datasets? What is the class of the new object?\nThe function we use to accomplish this task is left_join() and the key in both datasets are the state names, called NAME in us_states dataset, and state in us_states_df dataset.\nThe class of the new object depends on which object is used first on the left_join() function, if us_states (an sf object) is used first, the class of new object is sf . However, if the us_states_df (a data frame) is used first, the resulting object is a data.frame or tibble.\n\nus_states |&gt; \n  left_join(us_states_df, by = join_by(NAME == state)) |&gt; \n  class()\n## [1] \"sf\"         \"data.frame\"\n\nus_states_df |&gt; \n  left_join(us_states, by = join_by(state == NAME)) |&gt; \n  class()\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nE8\nus_states_df has two more rows than us_states. How can you find them? (Hint: try to use the dplyr::anti_join() function.)\nThe two rows that more more in us_states_df are shown below: —\n\nus_states_df |&gt; \n  anti_join(us_states, by = join_by(state == NAME)) |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\nTable 5: The two extra rows in us_states_df\n\n\n\n\n\n\n\n\n\nState\nMedian Income 10\nMedian Income 15\nPoverty Level 10\nPoverty Level 15\n\n\n\n\nAlaska\n29509\n31455\n64245\n72957\n\n\nHawaii\n29945\n31051\n124627\n153944\n\n\n\n\n\n\n\n\n\n\n\n\n\nE9\nWhat was the population density in 2015 in each state? What was the population density in 2010 in each state?\nThe Table 6 shows the population density.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  mutate(\n    population_density_2010 = total_pop_10 / as.numeric(AREA),\n    population_density_2015 = total_pop_15 / as.numeric(AREA),\n    .keep = \"unused\"\n  ) |&gt; \n  select(-GEOID) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    decimals = 1\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 6: A table showing population density in 2010 and 2015 in each state\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE10\nHow much has population density changed between 2010 and 2015 in each state? Calculate the change in percentages and map them.\nThe Table 7 shows how much the population density has changed between 2010 and 2015 in each state. The Figure 1 shows the percentage change in a map of the US.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  mutate(\n    population_density_2010 = total_pop_10 / as.numeric(AREA),\n    population_density_2015 = total_pop_15 / as.numeric(AREA),\n    change_in_density = (population_density_2015 - population_density_2010)/population_density_2010,\n    .keep = \"unused\"\n  ) |&gt; \n  select(-GEOID) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    decimals = 1\n  ) |&gt; \n  gt::fmt_percent(\n    columns = change_in_density\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 7: Table showing change in population density between 2010 and 2015\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nus_states |&gt; \n  mutate(\n    population_density_2010 = total_pop_10 / as.numeric(AREA),\n    population_density_2015 = total_pop_15 / as.numeric(AREA),\n    change_in_density = (population_density_2015 - population_density_2010)/population_density_2010,\n    .keep = \"unused\"\n  ) |&gt; \n  ggplot() +\n  geom_sf(\n    mapping = aes(\n      fill = change_in_density\n    )\n  ) +\n  geom_sf_text(\n    mapping = aes(\n      label = paste0(\n        round(\n          change_in_density * 100,\n          1\n        ),\n        \"%\"\n      )\n    ),\n    size = 3\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Red-Green Diverging\",\n    labels = scales::label_percent(),\n    name = \"Change in population density between 2010 and 2015\",\n    limits = c(-0.05, 0.1)\n  ) +\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"bottom\",\n    legend.title.position = \"top\"\n  )\n\n\n\n\n\n\n\n\nFigure 1: Map of the change in population density\n\n\n\n\n\n\n\n\nE11\nChange the columns’ names in us_states to lowercase. (Hint: helper functions - tolower() and colnames() may help.)\nA very easy method is using the janitor package and the function clean_names()\n\n\nCode\nus_states |&gt; \n  janitor::clean_names() |&gt; \n  as_tibble() |&gt; \n  print(n = 5)\n\n\n# A tibble: 49 × 7\n  geoid name   region   area total_pop_10 total_pop_15                  geometry\n  &lt;chr&gt; &lt;chr&gt;  &lt;fct&gt;  [km^2]        &lt;dbl&gt;        &lt;dbl&gt;        &lt;MULTIPOLYGON [°]&gt;\n1 01    Alaba… South  1.34e5      4712651      4830620 (((-88.20006 34.99563, -…\n2 04    Arizo… West   2.95e5      6246816      6641928 (((-114.7196 32.71876, -…\n3 08    Color… West   2.70e5      4887061      5278906 (((-109.0501 41.00066, -…\n4 09    Conne… Norte… 1.30e4      3545837      3593222 (((-73.48731 42.04964, -…\n5 12    Flori… South  1.51e5     18511620     19645772 (((-81.81169 24.56874, -…\n# ℹ 44 more rows\n\n\n\n\n\nE12\nUsing us_states and us_states_df create a new object called us_states_sel. The new object should have only two variables: median_income_15 and geometry. Change the name of the median_income_15 column to Income.\nThe new object us_states_sel is created as shown below.\n\n\nCode\nus_states_sel &lt;- us_states |&gt; \n  left_join(us_states_df, by = join_by(NAME == state)) |&gt; \n  select(Income = median_income_15, geometry)\n\nus_states_sel\n\n\nSimple feature collection with 49 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 24.55868 xmax: -66.9824 ymax: 49.38436\nGeodetic CRS:  NAD83\nFirst 10 features:\n   Income                       geometry\n1   22890 MULTIPOLYGON (((-88.20006 3...\n2   26156 MULTIPOLYGON (((-114.7196 3...\n3   30752 MULTIPOLYGON (((-109.0501 4...\n4   33226 MULTIPOLYGON (((-73.48731 4...\n5   24654 MULTIPOLYGON (((-81.81169 2...\n6   25588 MULTIPOLYGON (((-85.60516 3...\n7   23558 MULTIPOLYGON (((-116.916 45...\n8   25834 MULTIPOLYGON (((-87.52404 4...\n9   27315 MULTIPOLYGON (((-102.0517 4...\n10  24014 MULTIPOLYGON (((-92.01783 2...\n\n\n\n\n\nE13\nCalculate the change in the number of residents living below the poverty level between 2010 and 2015 for each state. (Hint: See ?us_states_df for documentation on the poverty level columns.) Bonus: Calculate the change in the percentage of residents living below the poverty level in each state.\nThe Table 8 shows the change in the number of residents living below the poverty level between 2010 and 2015 for each state.\n\n\nCode\nus_states_df |&gt; \n  mutate(\n    change_in_poverty = poverty_level_15 - poverty_level_10\n  ) |&gt; \n  select(state, change_in_poverty) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(decimals = 0) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::opt_interactive() \n\n\n\n\nTable 8: The change in the number of residents living below the poverty level between 2010 and 2015 for each state\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Table 9 shows the change in the percentage of residents living below the poverty level in each state.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  left_join(us_states_df, by = join_by(NAME == state)) |&gt; \n  as_tibble() |&gt; \n  mutate(\n    state = NAME,\n    poverty_2010 = poverty_level_10 / total_pop_10,\n    poverty_2015 = poverty_level_15 / total_pop_15,\n    change_in_poverty = poverty_2015 - poverty_2010,\n    .keep = \"none\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_percent() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 9: Table showing the change in the percentage of residents living below the poverty level in each state.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE14\nWhat was the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region? Bonus: What is the region with the largest increase in people living below the poverty line?\nThe the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region are shown in Table 10 below.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  select(state = NAME, region = REGION) |&gt; \n  left_join(us_states_df) |&gt; \n  as_tibble() |&gt; \n  group_by(region) |&gt; \n  summarise(\n    minimum_poverty_2015 = min(poverty_level_15),\n    maximum_poverty_2015 = max(poverty_level_15),\n    average_poverty_2015 = mean(poverty_level_15)\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::fmt_number(decimals = 0)\n\n\n\n\nTable 10: A table showing the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region\n\n\n\n\n\n\n\n\n\nRegion\nMinimum Poverty 2015\nMaximum Poverty 2015\nAverage Poverty 2015\n\n\n\n\nNorteast\n69,233\n3,005,943\n804,465\n\n\nMidwest\n79,758\n1,801,118\n799,155\n\n\nSouth\n108,315\n4,472,451\n1,147,575\n\n\nWest\n64,995\n6,135,142\n1,016,665\n\n\n\n\n\n\n\n\n\n\nAs evident in Table 11, the region with the largest increase in people living below the poverty line is the South Region.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  select(state = NAME, region = REGION) |&gt; \n  as_tibble() |&gt; \n  left_join(us_states_df) |&gt; \n  group_by(region) |&gt; \n  summarise(\n    change_total_poverty = sum(poverty_level_15) - sum(poverty_level_10)\n  ) |&gt; \n  arrange(desc(change_total_poverty)) |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::fmt_number(decimals = 0)\n\n\n\n\nTable 11: Table showing the region with the largest increase in people living below the poverty line\n\n\n\n\n\n\n\n\n\nRegion\nChange Total Poverty\n\n\n\n\nSouth\n2,718,396\n\n\nWest\n2,102,479\n\n\nMidwest\n1,095,133\n\n\nNorteast\n877,493\n\n\n\n\n\n\n\n\n\n\n\n\n\nE15\nCreate a raster from scratch, with nine rows and columns and a resolution of 0.5 decimal degrees (WGS84). Fill it with random numbers. Extract the values of the four corner cells.\n\n# Load the terra package\nlibrary(terra)\n\n# Create a raster with 9 rows and 9 columns, resolution of 0.5 degrees\nr &lt;- rast(nrows = 9, ncols = 9, \n          resolution = 0.5, \n          crs = \"EPSG:4326\")\n\n# Fill the raster with random numbers\nvalues(r) &lt;- runif(ncell(r))\n\n# Print the raster\nprint(r)\n## class       : SpatRaster \n## dimensions  : 360, 720, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :        lyr.1 \n## min value   : 2.654269e-07 \n## max value   : 9.999946e-01\n\nplot(r)\n\n\n\n\n\n\n\n# Extract the values of the four corner cells\n# Top-left (1, 1), Top-right (1, 9), Bottom-left (9, 1), \n# # Bottom-right (9, 9)\n\nr[1,1]\n##       lyr.1\n## 1 0.3745735\nr[1,9]\n##       lyr.1\n## 1 0.7673042\nr[9,1]\n##       lyr.1\n## 1 0.1745812\nr[9,9]\n##       lyr.1\n## 1 0.8618642\n\n\n\n\nE16\nWhat is the most common class of our example raster grain?\n\n\nCode\ngrain_order &lt;-  c(\"clay\", \"silt\", \"sand\")\ngrain_char &lt;- sample(grain_order, 36, replace = TRUE)\ngrain_fact &lt;-  factor(grain_char, levels = grain_order)\ngrain &lt;-rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, \n             ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\nanswer &lt;- freq(grain) |&gt; \n  arrange(desc(count))\n\ngt::gt(answer) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 12: The count of different classes in the example raster grain.\n\n\n\n\n\n\n\n\n\nLayer\nValue\nCount\n\n\n\n\n1\nclay\n12\n\n\n1\nsilt\n12\n\n\n1\nsand\n12\n\n\n\n\n\n\n\n\n\n\nThe most common class is the clay .\n\n\n\nE17\nPlot the histogram and the boxplot of the dem.tif file from the spDataLarge package (system.file(\"raster/dem.tif\", package = \"spDataLarge\")).\nThe plots are shown in Figure 2\n\ntemp_rast &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\nhist(temp_rast)\n\nboxplot(temp_rast)\n\n# Using ggplot2 methods\n\ntemp_rast |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  ggplot(aes(dem)) +\n  geom_histogram(\n    fill = \"white\",\n    colour = \"grey20\"\n  )\n\ntemp_rast |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  ggplot(aes(dem)) +\n  geom_boxplot(\n    fill = \"white\",\n    colour = \"grey20\",\n    staplewidth = 0.5\n  )\n\n\n\n\n\n\n\n\n\n\n(a) Histogram of the raster dem.tif using base R hist()\n\n\n\n\n\n\n\n\n\n\n\n(b) Boxplot of the raster dem.tif using base R boxplot()\n\n\n\n\n\n\n\n\n\n\n\n(c) Histogram of the values in raster dem.tif using ggplot2\n\n\n\n\n\n\n\n\n\n\n\n(d) Boxplot of the values in raster dem.tif using ggplot2\n\n\n\n\n\n\nFigure 2: Plots produced for question E17"
  },
  {
    "objectID": "geocomputation/chapter4.html",
    "href": "geocomputation/chapter4.html",
    "title": "Chapter 4: Spatial data operations",
    "section": "",
    "text": "library(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\n\n\nsysfonts::font_add_google(\"Saira Extra Condensed\", \"caption_font\")\nsysfonts::font_add_google(\"Saira\", \"body_font\")\ntheme_set(theme_minimal(base_family = \"body_font\"))\nshowtext::showtext_auto()"
  },
  {
    "objectID": "geocomputation/chapter4.html#introduction-to-spatial-operations",
    "href": "geocomputation/chapter4.html#introduction-to-spatial-operations",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.1 Introduction to Spatial Operations",
    "text": "4.1 Introduction to Spatial Operations\n\nSpatial Operations: Include spatial joins for vectors and local/focal operations for rasters, allowing modification based on location and shape.\n\nRelation to Non-Spatial Operations: Many spatial operations (e.g., subsetting, joining) have non-spatial counterparts.\n\nSpatial Joins: Can be done in multiple ways (e.g., intersect, within distance), unlike non-spatial joins (refer to fuzzyjoin package (Robinson 2020) for alternatives).\n\nTypes of Spatial Relationships: Includes operations like intersects and disjoint. Distance calculations explore spatial relationships.\n\nRaster Operations:\n\nSubsetting (Section 4.3.1)\nMap Algebra: Modifies raster cell values through local, focal, zonal, and global operations (Sections 4.3.3 to 4.3.6).\nMerging Rasters: Demonstrated with reproducible examples (Section 4.3.8).\n\nCoordinate Reference System (CRS): Consistency in CRS is essential for spatial operations.."
  },
  {
    "objectID": "geocomputation/chapter4.html#spatial-operations-on-vector-data",
    "href": "geocomputation/chapter4.html#spatial-operations-on-vector-data",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.2 Spatial operations on vector data",
    "text": "4.2 Spatial operations on vector data\n\n4.2.1 Spatial Subsetting: use st_filter()\n\nSpatial subsetting extracts features from a spatial object (x) that relate spatially to another object (y).\nSyntax: Use the [ ] operator: x[y, , op = st_intersects].\n\nx: Target sf object.\ny: Subsetting sf object.\nop: Topological relation (default is st_intersects).\nsf package documentation\n\nDefault Operator: st_intersects() selects features intersecting with the subsetting object. Alternative operators like st_disjoint() can be used for different relations.\n\nExample: nz_height[canterbury, ] returns high points within Canterbury from the nz_height dataset in the spData package (spData documentation).\n\nTopological Relations: Include touches, crosses, and within. These determine spatial relationships between features in x and y.\nSparse Geometry Binary Predicate (sgbp):\n\nUsing st_intersects(), an sgbp list object is created.\nConvert sgbp to logical vector for subsetting using lengths({sgbp_object_name} &gt; 0)\nUsing sparse = FALSE argument in st_intersects() returns a dense matrix.\n\nTidyverse Alternative: st_filter() from the sf package simplifies spatial subsetting, increasing compatibility with dplyr.\nOutput Consistency: Subsets created using [ ], logical vectors, or st_filter() are equivalent in spatial operations.\n\n\n\nCode\ndata(\"nz\")\ndata(\"nz_height\")\n\nclass(nz)\n## [1] \"sf\"         \"data.frame\"\n\n# A plot for all regions and all peaks\nnz |&gt; \n  ggplot() +\n  geom_sf(fill = \"white\") +\n  ggrepel::geom_text_repel(\n    mapping = aes(\n      label = Name,\n      geometry = geom\n    ),\n    size = 4,\n    family = \"caption_font\",\n    stat = \"sf_coordinates\"\n  ) +\n  geom_sf(\n    data = nz_height,\n    pch = 2,\n    colour = \"red\",\n    size = 3\n  ) +\n  scale_fill_manual(\n    values = c(\"white\", \"pink\")\n  ) +\n  labs(\n    title = \"All peaks in New Zealand, and all regions.\"\n  ) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(\n      fill = \"lightblue\",\n      colour = NA\n    ),\n    legend.position = \"none\"\n  )\n\n# Total peaks in New Zealand\nnz_height |&gt; dim()\n## [1] 101   3\n\n# Peaks within Canterbury in New Zealand\n\n# Base R Version\ncanterbury &lt;- nz |&gt; filter(Name == \"Canterbury\")\nnz_height[canterbury,] |&gt; dim()\n## [1] 70  3\n\n# Tidyverse Version\nnz_height |&gt;\n  st_filter(\n    nz |&gt; filter(Name == \"Canterbury\"),\n    .predicate = st_intersects\n  ) |&gt; \n  dim()\n## [1] 70  3\n\n# Getting the peaks which are inside Canterbury\ncanterbury_ids &lt;- nz_height |&gt;\n  st_filter(\n    nz |&gt; filter(Name == \"Canterbury\"),\n    .predicate = st_intersects\n  ) |&gt; \n  pull(t50_fid)\n\nnz_height |&gt; \n  mutate(in_canterbury = t50_fid %in% canterbury_ids) |&gt; \n  ggplot() +\n  \n  # Base NZ Map and Label for Canterbury\n  geom_sf(\n    data = nz,\n    mapping = aes(\n      fill = Name == \"Canterbury\"\n    )\n  ) +\n  geom_sf_text(\n    data = filter(nz, Name == \"Canterbury\"),\n    mapping = aes(\n      label = Name,\n      geometry = geom\n    ),\n    size = 4,\n    family = \"caption_font\"\n  ) +\n  \n  # Plotting the peaks, and colouring by presence in Canterbury\n  geom_sf(\n    mapping = aes(\n      colour = in_canterbury,\n      size = in_canterbury\n    ),\n    pch = 2\n  ) +\n  \n  scale_fill_manual(\n    values = c(\"white\", \"lightpink\")\n  ) +\n  scale_colour_manual(\n    values = c(\"black\", \"red\")\n  ) +\n  guides(\n    fill = \"none\"\n  ) +\n  labs(\n    colour = \"Peaks within Canterbury Region?\",\n    size = \"Peaks within Canterbury Region?\",\n    title = \"Highlighting Peaks within Canterbury region\"\n  ) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(\n      fill = \"lightblue\"\n    ),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n(a) New Zealand Map with all the peaks\n\n\n\n\n\n\n\n\n\n\n\n(b) New Zealand Map focussing on peaks that intersect with Canterbury\n\n\n\n\n\n\nFigure 1: Spatial Subsetting and plotting with tidyverse and ggplot2 methods\n\n\n\n\nExample code for st_intersects() and st_disjoint() : these functions produce a sparse predicate list only. Hence, correct way to use them would be st_filter() with .predicate = &lt;function&gt; argument.\n\nnz_height |&gt; \n  st_intersects(\n    filter(nz, Name == \"Canterbury\")\n  )\n\nSparse geometry binary predicate list of length 101, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: 1\n 6: 1\n 7: 1\n 8: 1\n 9: 1\n 10: 1\n\n# The 70 peaks within Canterbury region\nnz_height |&gt; \n  st_filter(\n    filter(nz, Name == \"Canterbury\"),\n    .predicate = st_intersects\n  )\n\nSimple feature collection with 70 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1365809 ymin: 5158491 xmax: 1654899 ymax: 5350463\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 10 features:\n   t50_fid elevation                geometry\n1  2362630      2749 POINT (1378170 5158491)\n2  2362814      2822 POINT (1389460 5168749)\n3  2362817      2778 POINT (1390166 5169466)\n4  2363991      3004 POINT (1372357 5172729)\n5  2363993      3114 POINT (1372062 5173236)\n6  2363994      2882 POINT (1372810 5173419)\n7  2363995      2796 POINT (1372579 5173989)\n8  2363997      3070 POINT (1373796 5174144)\n9  2363998      3061 POINT (1373955 5174231)\n10 2363999      3077 POINT (1373984 5175228)\n\n# The 31 peaks outside Canterbury Region\nnz_height |&gt; \n  st_filter(\n    filter(nz, Name == \"Canterbury\"),\n    .predicate = st_disjoint\n  )\n\nSimple feature collection with 31 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1204143 ymin: 5048309 xmax: 1822492 ymax: 5650492\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 10 features:\n   t50_fid elevation                geometry\n1  2353944      2723 POINT (1204143 5049971)\n2  2354404      2820 POINT (1234725 5048309)\n3  2354405      2830 POINT (1235915 5048745)\n4  2369113      3033 POINT (1259702 5076570)\n5  2363996      2759 POINT (1373264 5175442)\n6  2364028      2756 POINT (1374183 5177165)\n7  2364029      2800 POINT (1374469 5176966)\n8  2364031      2788 POINT (1375422 5177253)\n9  2364166      2782 POINT (1383006 5181085)\n10 2364167      2905 POINT (1383486 5181270)\n\n\n\n\n4.2.2 Topological Relations\n\nTopological relations describe spatial relationships between objects using logical TRUE or FALSE statements (Egenhofer and Herring, 1990).\nSymmetrical vs. non-symmetrical relations:\n\nSymmetrical relations (e.g., equals, intersects, crosses) yield the same result when order of input is swapped.\nNon-symmetrical relations (e.g., contains, within) depend on the order of input geometries.\n\nBinary predicates in sf package test spatial relationships between vector geometries. See vignette(“sf3”). The following binary predicates exist in sf : —\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nSymmetrical?\n\n\n\n\nst_intersects\nChecks if geometries intersect.\nYes\n\n\nst_disjoint\nChecks if geometries do not intersect (are disjoint).\nYes\n\n\nst_touches\nChecks if geometries have at least one boundary point in common.\nYes\n\n\nst_crosses\nChecks if a geometry crosses another (e.g., a line crosses a polygon).\nYes\n\n\nst_overlaps\nChecks if geometries have some but not all interior points in common.\nYes\n\n\nst_equals\nChecks if geometries are topologically equal.\nYes\n\n\nst_within\nChecks if a geometry is completely contained within another.\nNo\n\n\nst_contains\nChecks if a geometry contains another completely.\nNo\n\n\nst_contains_properly\nChecks if a geometry contains another but not vice versa.\nNo\n\n\nst_covers\nChecks if a geometry covers another (includes boundary).\nNo\n\n\nst_covered_by\nChecks if a geometry is covered by another (includes boundary).\nNo\n\n\nst_equals_exact\nChecks if geometries are exactly equal within a given tolerance.\nYes\n\n\nst_is_within_distance\nChecks if geometries are within a specified distance from each other.\nYes\n\n\n\n\nSparse matrix output: Functions like st_intersects() use sparse matrices to save memory by only registering positive results; setting sparse = FALSE returns a dense matrix.\n\n\n\nCode\n# Create two polygons\n polygon1 &lt;- st_polygon(\n   list(matrix(c(0, 0, 1, 0, 1, 1, 0, 1, 0, 0),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n\n polygon2 &lt;- st_polygon(\n   list(matrix(c(0.5, 0.5, 1.5, 0.5, 1.5, 1.5, 0.5, 1.5, 0.5, 0.5),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n\n polygon3 &lt;- st_polygon(\n   list(matrix(c(0.2, 1.2,\n                 0.5, 1.2, \n                 0.5, 1.5, \n                 0.2, 1.5, \n                 0.2, 1.2),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n\n polygon4 &lt;- st_polygon(\n   list(matrix(c(1.2, 0.2, \n                 1.5, 0.2, \n                 1.5, 0.4, \n                 1.2, 0.4, \n                 1.2, 0.2),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n \n # Convert to sf objects\n sf_poly1 &lt;- st_sfc(polygon1, crs = 4326)\n sf_poly2 &lt;- st_sfc(polygon2, crs = 4326)\n sf_poly3 &lt;- st_sfc(polygon3, crs = 4326)\n sf_poly4 &lt;- st_sfc(polygon4, crs = 4326)\n \n # Create a collection of points\n points &lt;- st_sfc(\n   st_point(c(0.25, 0.25)),\n   st_point(c(0.75, 0.75)),\n   st_point(c(1.25, 1.25)),\n   crs = 4326\n )\n\n sf_points &lt;- tibble(\n   point = c(\"p1\", \"p2\", \"p3\"),\n   geometry = points\n ) |&gt;\n   st_as_sf() |&gt;\n   st_set_crs(4326)\n\n# Keeping environment clean\nrm(polygon1, polygon2, \n   polygon3, polygon4,\n   points)\n\n# Visualize the objects\nggplot() +\n  geom_sf(data = sf_poly1, \n          aes(fill = \"sf_poly1\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_poly2, \n          aes(fill = \"sf_poly2\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_poly3, \n          aes(fill = \"sf_poly3\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_poly4, \n          aes(fill = \"sf_poly4\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_points,\n          aes(fill = point),\n          pch = 21,\n          size = 4) +\n  labs(fill = NULL) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nFigure 2: Some example objects to demonstrate the topological relations\n\n\n\n\n\n\n#################### Symmetrical Relations ######################\n# The order in which sf objects are placed does not matter\n\n## st_intersects()----------------------------------------\nst_intersects(sf_poly1, sf_poly2, sparse = F) \n##      [,1]\n## [1,] TRUE\n\nst_intersects(sf_poly1, sf_points, sparse = F) \n##      [,1] [,2]  [,3]\n## [1,] TRUE TRUE FALSE\n\nst_intersects(sf_poly1, sf_poly3, sparse = F)\n##       [,1]\n## [1,] FALSE\n\nst_intersects(sf_poly2 ,sf_poly3, sparse = F) \n##      [,1]\n## [1,] TRUE\n\n\n# st_disjoint()------------------------------------------\nst_disjoint(sf_poly1, sf_poly4, sparse = F)\n##      [,1]\n## [1,] TRUE\n\nst_disjoint(sf_poly2, sf_poly3, sparse = F) \n##       [,1]\n## [1,] FALSE\n\n\n# st_touches()-------------------------------------------\nst_touches(sf_poly1, sf_poly2, sparse = F) \n##       [,1]\n## [1,] FALSE\n\nst_touches(sf_poly2, sf_poly3, sparse = F)\n##      [,1]\n## [1,] TRUE\n\nst_touches(sf_poly1, sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n\n\n# st_crosses()-------------------------------------------\nst_crosses(sf_poly1, sf_poly2, sparse = F)\n##       [,1]\n## [1,] FALSE\n\nst_crosses(sf_poly1, sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n\n# st_overlaps()\nst_overlaps(sf_poly1, sf_poly2, sparse = F)\n##      [,1]\n## [1,] TRUE\nst_overlaps(sf_poly1, sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\nst_overlaps(sf_poly3, sf_poly3, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n# st_equals()-------------------------------------------\nst_equals(sf_poly1, sf_poly1, sparse = F)\n##      [,1]\n## [1,] TRUE\n\n\n\n# st_equals_exact()-------------------------------------\nst_equals_exact(sf_poly1, sf_poly2, par = 0.1, sparse = F)\n##       [,1]\n## [1,] FALSE\nst_equals_exact(sf_poly1, sf_poly2, par = 1, sparse = F)\n##      [,1]\n## [1,] TRUE\n\n\n# st_is_within_distance()-------------------------------\nst_is_within_distance(sf_poly1, sf_poly2, dist = 0.1, sparse = F)\n##      [,1]\n## [1,] TRUE\nst_is_within_distance(sf_poly2, sf_poly3, dist = 0.1, sparse = F)\n##      [,1]\n## [1,] TRUE\nst_is_within_distance(sf_poly3, sf_poly4, dist = 0.1, sparse = F)\n##       [,1]\n## [1,] FALSE\nst_is_within_distance(sf_poly3, sf_poly4, dist = 13, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n#################### Non-Symmetrical Relations ####################\n# The order in which sf objects are placed changes the outcome\n\n# st_within()-------------------------------------------\nsf_points |&gt; \n  st_within(sf_poly1, sparse = F)\n##       [,1]\n## [1,]  TRUE\n## [2,]  TRUE\n## [3,] FALSE\n\nsf_poly1 |&gt; \n  st_within(sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n\nsf_poly1 |&gt; \n  st_within(sf_poly2, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n# st_contains()-----------------------------------------\nsf_poly1 |&gt; \n  st_contains(sf_points, sparse = F)\n##      [,1] [,2]  [,3]\n## [1,] TRUE TRUE FALSE\n\nsf_points |&gt; \n  st_contains(sf_poly1, sparse = F)\n##       [,1]\n## [1,] FALSE\n## [2,] FALSE\n## [3,] FALSE\n\n\n# st_covers()-------------------------------------------\nsf_poly1 |&gt; \n  st_covers(sf_points, sparse = F)\n##      [,1] [,2]  [,3]\n## [1,] TRUE TRUE FALSE\n\nsf_poly2 |&gt; \n  st_covers(sf_poly1, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n# st_covered_by()---------------------------------------\nsf_points |&gt; \n  st_covered_by(sf_poly1, sparse = F)\n##       [,1]\n## [1,]  TRUE\n## [2,]  TRUE\n## [3,] FALSE\n\n\n\n4.2.3 Distance Relations\n\nDistance relations are continuous, unlike binary topological relations which return TRUE/FALSE values.\nThe st_distance() function calculates distances between two sf objects, returning a matrix with units of measurement (e.g., meters).\nst_centroid(): Computes the geometric centroid of a spatial feature, useful for representing a region’s central point in distance calculations.\nMatrix output:\n\nResults are returned as a matrix, even for single value calculations.\nComputes a distance matrix between all combinations of features in objects (e.g., distances between multiple points and polygons).\n\nPoint-to-polygon distance: Represents the shortest distance from a point to any part of the polygon.\nUsage in distance-based joins: st_distance() is also used for performing joins based on distance criteria.\nAn example code to find distance between central points of Auckland and Canterbury Regions, vs. Top three peaks in New Zealand, returned as a matrix,a nd shown below as a beautiful table using {gt}.\n\n\n# Central points of Auckland and Canterbury Regions\ndf1 &lt;- nz |&gt; \n  filter(str_detect(Name, \"Auck|Canter\")) |&gt; \n  st_centroid() |&gt; \n  select(Name, geom)\n\n# Top 3 highest peaks in New Zealand\ndf2 &lt;- nz_height |&gt; \n  slice_max(order_by = elevation, n = 3)\n\n# Finding the distance matrix\nst_distance(df1, df2) |&gt; \n  as_tibble() |&gt; \n  mutate(state = c(\"Auckland\", \"Canterbury\")) |&gt; \n  relocate(state) |&gt; \n  mutate(\n    across(\n      .cols = -state,\n      .fns = as.numeric\n    )\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    decimals = 1,\n    scale_by = 1e-3\n  ) |&gt; \n  gt::cols_label(V1 = \"Highest Peak\", \n                 V2 = \"Second\",\n                 V3 = \"Third\",\n                 state = \"Centroid of the State\") |&gt; \n  gt::tab_header(\n    title = \"Distance in kilometers\"\n  ) |&gt; \n  gtExtras::gt_theme_538()\n\n\n\nTable 1: Code output for use of st_centroid() and st_distance()\n\n\n\n\n\n\n\n\n\nDistance in kilometers\n\n\nCentroid of the State\nHighest Peak\nSecond\nThird\n\n\n\n\nAuckland\n856.6\n857.3\n856.9\n\n\nCanterbury\n115.5\n115.4\n115.5\n\n\n\n\n\n\n\n\n\n\n\n\n4.2.4 DE-9IM Strings\n\nThe Dimensionally Extended 9-Intersection Model (DE-9IM) underlies binary spatial predicates. This model forms the basis for many spatial operations and helps create custom spatial predicates.\nOrigins:\n\nInitially named “DE + 9IM,” it refers to the dimensions of intersections between the boundaries, interiors, and exteriors of two geometries (Clementini and Di Felice 1995).\nIt applies to two-dimensional geometries (points, lines, polygons) in Euclidean space, requiring data in a projected coordinate reference system (CRS).\n\nHow DE-9IM Works:\n\nThe model visualizes intersections between components of two geometries (interior, boundary, exterior) in a 3x3 matrix form, indicating the dimension of the intersection (0 for points, 1 for lines, 2 for polygons, and F for false).\nFlattening this matrix row-wise results in the DE-9IM string: “212111212”.\n\nUsing st_relate(): The st_relate() function returns DE-9IM strings to describe spatial relations.\nDeveloping Custom Predicates:\n\nBy interpreting DE-9IM strings, custom binary spatial predicates like queen and rook relations can be created:\n\nQueen relations (shared border or point): Pattern F***T****.\nRook relations (shared linear intersection): Pattern F***1****.\n\nCustom functions using st_relate():\n\n\nst_queen = function(x, y) \n  st_relate(x, y, pattern = \"F***T****\")\n\nst_rook = function(x, y) \n  st_relate(x, y, pattern = \"F***1****\")\n\nThis identifies which geometries in a grid have queen or rook relations to the central geometry.\n\n\n\n4.2.5 Spatial Joining with st_join()\n\nSpatial joins combine datasets based on spatial relationships instead of shared key variables (as in non-spatial joins). It adds columns from a source object (y) to a target object (x).\nJoin Details:\n\nDefault behavior: A left join, which retains all rows from x and includes rows with no match from y.\nOperators: Uses st_intersects() by default but can be modified via the join argument.\nHandles all geometry types: Works for points, lines, and polygons, though joins involving polygons may create duplicate rows for multiple matches in y.\n\nFlexibility:\n\nInner joins: Set left = FALSE to include only matched rows.\n\nThe st_join() function: The join argument defines the topological operator to determine these relationships, with the default being st_intersects().\n\nWe can customize this behavior by choosing alternative functions such as st_contains, st_within, st_overlaps, st_touches, or st_disjoint, among others, each defining a different geometric predicate.\nFor example, st_contains selects features where geometries of x fully encompass those of y, while st_within does the reverse.\nAdditionally, advanced options like st_is_within_distance allow proximity-based joins, and st_relate supports customized spatial relationships using a pattern.\n\nExample: Getting 25 random points in the world, and seeing in which countries they fall in Figure 3.\n\n\n\nCode\n# Getting 25 random points on the world,a dn then seeing in which countries they fall\nrandom_points &lt;- tibble(\n  x = round(\n    runif(\n    25, \n    min = st_bbox(world)$xmin, \n    max = st_bbox(world)$xmax\n    ),\n    2\n  ),\n  y = round(\n    runif(\n    25, \n    min = st_bbox(world)$ymin, \n    max = st_bbox(world)$ymax\n    ),\n    2\n  ),\n  id = LETTERS[1:25]\n) |&gt; \n  st_as_sf(coords = c(\"x\", \"y\")) |&gt; \n  st_set_crs(value = crs(world))\n\n\n# Easiest (but not tidyverse) way to subset\n# world[random_points, ]\n\n# Tidyverse way to filter: Names of Countries in which they fall\nintersecting_countries &lt;- world |&gt; \n  st_filter(random_points) |&gt; \n  pull(name_long)\n\n# The power of spatial joins: A tibble of countries where each random\n# point falls. st_join() by default performs a left_join()\nst_join(\n  random_points, \n  world |&gt; select(name_long)\n) |&gt; \n  drop_na() |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_nytimes()\n\n\n\n\n\n\n\n\nid\ngeometry\nname_long\n\n\n\n\nA\nc(144.5, -84.79)\nAntarctica\n\n\nC\nc(-88.34, 54.48)\nCanada\n\n\nE\nc(-75.3, 60.22)\nCanada\n\n\nF\nc(135.09, 66.74)\nRussian Federation\n\n\nI\nc(105.49, 15.32)\nThailand\n\n\nN\nc(19.08, 29.12)\nLibya\n\n\nO\nc(113.88, 48.71)\nMongolia\n\n\nQ\nc(21.99, -33.51)\nSouth Africa\n\n\nU\nc(140.47, 59.39)\nRussian Federation\n\n\n\n\n\n\n\n\n\nCode\nset.seed(42)\n\nworld |&gt; \n  mutate(highlight = name_long %in% intersecting_countries) |&gt; \n  ggplot() +\n  geom_sf(\n    mapping = aes(\n      fill = highlight\n    ),\n    alpha = 0.5\n  ) +\n  scale_fill_manual(\n    values = c(\"transparent\", \"red\")\n  ) +\n  geom_sf(\n    data = random_points,\n    pch = 20,\n    size = 4,\n    colour = \"black\",\n    alpha = 0.5\n  ) +\n  ggrepel::geom_text_repel(\n    data = random_points,\n    mapping = aes(label = id, geometry = geometry),\n    size = 4,\n    colour = \"black\",\n    nudge_x = 2,\n    nudge_y = -2,\n    stat = \"sf_coordinates\"\n  ) +\n  labs(\n    title = \"25 random points on world map, and Countries in which they fall\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\nFigure 3: Using st_join() to spatially join two data sets, based on the st_intersect() relation\n\n\n\n\n\n\n\n4.2.6 Distance-based Joins\n\nDistance-based joins are used when geographic datasets are spatially proximate but do not intersect. The sf package enables such joins using spatial relationships like proximity.\nExample Dataset used:\n\ncycle_hire: Official cycle hire points.\ncycle_hire_osm: Cycle hire points from OpenStreetMap.\nRelationship: These datasets are geographically close but do not overlap, as verified using st_intersects(), which returns FALSE for all points.\n\nImplementation:\n\nCheck Proximity:\n\nUse st_is_within_distance() to determine points within a threshold distance (e.g., 20 meters).\n\nPerform Distance-based Join:\n\nApply st_join() with the st_is_within_distance predicate and a dist argument.\nThe resulting dataset may contain duplicate rows if points in the target object (cycle_hire) match multiple points in the source (cycle_hire_osm).\n\n\nKey Observations:\n\nJoins retain the geometry of features in the target dataset (cycle_hire).\nDistance-based joins are effective for linking datasets that are close geographically but do not overlap.\n\n\nFigure 4 visualizes the spatial relationship between two datasets, cycle_hire and cycle_hire_osm, using a proximity filter. The st_filter() function from the sf package identifies points in the cycle_hire dataset that are within 10 meters of points in cycle_hire_osm, leveraging the st_is_within_distance predicate. The result is a subset of cycle_hire points, which are plotted using ggplot2. The plot includes:\n\nFiltered cycle_hire points (dark blue, fully opaque).\nAll cycle_hire points (dark blue, semi-transparent) for context.\nAll cycle_hire_osm points (red, semi-transparent) to show the proximity relationship.\n\n\n\nCode\ndata(\"cycle_hire\")\ndata(\"cycle_hire_osm\")\n\nggplot() +\n  geom_sf(\n    data = cycle_hire,\n    colour = \"blue\",\n    alpha = 0.5\n  ) +\n  geom_sf(\n    data = cycle_hire_osm,\n    colour = \"red\",\n    alpha = 0.5\n  )\n\n\n\n\n\n\n\n\n\nCode\n# Official Cycle hire points with added info from OSM points within 10 metres\n# \n# cycle_hire |&gt; \n#   st_join(\n#     cycle_hire_osm, \n#     join = st_is_within_distance,\n#     dist = units::set_units(10, \"m\")\n#   )\n\n\nJust checking, whether any of the two points in these two data sets exactly match. Well, they don’t!\n\nst_intersects(cycle_hire, cycle_hire_osm, sparse = F) |&gt; any()\n\n[1] FALSE\n\n\nNow, in Figure 4, we highlight only those points of bike hire in the official data, which are within 10 metres of the OSM data. The important function here is st_filter() along with the argument .predicate = st_is_within_distance() and the argument dist = ... .\n\n\nCode\n# Plot only points which have a OSM point within 10 metres\ncycle_hire |&gt; \n  st_filter(\n    cycle_hire_osm,\n    .predicate = st_is_within_distance,\n    dist = units::set_units(10, \"m\")\n  ) |&gt; \n  ggplot() +\n  geom_sf(size = 3, alpha = 0.75, colour = \"darkblue\") +\n  geom_sf(\n    data = cycle_hire, \n    alpha = 0.2, \n    colour = \"blue\",\n    size = 1\n  ) +\n  geom_sf(\n    data = cycle_hire_osm, \n    alpha = 0.2, \n    colour = \"red\",\n    size = 1\n  )\n\n\n\n\n\n\n\n\nFigure 4: Official Cycle Hire Points Within 10 Meters of OpenStreetMap Locations\n\n\n\n\n\n\n\n4.2.7 Spatial Aggregation\n\nSpatial data aggregation condenses data into fewer rows by summarizing multiple values of a variable into a single value per grouping variable, similar to attribute data aggregation. Following two approaches exist: —\n\nBase R’s aggregate(): Groups values based on spatial relationships and summarizes them with a specified function (e.g., mean).\nTidyverse Approach (group_by() and summarize()): Combines st_join() with grouping and summarizing to perform spatial aggregation while allowing flexibility in function application and column naming. (This approach is better, as shown in Figure 5)\n\nOutput Differences:\n\naggregate() may result in NA for unmatched regions.\nTidyverse methods preserve unmatched region names and allow for more flexible aggregation functions and output formatting.\n\nFunctions like median(), sd(), or other statistical summarizers can replace mean() for different aggregation purposes.\n\n\ndata(\"nz_height\")\ndata(\"nz\")\n\nst_join(x = nz, y = nz_height) |&gt; \n  group_by(Name) |&gt; \n  summarise(elevation = mean(elevation, na.rm = T)) |&gt; \n  ggplot(\n    mapping = aes(fill = elevation)\n  ) +\n  geom_sf() +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Terrain 2\",\n    na.value = \"white\"\n  )\n\n\n\n\n\n\n\nFigure 5: Spatial data aggregation with st_join() from {sf} and summarise() from {tidyverse}\n\n\n\n\n\n\n\n4.2.8 Joining In-congruent Layers\n\nSpatial congruence occurs when two layers (aggregating object y and target object x) share borders, enabling accurate spatial aggregation. Incongruence arises when no shared borders exist, complicating spatial operations.\nExample of Congruence:\n\nAdministrative boundaries, such as districts made of smaller units, typically exhibit spatial congruence.\n\nIssue with Incongruence:\n\nIn-congruent layers, like sub-zones with differing borders from aggregating zones, result in inaccurate aggregations (e.g., centroids of sub-zones).\n\nSolution: Areal Interpolation: Transfers values between areal units using:\n\nSimple area-weighted methods: Proportionally assigns values based on area overlap. This is implemented using st_interpolate_aw().\nAdvanced methods: Include algorithms like ‘pycnophylactic’ interpolation.\n\nExample Dataset:\n\nThe spData package includes incongruent (sub-zones) and aggregating_zones (larger zones). The value column in incongruent represents total regional income in million Euros, which must be aggregated into aggregating_zones.\n\nImplementation: st_interpolate_aw():\n\nThe st_interpolate_aw() function in the sf package performs areal-weighted interpolation of polygon data, allowing attributes from one spatial object (x) to be transferred to another (to) based on area overlap. The extensive argument determines whether attributes are spatially extensive (e.g., population, summed across areas) or spatially intensive (e.g., density, averaged). Additional options include keep_NA (to retain or exclude NA features) and na.rm (to remove features with NA attributes from x).\nAggregated results depend on the variable type:\n\nExtensive variables: Values increase with area (e.g., total income).\nIntensive variables: Values remain constant irrespective of area (e.g., averages).\n\nst_interpolate_aw() handles spatially extensive variables (e.g., total income) by summing values across areas.\nIn st_interpolate_aw(), for spatially intensive variables (e.g., averages, percentages), set extensive = FALSE to use averages instead of sums.\nNote: Warning messages indicate the assumption of uniform attribute distribution across areas.\n\n\n\ndata(\"aggregating_zones\")\ndata(\"incongruent\")\n\n# The two overall main zones for which the total income needs to be computed\naggregating_zones\n\nSimple feature collection with 2 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417686.2 ymin: 443703.6 xmax: 422959.3 ymax: 447036.8\nProjected CRS: OSGB 1936 / British National Grid\n      geo_code geo_label geo_labelw                       geometry\n5164 E02002332 Leeds 003       &lt;NA&gt; MULTIPOLYGON (((418731.9 44...\n6631 E02002333 Leeds 004       &lt;NA&gt; MULTIPOLYGON (((419196.4 44...\n\n# The 9 smaller counties or districts or sub-units which are not\n# congruent with the main zones\nincongruent\n\nSimple feature collection with 9 features and 2 fields\nAttribute-geometry relationships: aggregate (1), NA's (1)\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417686.8 ymin: 443703 xmax: 422963 ymax: 446978\nProjected CRS: OSGB 1936 / British National Grid\n        level    value                       geometry\n1 Incongruent 4.037919 MULTIPOLYGON (((420799.6 44...\n2 Incongruent 5.014419 MULTIPOLYGON (((418664 4464...\n3 Incongruent 4.933000 MULTIPOLYGON (((419964 4462...\n4 Incongruent 5.120139 MULTIPOLYGON (((420368 4441...\n5 Incongruent 6.548912 MULTIPOLYGON (((420419.8 44...\n6 Incongruent 3.749791 MULTIPOLYGON (((421779 4451...\n7 Incongruent 5.432837 MULTIPOLYGON (((419577 4464...\n8 Incongruent 4.618049 MULTIPOLYGON (((417687.6 44...\n9 Incongruent 5.956771 MULTIPOLYGON (((418859.3 44...\n\n# We are using extensive = TRUE, because our variable is \n# total income, not average income\nincongruent |&gt; \n  # We need to keep only the numeric variable (and of course,\n  # the sticky geometry. Otherwise, R will not understand what\n  # to do with non-numeric columns)\n  select(value) |&gt; \n  st_interpolate_aw(aggregating_zones, extensive = TRUE)\n\nWarning in st_interpolate_aw.sf(select(incongruent, value), aggregating_zones,\n: st_interpolate_aw assumes attributes are constant or uniform over areas of x\n\n\nSimple feature collection with 2 features and 1 field\nAttribute-geometry relationship: aggregate (1)\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417686.2 ymin: 443703.6 xmax: 422959.3 ymax: 447036.8\nProjected CRS: OSGB 1936 / British National Grid\n     value                       geometry\n1 19.61613 MULTIPOLYGON (((418731.9 44...\n2 25.66872 MULTIPOLYGON (((419196.4 44..."
  },
  {
    "objectID": "geocomputation/st_is_within_distance.html",
    "href": "geocomputation/st_is_within_distance.html",
    "title": "Using the power of {sf} to plot stores / outlets along a calculated route using sf::st_is_within_distance()",
    "section": "",
    "text": "A tutorial\nThis tutorial demonstrates how to combine geospatial data and tools in R to map store locations along a driving route. By leveraging the power of the {sf} package, we identify stores within a defined distance from a calculated route, enriched with data from OpenAddresses and AllThePlaces. The driving directions are fetched using {osrm}, and raster base maps are integrated via {ggmap} and Stadia Maps.\n\n\nData Preparation and Mapping\nFirst, the driving route between Sydney Opera House and Melbourne Cricket Ground is plotted using {osrm}’s osrmRoute(). Store data, in this case, McDonald’s locations in Australia, is sourced from AllThePlaces in GeoJSON format, converted into an sf object, and visualized on a map alongside the calculated route. Bounding boxes are created to focus the map and ensure a clean visual presentation, making it suitable for social media or reports.\n\n\nFiltering and Analysis\nUsing sf::st_is_within_distance(), stores within 500 meters of the route are identified and labeled. The route and stores are then plotted with customized aesthetics, distinguishing nearby stores with clear color coding. For enhanced visualization, logos or icons can replace points using {ggimage}. Additionally, raster base maps from Stadia Maps are overlaid, requiring a coordinate transformation to integrate smoothly with geom_sf() objects.\n\n\nLinks to Functions and Resources:\n\nRoute Calculation: osrmRoute()\nSpatial Data Handling: st_is_within_distance()\nStore Locations: AllThePlaces\nBase Maps: ggmap and Stadia Maps\nGeospatial Visualization: ggplot2\n\nThe resulting map provides a comprehensive visual tool for understanding proximity-based store access, with applications in retail analysis, logistics, and marketing.\n\n\nCode\nlibrary(tidyverse)   # Data Wrangling\nlibrary(sf)          # Handling Simple Features in R\nlibrary(scales)      # Easy handling numbers and scales\n\n\n\n\nStep 1: Get driving directions\n\n\nCode\n# The raw data to be entered\ndrive_stops &lt;- tibble(\n  station_name = c(\"Sydney Opera House\", \n                  \"Melbourne Cricket Ground\"),\n  city = c(\"Sydney\", \n           \"Melbourne\"),\n  lat = c(-33.85906634, -37.82358305),\n  lon = c(151.21353654, 144.98283670)\n) |&gt; \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\nroute &lt;- osrm::osrmRoute(\n  src = drive_stops$geometry[1],\n  dst = drive_stops$geometry[2]\n)\n\n\n\n\nStep 2: Get list of McDonalds locations in Australia\nCredits: https://openaddresses.io/ and Source: https://www.alltheplaces.xyz/. Finding code for McDonald’s from th WikiData page for the website. The data format is given here. Getting the actual data link for Australia from the spiders page. Courtesy Data-Is-Plural, 24.04.2024 edition.\n\n\nCode\n# Importing raw data: McDonalds in USA\n\nurl1 &lt;- \"https://alltheplaces-data.openaddresses.io/runs/2024-11-16-13-32-12/output/mcdonalds_au.geojson\"\n\nmcdonalds &lt;- geojsonio::geojson_read(url1, what = \"sp\") |&gt; \n  st_as_sf(crs = 4326) |&gt; \n  janitor::clean_names()\n\naus_map &lt;- rnaturalearth::ne_countries(sovereignty = \"Australia\") \n\nggplot() +\n  geom_sf(data = mcdonalds, alpha = 0.15, colour = \"red\") +\n  geom_sf(data = aus_map, fill = NA) +\n  geom_sf(data = route, colour = \"blue\", lwd = 1)\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Settle for a bounding box of 5:4 ratio (for nice twitter post)\n\n\nCode\nlonmin = 143.5\nlonmax &lt;- 151.5\nlatmin &lt;- -40.5\nlatmax &lt;- latmin + ((lonmax - lonmin) * 5/4)\n\n\nmy_new_bbox &lt;- st_polygon(\n  list(rbind(c(lonmin, latmin), \n             c(lonmin, latmax), \n             c(lonmax, latmax), \n             c(lonmax, latmin), \n             c(lonmin, latmin)))\n\n) |&gt; \n  st_sfc() |&gt; \n  st_set_crs(4326)\n\nmy_new_bbox\n\n\nGeometry set for 1 feature \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 143.5 ymin: -40.5 xmax: 151.5 ymax: -30.5\nGeodetic CRS:  WGS 84\n\n\nCode\nggplot() +\n  geom_sf(data = mcdonalds, alpha = 0.15, colour = \"red\") +\n  geom_sf(data = aus_map, fill = NA) +\n  geom_sf(data = route, colour = \"blue\", lwd = 1) +\n  geom_sf(data = my_new_bbox, \n          linewidth = 2,\n          lineend = \"square\",\n          fill = NA,\n          alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\nStep 4: Filter the driving directions and McDonalds locations to within a bounding box\n\n\nCode\naus_map &lt;- rnaturalearth::ne_countries(\n  sovereignty = \"Australia\",\n  scale = \"large\"\n  ) |&gt; \n  st_intersection(my_new_bbox)\n\nmcdonalds_bbox &lt;- mcdonalds |&gt; \n  st_intersection(my_new_bbox) |&gt; \n  select(drive_through, addr_street_address, addr_city, geometry)\n\nggplot() +\n  geom_sf(data = aus_map) +\n  geom_sf(data = mcdonalds_bbox, colour = \"red\", alpha = 0.2) +\n  geom_sf(data = route, colour = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\nStep 5: Use sf::st_is_within_distance() to label Outlets near and far from the highway.\n\n\nCode\n# Within 500 metres of the driving route\nmcdonalds_bbox &lt;- mcdonalds_bbox |&gt; \n  mutate(\n    near_route = as_vector(\n        mcdonalds_bbox |&gt; \n        st_is_within_distance(\n          y = route, \n          dist = 500, \n          sparse = F\n        )\n      )\n  )\n\nmcdonalds_bbox\n\n\nSimple feature collection with 551 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 143.5616 ymin: -38.60672 xmax: 151.4883 ymax: -30.97867\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   drive_through                                   addr_street_address\n1            yes                              1500 Eastlink Northbound\n4           &lt;NA&gt;            Erina Fair Shopping Centre, Terrigal Drive\n5           &lt;NA&gt;              Highpoint Shopping Centre, Rosamond Road\n7           &lt;NA&gt;                             Westpoint Shopping Centre\n8           &lt;NA&gt;                Westfield Penrith, 569-589 High Street\n10          &lt;NA&gt; Macarthur Square Shopping Centre, 200 Gilchrist Drive\n11           yes      Waverley Gardens S/C, Cnr Police & Jackson Roads\n12          &lt;NA&gt;                                     Domestic Terminal\n13          &lt;NA&gt;              Westfield Shopping Centre, George Street\n15          &lt;NA&gt;       Rouse Hill Town Centre, Main St (Cnr Civic Way)\n      addr_city                   geometry near_route\n1      Scoresby POINT (145.2304 -37.89857)      FALSE\n4         Erina POINT (151.3928 -33.43665)      FALSE\n5   Maribyrnong POINT (144.8887 -37.77362)      FALSE\n7     Blacktown POINT (150.9085 -33.77018)      FALSE\n8       Penrith POINT (150.6948 -33.75077)      FALSE\n10 Campbelltown POINT (150.7977 -34.07348)       TRUE\n11     Mulgrave  POINT (145.189 -37.93494)      FALSE\n12       Mascot POINT (151.1798 -33.93414)      FALSE\n13    Liverpool POINT (150.9246 -33.91814)      FALSE\n15   Rouse Hill POINT (150.9252 -33.69134)      FALSE\n\n\nCode\nmcdonalds_bbox |&gt; \n  filter(near_route) |&gt; \n  relocate(near_route) |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::sub_missing(missing_text = \"\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNear Route\nDrive Through\nAddr Street Address\nAddr City\n\n\n\n\nTRUE\n\n\nMacarthur Square Shopping Centre, 200 Gilchrist Drive\nCampbelltown\n\n\nTRUE\nyes\nCnr Victoria Parade & Smith Street\nCollingwood\n\n\nTRUE\nyes\n199 Queens Parade\nClifton Hill\n\n\nTRUE\n\n\nCnr Alfred Street & Loftus St\nCircular Quay\n\n\nTRUE\nyes\nBP Service Centre, Southbound Carriageway, Hume Highway\nGlenrowan\n\n\nTRUE\n\n\nBP Service Centre, Northbound Side, Hume Highway\nGlenrowan\n\n\nTRUE\nyes\n7 Sowerby Street\nGoulburn\n\n\nTRUE\nyes\nCnr Davies & Arab Roads\nPadstow\n\n\nTRUE\nyes\n143 Mount Street\nGundagai\n\n\nTRUE\nyes\nCnr Camden Valley Way & Ash Road\nPrestons\n\n\nTRUE\nyes\nBP Service Centre 1015 Hume Freeway\nWallan\n\n\nTRUE\nyes\n1050 Hume Freeway\nWallan\n\n\nTRUE\nyes\n36 Hoddle Street\nAbbotsford\n\n\nTRUE\nyes\n411-423 Bell Street (Cnr St Georges Road)\nPreston\n\n\nTRUE\nyes\nCnr Common Street & Sydney Road\nGoulburn\n\n\nTRUE\n\n\nR127, 305a Botany Road\nZetland\n\n\n\n\n\n\n\n\n\nStep 6: Plot the driving directions and outlets (labelled by colours)\n\n\nCode\nggplot() +\n  geom_sf(data = route, \n          colour = \"darkgrey\", \n          linewidth = 1.5,\n          alpha = 0.5) +\n  geom_sf(data = aus_map, fill = NA) +\n  geom_sf(\n    data = mcdonalds_bbox, \n    mapping = aes(\n      colour = near_route,\n      alpha = near_route,\n      size = near_route\n    )\n  ) +\n  scale_alpha_manual(values = c(0.1, 0.9), name = \"Within 500m of driving route?\") +\n  scale_size_manual(values = c(1.5, 3), name = \"Within 500m of driving route?\") + \n  scale_colour_manual(values = c(\"darkblue\", \"red\"), name = \"Within 500m of driving route?\") +\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(1,0.1),\n    legend.justification = c(1, 0)\n  )\n\n\n\n\n\n\n\n\n\n\n\nStep 7: Try icons in place of geom_point (geom_sf)\n\n\nCode\nlibrary(magick)\nmcd_icon &lt;- image_read(\"https://seeklogo.com/images/M/mcdonald-s-logo-2325D6C1EF-seeklogo.com.png\") |&gt;\n  image_resize(\"x50\") |&gt;\n  image_write(path = here::here(\"geocomputation\", \"images\", \"mcd_logo.png\"))\n\n\nggplot() +\n  # Base map of Australia within the bounding box\n  geom_sf(data = aus_map, fill = \"white\") +\n  \n  # The Driving Route\n  geom_sf(\n    data = route,\n    colour = \"darkgrey\",\n    linewidth = 1.5,\n    alpha = 0.5\n  ) +\n  \n  # All other McDonald's that are away from the drive\n  geom_sf(\n    data = mcdonalds_bbox |&gt;\n      filter(!near_route),\n    colour = \"darkblue\",\n    alpha = 0.2,\n    pch = 16\n  ) +\n  \n  # McDonald's that lie on the route and are drive through\n  ggimage::geom_image(\n    data = mcdonalds_bbox |&gt;\n      filter(near_route) |&gt;\n      filter(!is.na(drive_through)) |&gt; \n      mutate(image_path = \"geocomputation/images/mcd_logo.png\"),\n    mapping = aes(\n      geometry = geometry,\n      image = mcd_icon\n    ),\n    stat = \"sf_coordinates\",\n    size = 0.02\n  ) +\n  \n  # Labelling the McDonald's that lie on the route and \n  # are drive through using geom_text_repel()\n  ggrepel::geom_text_repel(\n    data = mcdonalds_bbox |&gt;\n      filter(near_route) |&gt; \n      filter(!is.na(drive_through)),\n    mapping = aes(\n      label = addr_city,\n      geometry = geometry\n    ),\n    stat = \"sf_coordinates\"\n  ) +\n  \n  coord_sf(expand = FALSE) +\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0.1),\n    legend.justification = c(1, 0),\n    plot.background = element_rect(\n      fill = \"lightblue\"\n    )\n  )\n\n\n\n\n\n\n\n\n\n\n\nStep 8: Get a base map of raster images from stadia maps\n\n\nCode\n# Get Stadia Maps key: Tutorial at\n# https://aditya-dahiya.github.io/visage/geocomputation/ggmap_rasters.html\nggmap::register_stadiamaps(my_stadiamaps_key)\n\nbase_map_bbox &lt;- c(\n  latmin, latmax, lonmin, lonmax\n)\nnames(base_map_bbox) &lt;- c(\n  \"bottom\", \"top\", \"left\", \"right\"\n)\n\nbase_map &lt;- ggmap::get_stadiamap(\n  bbox = base_map_bbox,\n  zoom = 7,\n  maptype = \"stamen_terrain\"\n)\n\n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nbase_map2 &lt;- ggmap_bbox(base_map)\n\ntemp &lt;- ggmap::ggmap(base_map2) +\n  coord_sf(\n    crs = st_crs(3857),\n    expand = F\n  ) +\n  ggthemes::theme_map()\n\nggsave(\n  filename = here::here(\n    \"geocomputation\",\n    \"images\",\n    \"base_map_st_is_within_distance.png\"\n  ),\n  plot = temp,\n  width = 350,\n  height = 500,\n  units = \"mm\",\n  bg = \"white\"\n)\n\n\n\n\n\nStep 9: Decorate the final product\n\n\nCode\n# Starting the process of Overlaying the geom_sf() data on this\n# Most important is to add the inherit.aes = FALSE argument.\nlibrary(fontawesome)\nsysfonts::font_add_google(\"Saira Extra Condensed\", \"caption_font\")\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ntext_hil &lt;- \"grey20\"\ntext_col &lt;- text_hil\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data:** {ISOcodes} by Christian Buchta & Kurt Hornik\", \n  \" |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\nshowtext::showtext_auto()\nbts &lt;- 90\n\ng &lt;- ggmap::ggmap(base_map2) +\n\n  # The Driving Route\n  geom_sf(\n    data = route,\n    colour = \"black\",\n    linewidth = 1.5,\n    alpha = 0.5,\n    inherit.aes = F\n  ) +\n  \n  \n  # All other McDonald's that are away from the drive\n  geom_sf(\n    data = mcdonalds_bbox |&gt;\n      filter(!near_route),\n    colour = \"red\",\n    alpha = 0.4,\n    size = 3,\n    pch = 16,\n    inherit.aes = F\n  ) +\n  \n  # McDonald's that lie on the route and are drive through\n  ggimage::geom_image(\n    data = mcdonalds_bbox |&gt;\n      filter(near_route) |&gt;\n      filter(!is.na(drive_through)) |&gt; \n      mutate(image_path = \"geocomputation/images/mcd_logo.png\"),\n    mapping = aes(\n      geometry = geometry,\n      image = mcd_icon\n    ),\n    stat = \"sf_coordinates\",\n    size = 0.02,\n    inherit.aes = F\n  ) +\n  \n  # Labelling the McDonald's that lie on the route and \n  # are drive through using geom_text_repel()\n  ggrepel::geom_text_repel(\n    data = mcdonalds_bbox |&gt;\n      filter(near_route) |&gt; \n      filter(!is.na(drive_through)),\n    mapping = aes(\n      label = str_wrap(paste0(addr_street_address,\n                              \", \",\n                              addr_city),\n                       15),\n      geometry = geometry\n    ),\n    stat = \"sf_coordinates\",\n    inherit.aes = F,\n    size = bts / 4,\n    force = 15,\n    family = \"caption_font\",\n    colour = text_hil,\n    lineheight = 0.2,\n    fontface = \"bold\"\n  ) +\n  \n  # Forcing the ggplot2 map to be in CRS: 3857\n  coord_sf(\n    crs = st_crs(3857),\n    expand = F\n  ) +\n  labs(\n    title = \"McDonald's Drive-Through\\nlocations along a drive\\nfrom Sydney to\\nMelbourne\",\n    subtitle = \"Using sf::st_is_within_distance() from {sf}\",\n    caption = plot_caption\n  ) +\n  ggthemes::theme_map(\n    base_family = \"caption_font\",\n    base_size = bts\n  ) +\n  theme(\n    plot.margin = margin(0,0,0,0, \"mm\"),\n    text = element_text(\n      colour = text_hil,\n      lineheight = 0.3\n    ),\n    plot.title = element_text(\n      margin = margin(20,0,-150,5, \"mm\"),\n      hjust = 0,\n      size = 3 * bts,\n      face = \"bold\"\n    ),\n    plot.subtitle = element_text(\n      margin = margin(150,0,-210,5, \"mm\"),\n      hjust = 0,\n      size = 1.5 * bts,\n      face = \"bold\"\n    ),\n    plot.caption = ggtext::element_textbox(\n      margin = margin(-50,0,20,0, \"mm\"),\n      hjust = 1\n    )\n  )\n\nggsave(\n  filename = here::here(\n    \"geocomputation\",\n    \"images\",\n    \"st_is_within_distance.png\"\n  ),\n  plot = g,\n  width = 350,\n  height = 500,\n  units = \"mm\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "geocomputation/chapter4.html#spatial-operations-on-raster-data",
    "href": "geocomputation/chapter4.html#spatial-operations-on-raster-data",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.3 Spatial operations on raster data",
    "text": "4.3 Spatial operations on raster data\n\nDemonstrates advanced spatial raster operations.\nProvides an alternative to manually creating datasets by accessing them from the spData package:\n\nelev: Represents elevation data.\ngrain: Represents grain-related data.\n\n\nelev &lt;- rast(system.file(\"raster/elev.tif\", \n                        package = \"spData\"))\n\ngrain &lt;- rast(system.file(\"raster/grain.tif\", \n                         package = \"spData\"))\n\n# plot(elev)\n# plot(grain)\n\nggplot() +\n  geom_spatraster(data = elev) +\n  labs(title = \"elev SpatRaster\", caption = \"data: {spData}\")\n  \n\nggplot() +\n  geom_spatraster(data = grain) +\n  labs(title = \"grain SpatRaster\", caption = \"data: {spData}\")\n\n\n\n\n\n\n\n\n\n\n\n(a) elev\n\n\n\n\n\n\n\n\n\n\n\n(b) grain\n\n\n\n\n\n\n\nFigure 6: Section 4.3: Raster Datasets used: plotted using ggplot2 and {tidyterra}\n\n\n\n\n4.3.1 Spatial subsetting\n\nBuilds on Section 3.3, which covered retrieving raster values by cell IDs or row/column combinations.\nSpatial subsetting allows extraction of raster data by location (coordinates) or spatial objects:\n\nterra::extract(): Extracts raster values directly using coordinates. (Note: A function with the same name exists in the tidyverse, so be careful to add package name at start).\n\nSubsetting with another raster object:\n\nUse a secondary raster as a spatial mask to subset the primary raster, using terra::extract(ext(...)) .\nExample shown below: Subsetting elev using a smaller raster clip_raster (defining a specific extent).\nTwo kinds of Spatial outputs from subsetting:\n\nUse the drop argument with the [ ] operator to return subsetting results as raster objects.\nExample: Subsets the first two cells of elev with elev[1:2, drop = FALSE], whereas elev[1:2] returns the cell values of first two cells only.\n\n\nMasking raster data with logical values:\n\nCreates a raster mask (rmask) with NA and TRUE values.\nMasks the primary raster (elev) to retain only values corresponding to TRUE in the mask using:\n\n[ ] operator - use TRUE and FALSE.\nmask() function - use TRUE and NA.\n\n\nThe mask() function in the terra package applies a mask to a SpatRaster or SpatVector. It replaces values in a raster (x) with NA (or another value) where another raster or vector (mask) has NA or specified mask values. It’s useful for filtering, clipping, or focusing on specific areas.\nThe extract() function in the terra package retrieves values from a SpatRaster based on specified locations or geometries. Locations can be points (as a SpatVector, matrix, or data frame), cell numbers, or spatial objects like polygons. It supports methods for exact or weighted extraction, interpolation, and summary statistics for extracted data. Key arguments include:\n\nx: The SpatRaster to extract values from\ny: Locations (e.g., points, polygons, or cell numbers) to extract values for.\nfun: Summarizes extracted data for polygons (e.g., mean, sum).\ncells/xy: Optionally return cell numbers or coordinates.\nweights/exact: Extract weighted or exact fractions for polygons.\nbind: Combines extracted values with input geometries (SpatVector).\n\nThe code below demonstrates these spatial operations on raster data. Initially, it showcases how to extract raster values using coordinates with terra::extract() by specifying a set of coordinate pairs. Next, it demonstrates how to create a new raster (clip_raster) to subset the elev raster, focusing on extracting values only within the extent defined by the clip raster using both the [ ] operator and terra::extract(). The example highlights the importance of the drop = FALSE argument in the [ ] operator, which ensures that spatial structure is preserved when subsetting raster objects. Finally, the code illustrates the use of masking with a logical raster (temporary_mask), where specific cells in the elev raster are retained based on TRUE values in the mask. This process is essential for filtering or replacing values (e.g., assigning NA to erroneous data).\n\n\n# Let us extract some values from \"elev\" using coordinates\n# I want to extract coordiantes of \ncoords_extract &lt;- matrix(\n  c(-1.2, -1.2,\n    1.2, 1.2),\n  ncol = 2,\n  byrow = T\n)\n\ncoords_extract\n\n     [,1] [,2]\n[1,] -1.2 -1.2\n[2,]  1.2  1.2\n\nelev |&gt; \n  terra::extract(\n    y = coords_extract\n  )\n\n  elev\n1   31\n2    6\n\n# Let us create a new raster to clip the central four blocks of the elev raster\nclip_raster &lt;- rast(\n  xmin = -0.5, xmax = 0.5, \n  ymin = -0.5, ymax = 0.5,\n  resolution = 0.5, \n  vals = sample(1:25, 4)\n  )\n\n# Extracting only the values\nelev[clip_raster]\n\n  elev\n1   15\n2   16\n3   21\n4   22\n\n# This code somehow doesn't work for me!\n# elev |&gt; \n#   terra::extract(ext(clip_raster))\n\n# Explaining the meaning of argument drop = FALSE in the \n# base R subsetting operator \"[]\"\nelev[1:2]\n\n  elev\n1    1\n2    2\n\nelev[1:2, drop = FALSE]    \n\nclass       : SpatRaster \ndimensions  : 1, 2, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -1.5, -0.5, 1, 1.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : elev \nname        : elev \nmin value   :    1 \nmax value   :    2 \n\n# Creating a temporary_mask object\ntemporary_mask &lt;- elev\nvalues(temporary_mask) &lt;- sample(c(NA, TRUE), 36,\n                                 replace = T)\n# elev |&gt; \n#   mask(temporary_mask)\n\nggplot() +\n  geom_spatraster(data = clip_raster)\n\nggplot() +\n  geom_spatraster(data = temporary_mask) +\n  scale_fill_discrete(na.value = \"white\")\n\nggplot() +\n  geom_spatraster(data = elev |&gt; mask(temporary_mask)) +\n  scale_fill_continuous(na.value = \"white\")\n\n\n\n\n\n\n\n\n\n\n\n(a) Plotting clip_raster: a smaller raster\n\n\n\n\n\n\n\n\n\n\n\n(b) The temporary_mask raster\n\n\n\n\n\n\n\n\n\n\n\n(c) plotting the masked elev, based on a randomly generated temporary_mask\n\n\n\n\n\n\n\nFigure 7: Showing plots from the code of above\n\n\n\n\n\n4.3.3 Local operations\n\nLocal operations are cell-by-cell operations performed on one or more raster layers. Includes operations like addition, subtraction, squaring, logical comparisons, and logarithmic transformations. Examples are shown in Figure 8\nReclassification:\n\nNumeric values can be grouped into intervals (e.g., low, middle, high elevations).\nUse the classify() function with a reclassification matrix to assign new values to defined ranges.\n\n\n\nggplot() +\n  geom_spatraster(data = elev) +\n  ggtitle(\"`elev` - the original raster\") +\n  paletteer::scale_fill_paletteer_c(\"grDevices::terrain.colors\") +\n  theme(legend.position = \"bottom\")\n\nggplot() +\n  geom_spatraster(data = elev^2) +\n  ggtitle(\"elev^2\") +\n  paletteer::scale_fill_paletteer_c(\"grDevices::terrain.colors\") +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(30, \"pt\"))\n\nggplot() +\n  geom_spatraster(data = log2(elev)) +\n  ggtitle(\"log2(elev)\") +\n  paletteer::scale_fill_paletteer_c(\"grDevices::terrain.colors\") +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(30, \"pt\"))\n\n\nggplot() +\n  geom_spatraster(data = elev &gt; 10) +\n  ggtitle(\"elev &gt; 10\") +\n paletteer::scale_fill_paletteer_d(\"ggsci::alternating_igv\") +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(30, \"pt\"))\n\n\n\n\n\n\n\n\n\n\n(a) elev\n\n\n\n\n\n\n\n\n\n\n\n(b) elev^2\n\n\n\n\n\n\n\n\n\n\n\n(c) log2(elev)\n\n\n\n\n\n\n\n\n\n\n\n(d) elev &gt; 10\n\n\n\n\n\n\nFigure 8\n\n\n\n\n\nEfficient alternatives for operations:\n\napp(): The app() function in the {terra} package applies a user-defined or pre-existing function to each cell’s values of a SpatRaster, treating layers as columns in a matrix. Functions should return outputs divisible by the total cell count.\ntapp(): The tapp() function in the {terra} package applies a function to subsets of layers in a SpatRaster grouped by an index. It allows for aggregation or summarization of layers based on grouping criteria such as indices, time periods (e.g., “years”, “months”), or custom functions.\nlapp(): The lapp() function in the {terra} package applies a user-defined function to the layers of a SpatRaster or SpatRasterDataset, treating each layer as an argument to the function. The function must accept a vector of layer values and return a vector or matrix of the same or compatible size. This is useful for combining or transforming layers, such as performing arithmetic operations between them. An example of lapp() is the NDVI Calculation:\n\nNDVI (Normalized Difference Vegetation Index) is a local operation to assess vegetation:\n\nFormula: (NIR - Red) / (NIR + Red).\n\nCalculated from satellite data (e.g., Landsat 8) with red and NIR bands.\n\nPositive NDVI values (&gt; 0.2) indicate vegetation.\nLargest values correspond to dense forests, while lowest values are related to lakes and snowy areas.\n\n\n\n\n\nmulti_rast = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_rast)\n# Rescale values to actual values (stored integers to save disk space)\nmulti_rast = (multi_rast * 0.0000275) - 0.2\n# Remove negative values due to clouds etc.\nmulti_rast[multi_rast &lt; 0] = 0\nobject.size(multi_rast)\n\n1304 bytes\n\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\n\nndvi_rast = lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)\n\nggplot() +\n  geom_spatraster(\n    data = ndvi_rast,\n    mapping = aes(fill = lyr1)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Terrain 2\",\n    direction = -1,\n    limits = c(0, 1),\n    oob = scales::squish\n  ) +\n  labs(\n    title = \"Zion National Park - Satellite Photo Raster\",\n    subtitle = \"Using custom nvdi_fun() to find NVDI\\nand plot vegetation areas in {ggplot2}\",\n    fill = NULL\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(40, \"pt\")\n  )\n\n\n\n\n\n\n\n\n\n\n4.3.4 Focal operations\n\nFocal operations consider a central cell and its neighbours within a defined neighbourhood (kernel, filter, or moving window).\n\nCommon neighbourhood size: 3x3 cells (central cell + 8 neighbours), but customizable sizes and shapes are supported.\nThe operation aggregates values within the neighbourhood and assigns the result to the central cell, iterating across all cells.\n\nImplementation in R:\n\nUse the focal() function to perform spatial filtering Figure 9. Parameters:\n\nw: Defines the weights of the moving window using a matrix, example in Figure 9 (c).\nfun: Specifies the aggregation function (e.g., min, sum, mean, var), as in Figure 9 (b)\n\n\nApplications:\n\nSpatial filtering or convolution for raster operations.\nLow-pass filters:\n\nUse the mean function to smooth and reduce extreme values.\nFor categorical data, replace the mean with the mode (most common value).\n\nHigh-pass filters:\n\nEnhance features using methods like Laplace or Sobel filters (e.g., line detection).\n\nTerrain processing:\n\nCompute topographic characteristics like slope, aspect, and flow directions using focal functions.\n\n\n\n\nggplot() +\n  geom_spatraster(data = elev) +\n  labs(title = \"elev SpatRaster\", caption = \"data: {spData}\")\n\nggplot() +\n  geom_spatraster(\n    data = elev |&gt; \n        terra::focal(\n        w = matrix(rep(1, 9), 3, 3),\n        fun = min\n      )\n  ) +\n  labs(title = \"Focal operation min on a 3X3 matric\",\n       subtitle = \"Simple min() function with na.rm = FALSE\")\n\nggplot() +\n  geom_spatraster(\n    data = elev |&gt; \n        terra::focal(\n        # Sobel filters (for edge detection):\n        w = matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow = 3),\n        fun = mean,\n        na.rm = TRUE\n      )\n  ) +\n  labs(\n    title = \"Focal operation min on a 3X3 matric\",\n    subtitle = \"Sobel filter matrix for edge detection, with mean() function\"\n  )\n\n\n\n\n\n\n\n\n\n\n(a) Original elev raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Focal operation with min() and a simple matrix of equal weights\n\n\n\n\n\n\n\n\n\n\n\n(c) Focal operation with mean() and a sobel filter matrix for edge detection\n\n\n\n\n\n\nFigure 9: Focal operations on Rasters using terra::focal()\n\n\n\n\n\n\n4.3.5 Zonal operations\n\nZonal operations aggregate raster cell values based on zones defined by a second raster with categorical values. Unlike focal operations, zones in zonal operations do not require neighboring cells to be adjacent.\nKey Characteristics:\n\nThe zonal() function in the terra package computes zonal statistics by summarizing the values of a SpatRaster for each “zone” defined by another SpatRaster. It applies a specified function (fun, e.g., mean, sum) to aggregate the data for each zone.\nThe result is typically a summary table, grouped by zones. Zones are defined by a secondary raster.\nOptional Output: A raster with calculated statistics for each zone can be generated by setting as.raster = TRUE.\n\nUsage:\n\nIdeal for summarizing raster values based on irregularly spread categorical zones.\nCommonly used in land classification, soil analysis, and other spatial analyses where zones are pre-defined.\n\n\nggplot() +\n  geom_spatraster(data = elev) +\n  labs(title = \"elev SpatRaster\", caption = \"data: {spData}\")\n  \n\nggplot() +\n  geom_spatraster(data = grain) +\n  labs(title = \"grain SpatRaster\", caption = \"data: {spData}\")\n\n\n\n\n\n\n\n\n\n\n\n(a) elev\n\n\n\n\n\n\n\n\n\n\n\n(b) grain\n\n\n\n\n\n\n\nFigure 10: The elev and grain rasters\n\n\n\n\nelev |&gt; \n  terra::zonal(\n    z = grain,\n    fun = mean\n  ) |&gt; \n  as_tibble()\n\n# A tibble: 3 × 2\n  grain  elev\n  &lt;chr&gt; &lt;dbl&gt;\n1 clay   14.8\n2 silt   21.2\n3 sand   18.7\n\n\n\n\n4.3.6 Global operations and distances\n\nGlobal operations consider the entire raster dataset as a single zone.\nCommon operations include:\n\nDescriptive statistics: Minimum, maximum, etc.\nDistance calculations: Compute distance from each cell to a target cell using terra::distance(). The terra::distance() function calculates the shortest distance from each cell in a raster to a set of target cells, which are identified based on a condition (e.g., where raster values are non-NA, equal to a specific value, or greater than a threshold). This is useful for spatial analysis, such as finding proximity to certain features or zones in a raster.\nWeighted distances: Factor in additional variables, such as elevation, to modify distance calculations.\nVisibility and viewshed analysis: Assess visible areas from a specific point.\n\nApplications:\n\nDistance to coastlines or other target areas.\nTopography-aware distance calculations.\nAdvanced spatial modeling like visibility analysis.\n\n\n\n# Create a sample SpatRaster\nr &lt;- rast(ncols = 10, nrows = 10, \n          xmin = 0, xmax = 10, \n          ymin = 0, ymax = 10)\nvalues(r) &lt;- NA\nvalues(r)[c(5, 15, 25)] &lt;- 1  # Assign specific cells as targets\n\n# Compute the distance to the non-NA cells\ndist_raster &lt;- distance(r)\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\ndist_raster &lt;- dist_raster * 1e-5\n\n# View the raster\nggplot() +\n  geom_spatraster(data = r) +\n  labs(title = \"Original Raster (Targets in Blue)\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\n# View the distance raster\nggplot() +\n  geom_spatraster(data = dist_raster) +\n  labs(title = \"Distance to Targets (in units)\",\n       fill = \"Distance in Degrees\") +\n  paletteer::scale_fill_paletteer_c(\"ggthemes::Red-Gold\") +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\n(a) Original raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Distance raster\n\n\n\n\n\n\n\nFigure 11: Using the terra::distance()\n\n\n\n\n\n4.3.7 Map algebra counterparts in vector processing\n\nEquivalence between raster and vector operations:\n\nDistance raster (global operation) ≈ Buffer operation (vector) (Section 5.2.5).\nRaster reclassification ≈ Dissolving vector boundaries (Section 4.2.5).\nRaster overlay with masks ≈ Vector clipping (Section 5.2.5).\nZonal operations ≈ Aggregating vector geometries by zones.\n\n\n\n\n4.3.8 Merging rasters\n\nCombines multiple raster datasets into a single raster. Often required for datasets spanning multiple spatial scenes (e.g., satellite imagery, elevation data).\nmerge():\n\nPlaces rasters side by side.\nFor overlapping areas, prioritizes values from the first raster.\n\n\n\naut &lt;- geodata::elevation_30s(country = \"AUT\", path = tempdir())\nggplot() +\n  geom_spatraster(data = aut) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Austria\")\n\n\n\n\n\n\n\ncze &lt;- geodata::elevation_30s(country = \"CZE\", path = tempdir())\nggplot() +\n  geom_spatraster(data = cze) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Czechia\")\n\n\n\n\n\n\n\nsvk &lt;- geodata::elevation_30s(country = \"SVK\", path = tempdir())\nggplot() +\n  geom_spatraster(data = svk) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Slovakia\")\n\n\n\n\n\n\n\naut_cze_svk &lt;- aut |&gt; \n  merge(svk) |&gt; \n  merge(cze)\n\nggplot() +\n  geom_spatraster(data = aut_cze_svk) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Austria, Czechia and Slovakia\")\n\n\n\n\n\n\n\n\n\nmosaic():\n\nHandles overlaps by applying a function (e.g., mean) to the overlapping area.\nHelps smooth visible borders but may not eliminate them entirely."
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html",
    "href": "geocomputation/elevation_raster_maps.html",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "",
    "text": "The geodata R package (Hijmans et al. 2024) provides functions to download elevation data for any country, primarily sourced from the Shuttle Radar Topography Mission (SRTM). The elevation_3s function retrieves high-resolution elevation data (approximately 90 meters, i.e., 3 arc seconds) for specified coordinates, while elevation_30s offers coarser resolution data (about 1 kilometre, i.e., 30 arc seconds) for entire countries. For global coverage, elevation_global allows users to obtain elevation data at resolutions ranging from 0.5 to 10 arc-minutes. These datasets are essential for various geospatial analyses, including topographic assessments and environmental modelling.\n\n\nCode\n# Load spatial and environmental datasets.\nlibrary(geodata)\n\n# Handle, analyze, and visualize raster and vector data.\nlibrary(terra)\n\n# Tidy data workflows with 'terra' objects.\nlibrary(tidyterra)\n\n# Data manipulation, visualization, and wrangling.\nlibrary(tidyverse)"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#package-geodata",
    "href": "geocomputation/elevation_raster_maps.html#package-geodata",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "",
    "text": "The geodata R package (Hijmans et al. 2024) provides functions to download elevation data for any country, primarily sourced from the Shuttle Radar Topography Mission (SRTM). The elevation_3s function retrieves high-resolution elevation data (approximately 90 meters, i.e., 3 arc seconds) for specified coordinates, while elevation_30s offers coarser resolution data (about 1 kilometre, i.e., 30 arc seconds) for entire countries. For global coverage, elevation_global allows users to obtain elevation data at resolutions ranging from 0.5 to 10 arc-minutes. These datasets are essential for various geospatial analyses, including topographic assessments and environmental modelling.\n\n\nCode\n# Load spatial and environmental datasets.\nlibrary(geodata)\n\n# Handle, analyze, and visualize raster and vector data.\nlibrary(terra)\n\n# Tidy data workflows with 'terra' objects.\nlibrary(tidyterra)\n\n# Data manipulation, visualization, and wrangling.\nlibrary(tidyverse)"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#getting-world-elevation-map",
    "href": "geocomputation/elevation_raster_maps.html#getting-world-elevation-map",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Getting World Elevation Map",
    "text": "Getting World Elevation Map\nThis code downloads global elevation data at a 10-degree resolution using the geodata package, calculates its memory size in R, and visualizes it using ggplot2. The geom_spatraster function plots the raster data, applying a colour scale with squished limits (0-6000 meters), and customizes the map’s title, subtitle, and legend placement.\n\n\nCode\nworld &lt;- geodata::elevation_global(10, path = tempdir())\n\n# With ggplot2\ng &lt;- ggplot() +\n  geom_spatraster(data = world) +\n  scale_fill_wiki_c(\n    limits = c(0, 6000),\n    oob = scales::squish\n  ) +\n  labs(\n    title = \"World Elevation Map\",\n    subtitle = \"Resolution of 10 degrees\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(50, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"elevation_raster_maps_1.png\"),\n  height = 1400,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 1: A simple elevation map of the world using data from {geodata} and geom_spatraster() from {terra}"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#countries-in-geodata",
    "href": "geocomputation/elevation_raster_maps.html#countries-in-geodata",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Countries in {geodata}",
    "text": "Countries in {geodata}\nThis code retrieves country codes from the geodata package, converts them into a tibble, and displays them in a styled, interactive table using the gt package. Column labels are formatted with snakecase and stringr, missing values are replaced with blank text, and a custom theme with a header title is applied for presentation.\n\n\nCode\ngeodata::country_codes() |&gt; \n  as_tibble() |&gt; \n  gt::gt() |&gt;\n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::cols_label_with(fn = str_to_upper) |&gt;\n  gt::sub_missing(missing_text = \"\") |&gt; \n  gt::opt_interactive() |&gt; \n  # gtExtras::gt_theme_538() |&gt; \n  gt::tab_header(\n    title = \"List of countries available in {geodata}\"\n  )\n\n\n\n\nTable 1\n\n\n\n\n\n\nList of countries available in {geodata}"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#country-specific-raster-elevation-maps",
    "href": "geocomputation/elevation_raster_maps.html#country-specific-raster-elevation-maps",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Country-specific raster elevation maps",
    "text": "Country-specific raster elevation maps\nThis code downloads 30-arc-second resolution elevation data for Switzerland using the geodata package and visualizes it with ggplot2. The elevation is displayed as a raster map with a colour scale capped at 6000 meters, custom titles, subtitles, and a bottom-positioned legend with an adjusted width.\n\n\nCode\n# Taking a smaller country to save data download time\nswitzerland_raster &lt;- geodata::elevation_30s(\n  country = \"CHE\", \n  path = tempdir()\n  )\n\n# With ggplot2\ng &lt;- ggplot() +\n  geom_spatraster(data = switzerland_raster) +\n  scale_fill_wiki_c(\n    limits = c(0, 6000),\n    oob = scales::squish\n  ) +\n  labs(\n    title = \"Elevation Map of Switzerland\",\n    subtitle = \"Resolution of approx. 1 km (30 arc seconds)\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(50, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"elevation_raster_maps_2.png\"),\n  height = 1400,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 2: Base raster map of Switzerland from {geodata}"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#getting-outline-map-of-switzerland-sf",
    "href": "geocomputation/elevation_raster_maps.html#getting-outline-map-of-switzerland-sf",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Getting outline map of Switzerland {sf}",
    "text": "Getting outline map of Switzerland {sf}\nThis code creates two visualizations of Switzerland using ggplot2. The first plot is a vector map generated from the {rnaturalearth} package, displaying Switzerland’s boundaries at a large scale (1:10 million). The second plot combines this vector boundary with a high-resolution raster elevation map from switzerland_raster, highlighting elevation levels up to 6000 meters. The raster data is overlaid with a transparent outline of Switzerland and utilizes a squished colour scale for elevation visualization.\n\n\nCode\nswitzerland_vector &lt;- rnaturalearth::ne_countries(\n  country = \"Switzerland\",\n  returnclass = \"sf\",\n  scale = \"large\"\n)\n\ng &lt;- ggplot() +\n  geom_sf(data = switzerland_vector) +\n  labs(\n    title = \"Vector Map of Switzerland from {rnaturalearth}\",\n    subtitle = \"Scale of 1:10 million\",\n    fill = \"Elevation (metres)\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"elevation_raster_maps_3.png\"),\n  height = 1400,\n  width = 2000,\n  units = \"px\"\n)\n\ng &lt;- ggplot() +\n  geom_spatraster(data = switzerland_raster) +\n  geom_sf(\n    data = switzerland_vector,\n    linewidth = 1, \n    fill = NA,\n    colour = \"black\",\n    alpha = 0.8\n  ) +\n  coord_sf(\n    crs = 4326\n  ) +\n  scale_fill_wiki_c(\n    limits = c(0, 6000),\n    oob = scales::squish\n  ) +\n  labs(\n    title = \"Elevation Map of Switzerland\",\n    subtitle = \"Overlaid with a vector map with geom_sf()\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(40, \"pt\")\n  )\n\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"elevation_raster_maps_4.png\"),\n  height = 1400,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Switzerland: Vector map using geom_sf{}\n\n\n\n\n\n\n\n\n\n\n\n(b) Vector map of Switzerland, plotted using {sf}, overlaid with a raster map, plotted using {terra}\n\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#raster-operations-spatial-subsetting",
    "href": "geocomputation/elevation_raster_maps.html#raster-operations-spatial-subsetting",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Raster Operations: Spatial Subsetting",
    "text": "Raster Operations: Spatial Subsetting\nThis code calculates the mean elevation of Switzerland using a raster dataset and filters the raster to show only areas above 2000 meters. It then visualizes these high-altitude regions as a raster map overlaid with Switzerland’s vector boundaries using ggplot2. The map employs a custom color palette, minimal theme, and detailed labels, emphasizing Switzerland’s mountain ranges above 2000 meters elevation.\n\n# Mean elevation above Sea Level in Switzerland\nswitzerland_raster |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  summarise(mean = mean(CHE_elv_msk, na.rm = T)) |&gt; \n  pull(mean)\n\n#&gt; [1] 1289.186\n\nThe mean elevation of Switzerland is 1,289.19 metres.\n\n\nCode\n# Plotting only those portions of Switzerland that are above 2000 metres above sea level\nswit_mountains &lt;- switzerland_raster &gt; 2000\nswit_mountains &lt;- switzerland_raster[swit_mountains, drop = FALSE]\n\ng &lt;- ggplot() +\n  geom_spatraster(data = swit_mountains) +\n  geom_sf(\n    data = switzerland_vector,\n    linewidth = 1, \n    fill = NA,\n    colour = \"black\",\n    alpha = 0.8\n  ) +\n  coord_sf(\n    crs = 4326\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Brown\",\n    na.value = \"transparent\"\n    ) +\n  labs(\n    title = \"Switzerland mountain ranges\",\n    subtitle = \"Only showing areas above 2000 metres elevation\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(40, \"pt\")\n  )\n\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"elevation_raster_maps_5.png\"),\n  height = 1400,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 4: Subsetting rasters: Displaying areas in Switzerland with altitude over 2000 metres"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#computing-distance-from-highest-point-in-switzerland",
    "href": "geocomputation/elevation_raster_maps.html#computing-distance-from-highest-point-in-switzerland",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Computing distance from highest point in Switzerland",
    "text": "Computing distance from highest point in Switzerland\nThis code identifies Switzerland’s highest elevation point at 4442 meters and filters for all three raster points above 4200 meters. It calculates distances from these points (and removes non-Switzerland areas: this is work-in-progress). Finally, it visualizes these extreme elevations on a map using ggplot2, overlaying the filtered raster data with Switzerland’s vector boundaries. The plot employs a custom brown color palette and highlights the topographic peaks within Switzerland exceeding 4200 meters.\n\n\nCode\n# Highest Point in Switzerland\nswitzerland_raster |&gt; \n  values() |&gt; \n  max(na.rm = TRUE)\n\n# It is 4442 metres above sea level.\n\n# Let us select all points above 4200 metres\nswit_4200 &lt;- switzerland_raster == 4442\nswit_4200 &lt;- switzerland_raster[swit_4200, drop = FALSE]\nswit_4200 &lt;- terra::distance(swit_4200)\nswit_4200 &lt;- swit_4200 / 1000\n\n# Remove non-Switzerland area\nvalues(swit_4200) &lt;- tibble(\n  dist = values(swit_4200),\n  actual = values(switzerland_raster)\n) |&gt; \n  mutate(\n    masked = if_else(\n      is.nan(actual),\n      NA,\n      dist\n    )\n  ) |&gt; \n  pull(masked)\n\n# Plotting the three points in Switzerland above 4200 m\ng &lt;- ggplot() +\n  geom_spatraster(data = swit_4200) +\n  coord_sf(\n    crs = 4326\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Inferno\",\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Distance to Switzerland's highest points\",\n    subtitle = \"Distance from the highest points (&gt;4200 m elevation)\",\n    fill = \"Distance (km)\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(40, \"pt\")\n  )\n\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"elevation_raster_maps_6.png\"),\n  height = 1400,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 5: Distance from the highest point in Switzerland"
  },
  {
    "objectID": "geocomputation/elevation_raster_maps.html#next-steps",
    "href": "geocomputation/elevation_raster_maps.html#next-steps",
    "title": "Using {geodata} to get elevation raster maps",
    "section": "Next steps",
    "text": "Next steps\nStudy this page, and write more about other awesome functions in {geodata}."
  },
  {
    "objectID": "geocomputation/chapter4.html#exercises",
    "href": "geocomputation/chapter4.html#exercises",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.4 Exercises",
    "text": "4.4 Exercises\n\nE1.\nIt was established in Section 4.2 that Canterbury was the region of New Zealand containing most of the 101 highest points in the country. How many of these high points does the Canterbury region contain?\nCanterbury contains 70 of these high points.\n\ndata(\"nz\")\ndata(\"nz_height\")\n\nnz_height |&gt; \n  st_intersection(\n    nz |&gt; filter(Name == \"Canterbury\")\n  ) |&gt; \n  nrow()\n\n[1] 70\n\n\nBonus: plot the result using the plot() function to show all of New Zealand, canterbury region highlighted in yellow, high points in Canterbury represented by red crosses (hint: pch = 7) and high points in other parts of New Zealand represented by blue circles. See the help page ?points for details with an illustration of different pch values.\n\nnz_height |&gt; \n  mutate(\n    in_canterbury = nz_height |&gt; \n      st_intersects(\n        nz |&gt; filter(Name == \"Canterbury\"),\n        sparse = FALSE\n      )\n  ) |&gt; \n  ggplot() +\n  geom_sf(\n    data = nz |&gt; mutate(fill_var = Name == \"Canterbury\"),\n    mapping = aes(fill = fill_var)\n  ) +\n  geom_sf(\n    mapping = aes(shape = in_canterbury, colour = in_canterbury)\n  ) +\n  scale_shape_manual(values = c(16, 4)) +\n  scale_colour_manual(values = c(\"blue\", \"red\")) +\n  scale_fill_manual(values = c(\"transparent\", \"yellow\")) +\n  labs(\n    fill = \"Is the region Canterbury?\",\n    colour = \"Peaks are in Canterbury?\",\n    shape = \"Peaks are in Canterbury?\"\n  ) +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\nE2.\nWhich region has the second highest number of nz_height points, and how many does it have?\nThe region with second highest number of nz_height points is West Coast. It has 22 such points.\n\nnz_height |&gt; \n  st_join(nz) |&gt; \n  st_drop_geometry() |&gt; \n  group_by(Name) |&gt; \n  count()\n\n# A tibble: 7 × 2\n# Groups:   Name [7]\n  Name                  n\n  &lt;chr&gt;             &lt;int&gt;\n1 Canterbury           70\n2 Manawatu-Wanganui     2\n3 Marlborough           1\n4 Otago                 2\n5 Southland             1\n6 Waikato               3\n7 West Coast           22\n\n\n\n\n\nE3.\nGeneralizing the question to all regions: how many of New Zealand’s 16 regions contain points which belong to the top 101 highest points in the country? Which regions?\n\nBonus: create a table listing these regions in order of the number of points and their name.\n\nSeven (7) regions of New Zealand contain points which belong to top 101 highest points in the country. The table is shown below.\n\nnz_height |&gt; \n  st_join(nz) |&gt; \n  st_drop_geometry() |&gt; \n  group_by(Name) |&gt; \n  count(name = \"Number of points\", sort = T) |&gt; \n  ungroup() |&gt; \n  mutate(`S.No.` = row_number()) |&gt; \n  relocate(`S.No.`) |&gt;\n  gt::gt() |&gt; \n  gtExtras::gt_theme_538() |&gt; \n  gt::tab_header(\n    title = \"Number of highest points in each region of New Zealand\"\n  )\n\n\n\nTable 2: Table listing the regions\n\n\n\n\n\n\n\n\n\nNumber of highest points in each region of New Zealand\n\n\nS.No.\nName\nNumber of points\n\n\n\n\n1\nCanterbury\n70\n\n\n2\nWest Coast\n22\n\n\n3\nWaikato\n3\n\n\n4\nManawatu-Wanganui\n2\n\n\n5\nOtago\n2\n\n\n6\nMarlborough\n1\n\n\n7\nSouthland\n1\n\n\n\n\n\n\n\n\n\n\n\nTest your knowledge of spatial predicates by finding out and plotting how US states relate to each other and other spatial objects.\n\n\nE4.\nThe starting point of this exercise is to create an object representing Colorado state in the USA. Do this with the command colorado = us_states[us_states$NAME == \"Colorado\",] (base R) or with the filter() function (tidyverse) and plot the resulting object in the context of US states.\n\ndata(\"us_states\")\n\ncolorado &lt;- us_states |&gt; \n  filter(NAME == \"Colorado\")\n\nggplot() +\n  geom_sf(data = colorado) +\n  ggtitle(\"Map of Colorado State\") +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  )\n\n\n\n\n\n\n\nFigure 12: Map of Colorado State\n\n\n\n\n\n\nCreate a new object representing all the states that geographically intersect with Colorado and plot the result (hint: the most concise way to do this is with the subsetting method [).\n\n\nggplot() +\n  geom_sf(\n    data = us_states,\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = colorado,\n    fill = \"yellow\"\n  ) +\n  geom_sf_text(\n    data = colorado,\n    mapping = aes(\n      label = NAME\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\"\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Map of USA states, with Colorado highlighted\"\n  )\n\n\n\n\n\n\n\nFigure 13: Colorado, within USA’s states; with projection changed to Albers Equal Area Projection\n\n\n\n\n\n\nCreate another object representing all the objects that touch (have a shared boundary with) Colorado and plot the result (hint: remember you can use the argument op = st_intersects and other spatial relations during spatial subsetting operations in base R).\n\n\nbordering &lt;- us_states |&gt; \n  mutate(\n    border_colorado = as_vector(\n      as_vector(\n        us_states |&gt; \n        st_intersects(colorado, sparse = FALSE)\n      )\n    )\n  )\n\nggplot() +\n  geom_sf(\n    data = bordering,\n    mapping = aes(\n      fill = border_colorado\n    )\n  ) +\n  scale_fill_manual(\n    values = c(\"transparent\", \"orange\")\n  ) +\n  geom_sf_text(\n    data = filter(bordering, border_colorado),\n    mapping = aes(\n      label = NAME\n    ),\n    family = \"caption_font\"\n  ) +\n  geom_sf(\n    data = colorado,\n    fill = \"red\"\n  ) +\n  geom_sf_text(\n    data = colorado,\n    mapping = aes(\n      label = NAME\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\"\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Map of USA states, with states bordering Colorado highlighted in orange\"\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\nBonus: create a straight line from the centroid of the District of Columbia near the East coast to the centroid of California near the West coast of the USA (hint: functions st_centroid(), st_union() and st_cast() described in Chapter 5 may help) and identify which states this long East-West line crosses.\n\n\nwdc_centre &lt;- st_centroid(\n  us_states |&gt; filter(NAME == \"District of Columbia\")\n) |&gt; \n  pull(geometry)\n\ncal_centre &lt;- st_centroid(\n  us_states |&gt; filter(NAME == \"California\")\n) |&gt; \n  pull(geometry)\n\nstraight_line &lt;- st_union(\n  wdc_centre,\n  cal_centre\n) |&gt; \n  st_cast(\n    \"LINESTRING\"\n  )\n\nus_states |&gt; \n  mutate(\n    on_the_way = as_vector(\n      st_intersects(\n        us_states, \n        straight_line, \n        sparse = FALSE\n      )\n    )\n  ) |&gt; \n  ggplot() +\n  geom_sf(\n    mapping = aes(\n      fill = on_the_way\n    )\n  ) +\n  scale_fill_manual(\n    values = c(\"transparent\", \"orange\")\n  ) +\n  geom_sf(\n    data = straight_line,\n    linewidth = 0.5\n  ) +\n  geom_sf(\n    data = cal_centre,\n    size = 2\n  ) +\n  geom_sf(\n    data = wdc_centre,\n    size = 2\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  ) +\n  labs(\n    subtitle = \"Line from Centroids of District of Columbia and California;\\nand highlighting the states that it crosses through\"\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nE5.\nUse dem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\")), and reclassify the elevation in three classes: low (&lt;300), medium and high (&gt;500). Secondly, read the NDVI raster (ndvi = rast(system.file(\"raster/ndvi.tif\", package = \"spDataLarge\"))) and compute the mean NDVI and the mean elevation for each altitudinal class.\n\ndem &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\nggplot() +\n  geom_spatraster(data = dem) +\n  paletteer::scale_fill_paletteer_c(\"grDevices::Terrain 2\")\n\n\n\n\n\n\n\n\n\n\n\nE6.\nApply a line detection filter to rast(system.file(\"ex/logo.tif\", package = \"terra\")). Plot the result. Hint: Read ?terra::focal().\n\n\n\nE7.\nCalculate the Normalized Difference Water Index (NDWI; (green - nir)/(green + nir)) of a Landsat image. Use the Landsat image provided by the spDataLarge package (system.file(\"raster/landsat.tif\", package = \"spDataLarge\")). Also, calculate a correlation between NDVI and NDWI for this area (hint: you can use the layerCor() function).\n\n\n\nE8.\nA StackOverflow post (stackoverflow.com/questions/35555709) shows how to compute distances to the nearest coastline using raster::distance(). Try to do something similar but with terra::distance(): retrieve a digital elevation model of Spain, and compute a raster which represents distances to the coast across the country (hint: use geodata::elevation_30s()). Convert the resulting distances from meters to kilometers. Note: it may be wise to increase the cell size of the input raster to reduce compute time during this operation (aggregate()).\nE9. Try to modify the approach used in the above exercise by weighting the distance raster with the elevation raster; every 100 altitudinal meters should increase the distance to the coast by 10 km. Next, compute and visualize the difference between the raster created using the Euclidean distance (E7) and the raster weighted by elevation."
  },
  {
    "objectID": "geocomputation/crs_projections.html",
    "href": "geocomputation/crs_projections.html",
    "title": "Various CRS projections for use with {sf} plots in {ggplot2}",
    "section": "",
    "text": "No.\nProjection Name\nEPSG /ESRI Code\nExample & coord_sf() code\nDescription\nUse Case\n\n\n\n\n1\nWGS 84 (Geographic)\n4326\nFigure 1\nEPSG:4326\nDefault geographic coordinate system using latitude and longitude.\nWorking with raw geographic coordinates.\n\n\n2\nWeb Mercator\n3857\nFigure 2\nEPSG:3857\nUsed by most web mapping services like Google Maps, OpenStreetMap.\nVisualizing data on interactive maps or raster tiles.\n\n\n3\nUTM Zone 33N\n32633\nFigure 3\nEPSG:32633\nUniversal Transverse Mercator for Zone 33 North (WGS 84).\nDetailed mapping with minimal distortion for Zone 33N.\n\n\n4\nUTM Zone 33S\n32733\nFigure 4\nEPSG:32733\nUniversal Transverse Mercator for Zone 33 South (WGS 84).\nDetailed mapping with minimal distortion for Zone 33S.\n\n\n5\nNAD83\n4269\nFigure 5\nEPSG:4269\nNorth American Datum 1983.\nStandard for North American datasets.\n\n\n6\nETRS89 / LAEA Europe\n3035\nFigure 6\nEPSG:3035\nLambert Azimuthal Equal Area projection for Europe.\nMapping datasets across Europe with minimal area distortion.\n\n\n7\nWGS 84 / Pseudo-Mercator\n3857\nFigure 7\nEPSG:3857\nSimilar to Web Mercator but suited for global-scale applications.\nQuick global visualizations and compatibility with tile layers.\n\n\n8\nAlbers Equal Area\n5070\nFigure 8\nEPSG:5070\nAlbers Equal Area for continental-scale datasets in the US.\nUS-focused analysis with equal-area properties.\n\n\n9\nLambert Conformal Conic\n102004 (ESRI)\nFigure 9\nESRI:102004\nProjection widely used for mapping in the US.\nRegional analysis and thematic mapping in North America.\n\n\n10\nMollweide\n54009 (ESRI)\nFigure 10\nESRI:54009\nEqual-area pseudocylindrical projection for global maps.\nGlobal-scale thematic maps with equal area representation.\n\n\n11\nRobinson\n54030 (ESRI)\nFigure 11\nESRI:54030\nA compromise projection for visually pleasing world maps.\nWorld maps for general use, emphasizing aesthetics.\n\n\n12\nSinusoidal\n54008 (ESRI)\nFigure 12\nESRI:54008\nPseudocylindrical equal-area projection.\nGlobal-scale analysis with equal-area properties.\n\n\n13\nBonne\n54024 (ESRI)\nFigure 13\nESRI:54024\nEqual-area projection, often used for continents.\nRegional mapping with minimized distortion.\n\n\n14\nWorld Van der Grinten I\n54029 (ESRI)\nFigure 14\nESRI:54029\nProjection displaying the entire world in a circular format.\nAesthetic and general-purpose world maps.\n\n\n15\nPlate Carrée\n32662\nFigure 15\nEPSG:32662\nSimple projection with equally spaced latitudes and longitudes.\nBasic visualization of geographic data.\n\n\n16\nTransverse Mercator\n4326\nFigure 16\nEPSG:4326\nCylindrical projection ideal for mapping narrow regions.\nRegional and local-scale mapping (often used with UTM zones).\n\n\n17\nNorth Pole Stereographic\n3413\nFigure 17\nEPSG:3413\nStereographic projection for mapping the Arctic region.\nMapping polar data in the Arctic with minimal distortion.\n\n\n18\nSouth Pole Stereographic\n3031\nFigure 18\nEPSG:3031\nStereographic projection for mapping the Antarctic region.\nMapping polar data in the Antarctic with minimal distortion.\n\n\n19\nInterrupted Goode Homolosine\n54052 (ESRI)\nFigure 19\nESRI:54052\nComposite projection for minimal distortion of landmasses.\nGlobal mapping that emphasizes land area accuracy.\n\n\n20\nKrovak\n5514\nFigure 20\nEPSG:5514\nProjection widely used in the Czech Republic and Slovakia.\nMapping datasets specific to these regions.\n\n\n21\nAsia North Lambert Conformal\n102026 (ESRI)\nFigure 21\nESRI:102026\nLambert Conformal projection for northern Asia.\nMapping datasets across northern Asia.\n\n\n22\nAustralia Albers\n3577\nFigure 22\nEPSG:3577\nEqual-area projection for Australia.\nRegional mapping of Australia with minimized area distortion.\n\n\n\nSetting up the basic code, libraries and getting world map data\n\n\nCode\nlibrary(tidyverse)          # Data wrangling\nlibrary(sf)                 # Simple Features in R\nlibrary(rnaturalearth)      # Map data\n\nworld &lt;- ne_countries(\n  scale = \"medium\",\n  returnclass = \"sf\"\n) |&gt; \n  select(name, name_long, \n         iso_a2, iso_a3, \n         geometry, continent)"
  },
  {
    "objectID": "geocomputation/crs_projections.html#a-table-of-various-projections",
    "href": "geocomputation/crs_projections.html#a-table-of-various-projections",
    "title": "Various CRS projections for use with {sf} plots in {ggplot2}",
    "section": "",
    "text": "No.\nProjection Name\nEPSG /ESRI Code\nExample & coord_sf() code\nDescription\nUse Case\n\n\n\n\n1\nWGS 84 (Geographic)\n4326\nFigure 1\nEPSG:4326\nDefault geographic coordinate system using latitude and longitude.\nWorking with raw geographic coordinates.\n\n\n2\nWeb Mercator\n3857\nFigure 2\nEPSG:3857\nUsed by most web mapping services like Google Maps, OpenStreetMap.\nVisualizing data on interactive maps or raster tiles.\n\n\n3\nUTM Zone 33N\n32633\nFigure 3\nEPSG:32633\nUniversal Transverse Mercator for Zone 33 North (WGS 84).\nDetailed mapping with minimal distortion for Zone 33N.\n\n\n4\nUTM Zone 33S\n32733\nFigure 4\nEPSG:32733\nUniversal Transverse Mercator for Zone 33 South (WGS 84).\nDetailed mapping with minimal distortion for Zone 33S.\n\n\n5\nNAD83\n4269\nFigure 5\nEPSG:4269\nNorth American Datum 1983.\nStandard for North American datasets.\n\n\n6\nETRS89 / LAEA Europe\n3035\nFigure 6\nEPSG:3035\nLambert Azimuthal Equal Area projection for Europe.\nMapping datasets across Europe with minimal area distortion.\n\n\n7\nWGS 84 / Pseudo-Mercator\n3857\nFigure 7\nEPSG:3857\nSimilar to Web Mercator but suited for global-scale applications.\nQuick global visualizations and compatibility with tile layers.\n\n\n8\nAlbers Equal Area\n5070\nFigure 8\nEPSG:5070\nAlbers Equal Area for continental-scale datasets in the US.\nUS-focused analysis with equal-area properties.\n\n\n9\nLambert Conformal Conic\n102004 (ESRI)\nFigure 9\nESRI:102004\nProjection widely used for mapping in the US.\nRegional analysis and thematic mapping in North America.\n\n\n10\nMollweide\n54009 (ESRI)\nFigure 10\nESRI:54009\nEqual-area pseudocylindrical projection for global maps.\nGlobal-scale thematic maps with equal area representation.\n\n\n11\nRobinson\n54030 (ESRI)\nFigure 11\nESRI:54030\nA compromise projection for visually pleasing world maps.\nWorld maps for general use, emphasizing aesthetics.\n\n\n12\nSinusoidal\n54008 (ESRI)\nFigure 12\nESRI:54008\nPseudocylindrical equal-area projection.\nGlobal-scale analysis with equal-area properties.\n\n\n13\nBonne\n54024 (ESRI)\nFigure 13\nESRI:54024\nEqual-area projection, often used for continents.\nRegional mapping with minimized distortion.\n\n\n14\nWorld Van der Grinten I\n54029 (ESRI)\nFigure 14\nESRI:54029\nProjection displaying the entire world in a circular format.\nAesthetic and general-purpose world maps.\n\n\n15\nPlate Carrée\n32662\nFigure 15\nEPSG:32662\nSimple projection with equally spaced latitudes and longitudes.\nBasic visualization of geographic data.\n\n\n16\nTransverse Mercator\n4326\nFigure 16\nEPSG:4326\nCylindrical projection ideal for mapping narrow regions.\nRegional and local-scale mapping (often used with UTM zones).\n\n\n17\nNorth Pole Stereographic\n3413\nFigure 17\nEPSG:3413\nStereographic projection for mapping the Arctic region.\nMapping polar data in the Arctic with minimal distortion.\n\n\n18\nSouth Pole Stereographic\n3031\nFigure 18\nEPSG:3031\nStereographic projection for mapping the Antarctic region.\nMapping polar data in the Antarctic with minimal distortion.\n\n\n19\nInterrupted Goode Homolosine\n54052 (ESRI)\nFigure 19\nESRI:54052\nComposite projection for minimal distortion of landmasses.\nGlobal mapping that emphasizes land area accuracy.\n\n\n20\nKrovak\n5514\nFigure 20\nEPSG:5514\nProjection widely used in the Czech Republic and Slovakia.\nMapping datasets specific to these regions.\n\n\n21\nAsia North Lambert Conformal\n102026 (ESRI)\nFigure 21\nESRI:102026\nLambert Conformal projection for northern Asia.\nMapping datasets across northern Asia.\n\n\n22\nAustralia Albers\n3577\nFigure 22\nEPSG:3577\nEqual-area projection for Australia.\nRegional mapping of Australia with minimized area distortion.\n\n\n\nSetting up the basic code, libraries and getting world map data\n\n\nCode\nlibrary(tidyverse)          # Data wrangling\nlibrary(sf)                 # Simple Features in R\nlibrary(rnaturalearth)      # Map data\n\nworld &lt;- ne_countries(\n  scale = \"medium\",\n  returnclass = \"sf\"\n) |&gt; \n  select(name, name_long, \n         iso_a2, iso_a3, \n         geometry, continent)"
  },
  {
    "objectID": "geocomputation/crs_projections.html#details-on-different-projections-their-usage-examples-and-code",
    "href": "geocomputation/crs_projections.html#details-on-different-projections-their-usage-examples-and-code",
    "title": "Various CRS projections for use with {sf} plots in {ggplot2}",
    "section": "Details on different projections, their usage, examples and code",
    "text": "Details on different projections, their usage, examples and code\n\n1. WGS 84 (Geographic)\nThe WGS 84 projection, identified by EPSG:4326, is the default geographic coordinate system used for latitude and longitude. It is the most common system for raw geographic data and is widely used in GPS devices and mapping applications. This projection is excellent for datasets that involve global coverage but does not preserve area, shape, or distance due to its geographic nature.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(data = world) +\n  coord_sf(\n    crs = \"EPSG:4326\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"WGS 84 (Geographic) Projection\",\n    subtitle = \"EPSG:4326. Default geographic coordinate system using latitude and longitude.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_1.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 1: WGS 84 (Geographic) Projection\n\n\n\n\n\n\n2. Web Mercator\nThe Web Mercator projection, represented by EPSG:3857, is widely used by web mapping platforms like Google Maps and OpenStreetMap. It is a conformal projection, meaning it preserves angles but distorts area, especially near the poles. It is best suited for interactive maps or raster tiles for visualizing data at various zoom levels.\n\n\n\n\n\n\nNote\n\n\n\nAntarctica cannot be plotted with Web Mercator projection, as it become hugely elongated. Must remove Antarctica before plotting in Web Mercator.\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world |&gt; \n      filter(name != \"Antarctica\")\n  ) +\n  coord_sf(\n    crs = \"EPSG:3857\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Web Mercator Projection\",\n    subtitle = \"EPSG:3857. Best for interactive Maps; preserves angles.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_2.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 2: Web Mercator Projection\n\n\n\n\n\n\n3. UTM Zone 33N\nThe Universal Transverse Mercator (UTM) Zone 33N, identified by EPSG:32633, is a projection system designed for mapping specific regions with minimal distortion. UTM divides the world into 6° longitudinal zones, and Zone 33N is suited for areas within its coverage, typically in Europe. It is ideal for regional-scale analysis and detailed mapping.\n\n\n\n\n\n\nNote\n\n\n\nIn order to be able to use xlim = c(-20, 45), and ylim = c(33, 70) within the coord_sf(), to focus on Europe, we must use default_crs = sf::st_crs(4326). The deafult_crs argument tells the ggplot2 that the limits’ numbers are mentioned in which CRS system. And, the 4326 CRS is the default longitude-latitude CRS system.\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world |&gt; \n      filter(continent == \"Europe\")\n  ) +\n  coord_sf(\n    crs = \"EPSG:32633\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"UTM Zone 33N Projection: For Europe\",\n    subtitle = \"Minimal distortion for European Region.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_3_1.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\ng &lt;- world |&gt; \n  filter(continent == \"Europe\") |&gt; \n  filter(!(name %in% c(\"Russia\", \"Iceland\"))) |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(label = name),\n    check_overlap = TRUE,\n    size = 1.5\n  ) +\n  coord_sf(\n    crs = \"EPSG:32633\",\n    xlim = c(-20, 45),\n    ylim = c(33, 70),\n    default_crs = sf::st_crs(4326)\n  ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"UTM Zone 33N Projection: For Europe\",\n    subtitle = \"After removing Russia and setting xlim & ylim\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_3.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\n\nFigure 3: UTM Zone 33N Projection\n\n\n\n\n\n\n4. UTM Zone 33S\nThe UTM Zone 33S, associated with EPSG:32733, is similar to Zone 33N but designed for the southern hemisphere. It minimizes distortion within its zone and is widely used for detailed mapping in areas south of the equator within its longitudinal range. It is particularly useful for engineering and cadastral surveys. Area of use: Between 12°E and 18°E, southern hemisphere between 80°S and equator, onshore and offshore. Angola. Congo. Democratic Republic of the Congo (Zaire).\n\n\nCode\ng &lt;- world |&gt; \n  filter(name %in% c(\"Angola\", \"Congo\", \"Dem. Rep. Congo\",\n                     \"Namibia\")) |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(label = name),\n    check_overlap = TRUE,\n    size = 4\n  ) +\n  coord_sf(\n    crs = \"EPSG:32733\",\n    clip = \"off\"\n    ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"UTM Zone 33S Projection\",\n    subtitle = \"For Southern Hemisphere: Africa\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_4.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 4: UTM Zone 33S Projection\n\n\n\n\n\n\n5. NAD83\nThe North American Datum 1983 (NAD83), identified by EPSG:4269, is a standard reference system used across North America. It serves as the foundation for many regional and national mapping projects in the US and Canada. This projection ensures compatibility with datasets collected in the region.\n\n\nCode\ng &lt;- world |&gt; \n  filter(continent == \"North America\") |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(\n      label = name,\n      size = as.numeric(st_area(geometry))\n    ),\n    check_overlap = TRUE\n  ) +\n  scale_size(range = c(0.75, 3)) +\n  coord_sf(\n    crs = \"EPSG:4269\",\n    clip = \"on\",\n    xlim = c(-160, -40),\n    default_crs = st_crs(4326)\n    ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"North American Datum 1983 (NAD83) Projection\",\n    subtitle = \"For Canada and USA\"\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_5.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 5: NAD83 Projection\n\n\n\n\n\n\n6. ETRS89 / LAEA Europe\nThe ETRS89 Lambert Azimuthal Equal Area projection, represented by EPSG:3035, is optimized for mapping datasets across Europe. It preserves area relationships, making it suitable for thematic maps like population density or land use. This projection is commonly used in European Union projects and cross-country analyses.\n\n\nCode\ng &lt;- world |&gt; \n  filter(continent == \"Europe\") |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(label = name),\n    check_overlap = TRUE,\n    size = 1.5\n  ) +\n  coord_sf(\n    crs = \"EPSG:3035\",\n    xlim = c(-15, 45),\n    ylim = c(33, 70),\n    default_crs = sf::st_crs(4326)\n  ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"ETRS89 / LAEA Europe Projection\",\n    subtitle = \"European Union projects\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_6.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 6: ETRS89 / LAEA Europe Projection\n\n\n\n\n\n\n7. WGS 84 / Pseudo-Mercator\nThe WGS 84 / Pseudo-Mercator projection, also known as EPSG:3857, is closely related to the Web Mercator projection. It is designed for global-scale applications and is widely used for compatibility with web mapping platforms. This projection simplifies visualization but does not preserve distances or areas accurately.\n\n\n\n\n\n\nNote\n\n\n\nAntarctica cannot be plotted with Web Mercator projection, as it become hugely elongated. Must remove Antarctica before plotting in Web Mercator.\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(data = world |&gt; \n            filter(name != \"Antarctica\")) +\n  coord_sf(\n    crs = \"EPSG:3857\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"WGS 84 / Pseudo-Mercator Projection (EPSG:3857)\",\n    subtitle = \"Simplifies visualization but does not preserve distances or areas accurately.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_7.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 7: WGS 84 / Pseudo-Mercator Projection\n\n\n\n\n\n\n8. Albers Equal Area\nThe Albers Equal Area projection, identified by EPSG:5070, is particularly useful for mapping datasets across the United States. This projection preserves area relationships, making it suitable for applications like land-use planning or resource management. It is often used in environmental studies and thematic mapping.\n\n\nCode\ng &lt;- world |&gt; \n  # filter(name == \"United States of America\") |&gt; \n  ggplot() +\n  geom_sf(\n    fill = NA\n  ) +\n  geom_sf_text(\n    mapping = aes(label = name),\n    check_overlap = TRUE,\n    size = 1.5\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\",\n    # xlim = c(-15, 45),\n    # ylim = c(33, 70),\n    # default_crs = sf::st_crs(4326)\n  ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Albers Equal Area Projection\",\n    subtitle = \"For mainland USA\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_8.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\ng &lt;- world |&gt; \n  filter(name == \"United States of America\") |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(label = name),\n    check_overlap = TRUE,\n    size = 4\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\",\n    xlim = c(-125, -67),\n    ylim = c(25, 53),\n    default_crs = sf::st_crs(4326)\n  ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Albers Equal Area Projection\",\n    subtitle = \"Focussing on mainland USA\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_8_2.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\nAlbers Equal Area Projection\n\n\n\n\n\n\n\n\nFigure 8: Albers Equal Area Projection\n\n\n\n\n\n\n9. Lambert Conformal Conic (ESRI)\nThe Lambert Conformal Conic projection, represented by ESRI:102004, is a conformal projection widely used for mapping in North America. It minimizes distortion for regions with east-west orientation. This projection is often employed for regional-scale thematic mapping and analysis.\n\n\nCode\ng &lt;- world |&gt; \n  filter(continent == \"North America\") |&gt; \n  ggplot() +\n  geom_sf(\n    fill = NA\n  ) +\n  geom_sf_text(\n    mapping = aes(\n      label = name,\n      size = as.numeric(st_area(geometry))\n    ),\n    check_overlap = TRUE\n  ) +\n  scale_size(range = c(0.5, 3)) +\n  coord_sf(\n    crs = \"ESRI:102004\",\n    xlim = c(-160, -40),\n    ylim = c(5, 85),\n    default_crs = sf::st_crs(4326)\n  ) +\n  theme_minimal() +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Lambert Conformal Conic Projection\",\n    subtitle = \"For mapping North America. Minimizes East-West distortion\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title.position = \"plot\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_9.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 9: Lambert Conformal Conic Projection\n\n\n\n\n\n\n10. Mollweide (ESRI)\nThe Mollweide projection, identified by ESRI:54009, is an equal-area pseudo-cylindrical projection. It is ideal for global-scale thematic maps, such as climate or population density maps, where preserving area relationships is important. Its elliptical shape makes it visually distinct and effective for representing the entire world.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world\n  ) +\n  coord_sf(\n    crs = \"ESRI:54009\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Mollweide Projection (ESRI:54009)\",\n    subtitle = \"For world maps, preserving area-relationships\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_10.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 10: Mollweide Projection\n\n\n\n\n\n\n11. Robinson (ESRI)\nThe Robinson projection, represented by ESRI:54030, is a compromise projection designed to create visually appealing world maps. It strikes a balance between distortion of shape, area, and distance, making it suitable for general-purpose global mapping. It is widely used in atlases and educational materials.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world\n  ) +\n  coord_sf(\n    crs = \"ESRI:54030\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Robinson Projection (ESRI:54030)\",\n    subtitle = \"General purpose, visually appealing global maps.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_11.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 11: Robinson Projection\n\n\n\n\n\n\n12. Sinusoidal (ESRI)\nThe Sinusoidal projection, identified by ESRI:54008, is an equal-area projection that is widely used for global-scale analysis. It is particularly effective for thematic maps showing area distribution, such as land cover or climate zones. Its straightforward representation of meridians makes it easy to interpret.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world\n  ) +\n  coord_sf(\n    crs = \"ESRI:54008\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Sinusoidal Projection (ESRI:54008)\",\n    subtitle = \"An equal area projection, meridians are easier to interpret.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_12.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 12: Sinusoidal Projection\n\n\n\n\n\n\n13. Bonne (ESRI)\nThe Bonne projection, represented by ESRI:54024, is an equal-area projection often used for mapping continents. It minimizes area distortion while maintaining a pleasing, compact layout. It is suitable for thematic maps where regional relationships are critical.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world\n  ) +\n  coord_sf(\n    crs = \"ESRI:54024\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Bonne Projection (ESRI:54024)\",\n    subtitle = \"An equal area projection, with focus on regional relationships.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_13.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 13: Bonne Projection\n\n\n\n\n\n\n14. World Van der Grinten I (ESRI)\nThe World Van der Grinten I projection, identified by ESRI:54029, displays the entire world in a circular format. It offers an aesthetically pleasing view of global datasets, though it sacrifices accuracy in terms of area and shape. It is often used for decorative or general-purpose maps.\n\n\n\n\n\n\nNote\n\n\n\nThe World Van der Grinten I projection, being circular, significantly expands Antarctica. SO it is best not to plot Antarctica with a world map in this projection.\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world |&gt; \n      filter(name != \"Antarctica\")\n  ) +\n  coord_sf(\n    crs = \"ESRI:54029\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"World Van der Grinten Projection (ESRI:54029)\",\n    subtitle = \"An aesthetically pleasing, circular decorative World Map.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_14.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 14: World Van der Grinten I Projection\n\n\n\n\n\n\n15. Plate Carrée\nThe Plate Carrée projection, represented by EPSG:32662, is one of the simplest projections with equally spaced latitudes and longitudes. It is easy to work with but distorts area and shape significantly away from the equator. It is suitable for visualizing raw geographic data.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world\n  ) +\n  coord_sf(\n    crs = \"EPSG:32662\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Plate Carrée Projection (EPSG:32662)\",\n    subtitle = \"For working with Raw data. Has equally spaced latitudes and longitudes.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_15.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 15: Plate Carrée Projection\n\n\n\n\n\n\n16. Transverse Mercator\nThe Transverse Mercator projection, associated with EPSG:4326, is a cylindrical projection ideal for narrow regions. It minimizes distortion along the central meridian, making it widely used for mapping zones like UTM. It is often employed in engineering and cadastral surveys.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world\n  ) +\n  coord_sf(\n    crs = \"EPSG:4326\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Transverse Mercator Projection (EPSG:4326)\",\n    subtitle = \"Cylindrical Projection.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_16.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 16: Transverse Mercator Projection\n\n\n\n\n\n\n17. North Pole Stereographic\nThe North Pole Stereographic projection, identified by EPSG:3413, is designed for mapping the Arctic region. It minimizes distortion near the pole, making it suitable for polar datasets, including sea ice and Arctic biodiversity.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world,\n    fill = \"grey80\",\n    alpha = 0.3\n  ) +\n  coord_sf(\n    crs = \"EPSG:3413\",\n    ylim = c(50, 90),\n    xlim = c(-180, 180),\n    default_crs = st_crs(4326),\n    clip = \"on\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"North Pole Stereographic Projection (EPSG:3413)\",\n    subtitle = \"For mapping the Arctic Region.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_17.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 17: North Pole Stereographic Projection\n\n\n\n\n\n\n18. South Pole Stereographic\nThe South Pole Stereographic projection, represented by EPSG:3031, is specifically designed for mapping the Antarctic region. It preserves the geometric properties near the pole and is commonly used for research on Antarctic ice sheets and ecosystems.\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world |&gt; \n      filter(name == \"Antarctica\")\n  ) +\n  coord_sf(\n    crs = \"EPSG:3031\",\n    # ylim = c(-90, -60),\n    # xlim = c(-180, 180),\n    # default_crs = st_crs(4326)\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"South Pole Stereographic Projection (EPSG:3031)\",\n    subtitle = \"For mapping the Antarctic Region.\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_18.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 18: South Pole Stereographic Projection\n\n\n\n\n\n\n19. Interrupted Goode Homolosine (ESRI)\nThe Interrupted Goode Homolosine projection, identified by EPSG:54052, is a composite projection designed to minimize distortion of landmasses. It is particularly effective for global mapping that emphasizes land area accuracy and is often used in environmental studies.\n\n\n\n\n\n\nNote\n\n\n\nThis interrupted composite projection severely distorts and pulls apart Greenland and Antarctica, so avoid plotting them with this projection.\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = world |&gt; \n      filter(!(name %in% c(\"Greenland\", \"Antarctica\")))\n  ) +\n  coord_sf(\n    crs = \"ESRI:54052\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Interrupted Goode Homolosine Projection (ESRI:4326)\",\n    subtitle = \"Composite Projection. Minimzes distortion of landmasses\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_19.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 19: Interrupted Goode Homolosine Projection\n\n\n\n\n\n\n20. Krovak\nThe Krovak projection, associated with EPSG:5514, is widely used in the Czech Republic and Slovakia. It is tailored to their geographic extents, ensuring minimal distortion for regional applications. It is ideal for cadastral and engineering projects in these areas.\n\n\nCode\ng &lt;- world |&gt; \n  filter(name %in% c(\"Czechia\", \"Slovakia\")) |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf_text(\n    aes(label = name)\n  ) +\n  coord_sf(\n    crs = \"EPSG:5514\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Krovak Projection (EPSG:5514)\",\n    subtitle = \"Used for Czechia and Slovakia, for minimal distortion in those regions\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_20.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 20: Krovak Projection\n\n\n\n\n\n\n21. Asia North Lambert Conformal (ESRI)\nThe Asia North Lambert Conformal Conic projection, identified by ESRI:102026, is designed for northern Asia. It is suitable for mapping datasets across this vast region with minimal distortion. It is commonly used in regional studies and thematic mapping.\n\n\nCode\ng &lt;- world |&gt; \n  filter(continent == \"Asia\" | name == \"Russia\") |&gt; \n  ggplot() +\n  geom_sf() +\n  coord_sf(\n    crs = \"ESRI:102026\"\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Asia North Lambert Conformal Projection\",\n    subtitle = \"Used for plotting Northern Asia within minimal distortion\"\n  ) +\n  theme(\n    plot.title.position = \"plot\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_21.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 21: Asia North Lambert Conformal Projection\n\n\n\n\n\n\n22. Australia Albers\nThe Australia Albers projection, represented by EPSG:3577, is an equal-area projection optimized for Australia. It minimizes area distortion and is commonly used for environmental studies and resource management across the continent.\n\n\nCode\ng &lt;- world |&gt; \n  filter(name %in% c(\"Australia\")) |&gt; \n  ggplot() +\n  geom_sf() +\n  coord_sf(\n    crs = \"EPSG:3577\",\n    default_crs = st_crs(4326),\n    ylim = c(-43, -10)\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"Australia Albers Projection\",\n    subtitle = \"A projection optimized for Australia\"\n  ) +\n  theme(\n    plot.title.position = \"plot\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crs_projections_22.png\"),\n  height = 1200,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 22: Australia Albers Projection"
  },
  {
    "objectID": "book_solutions/chapter4.html",
    "href": "book_solutions/chapter4.html",
    "title": "Chapter 4: Spatial data operations",
    "section": "",
    "text": "library(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(magrittr)  # Using pipes with raster objects\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\n\n\nsysfonts::font_add_google(\"Saira Extra Condensed\", \"caption_font\")\nsysfonts::font_add_google(\"Saira\", \"body_font\")\ntheme_set(theme_minimal(base_family = \"body_font\",\n                        base_size = 16))\nshowtext::showtext_auto()"
  },
  {
    "objectID": "book_solutions/chapter4.html#introduction-to-spatial-operations",
    "href": "book_solutions/chapter4.html#introduction-to-spatial-operations",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.1 Introduction to Spatial Operations",
    "text": "4.1 Introduction to Spatial Operations\n\nSpatial Operations: Include spatial joins for vectors and local/focal operations for rasters, allowing modification based on location and shape.\n\nRelation to Non-Spatial Operations: Many spatial operations (e.g., subsetting, joining) have non-spatial counterparts.\n\nSpatial Joins: Can be done in multiple ways (e.g., intersect, within distance), unlike non-spatial joins (refer to fuzzyjoin package (Robinson 2020) for alternatives).\n\nTypes of Spatial Relationships: Includes operations like intersects and disjoint. Distance calculations explore spatial relationships.\n\nRaster Operations:\n\nSubsetting (Section 4.3.1)\nMap Algebra: Modifies raster cell values through local, focal, zonal, and global operations (Sections 4.3.3 to 4.3.6).\nMerging Rasters: Demonstrated with reproducible examples (Section 4.3.8).\n\nCoordinate Reference System (CRS): Consistency in CRS is essential for spatial operations.."
  },
  {
    "objectID": "book_solutions/chapter4.html#spatial-operations-on-vector-data",
    "href": "book_solutions/chapter4.html#spatial-operations-on-vector-data",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.2 Spatial operations on vector data",
    "text": "4.2 Spatial operations on vector data\n\n4.2.1 Spatial Subsetting: use st_filter()\n\nSpatial subsetting extracts features from a spatial object (x) that relate spatially to another object (y).\nSyntax: Use the [ ] operator: x[y, , op = st_intersects].\n\nx: Target sf object.\ny: Subsetting sf object.\nop: Topological relation (default is st_intersects).\nsf package documentation\n\nDefault Operator: st_intersects() selects features intersecting with the subsetting object. Alternative operators like st_disjoint() can be used for different relations.\n\nExample: nz_height[canterbury, ] returns high points within Canterbury from the nz_height dataset in the spData package (spData documentation).\n\nTopological Relations: Include touches, crosses, and within. These determine spatial relationships between features in x and y.\nSparse Geometry Binary Predicate (sgbp):\n\nUsing st_intersects(), an sgbp list object is created.\nConvert sgbp to logical vector for subsetting using lengths({sgbp_object_name} &gt; 0)\nUsing sparse = FALSE argument in st_intersects() returns a dense matrix.\n\nTidyverse Alternative: st_filter() from the sf package simplifies spatial subsetting, increasing compatibility with dplyr.\nOutput Consistency: Subsets created using [ ], logical vectors, or st_filter() are equivalent in spatial operations.\n\n\n\nCode\ndata(\"nz\")\ndata(\"nz_height\")\n\nclass(nz)\n## [1] \"sf\"         \"data.frame\"\n\n# A plot for all regions and all peaks\nnz |&gt; \n  ggplot() +\n  geom_sf(fill = \"white\") +\n  ggrepel::geom_text_repel(\n    mapping = aes(\n      label = Name,\n      geometry = geom\n    ),\n    size = 4,\n    family = \"caption_font\",\n    stat = \"sf_coordinates\"\n  ) +\n  geom_sf(\n    data = nz_height,\n    pch = 2,\n    colour = \"red\",\n    size = 3\n  ) +\n  scale_fill_manual(\n    values = c(\"white\", \"pink\")\n  ) +\n  labs(\n    title = \"All peaks in New Zealand, and all regions.\"\n  ) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(\n      fill = \"lightblue\",\n      colour = NA\n    ),\n    legend.position = \"none\"\n  )\n\n# Total peaks in New Zealand\nnz_height |&gt; dim()\n## [1] 101   3\n\n# Peaks within Canterbury in New Zealand\n\n# Base R Version\ncanterbury &lt;- nz |&gt; filter(Name == \"Canterbury\")\nnz_height[canterbury,] |&gt; dim()\n## [1] 70  3\n\n# Tidyverse Version\nnz_height |&gt;\n  st_filter(\n    nz |&gt; filter(Name == \"Canterbury\"),\n    .predicate = st_intersects\n  ) |&gt; \n  dim()\n## [1] 70  3\n\n# Getting the peaks which are inside Canterbury\ncanterbury_ids &lt;- nz_height |&gt;\n  st_filter(\n    nz |&gt; filter(Name == \"Canterbury\"),\n    .predicate = st_intersects\n  ) |&gt; \n  pull(t50_fid)\n\nnz_height |&gt; \n  mutate(in_canterbury = t50_fid %in% canterbury_ids) |&gt; \n  ggplot() +\n  \n  # Base NZ Map and Label for Canterbury\n  geom_sf(\n    data = nz,\n    mapping = aes(\n      fill = Name == \"Canterbury\"\n    )\n  ) +\n  geom_sf_text(\n    data = filter(nz, Name == \"Canterbury\"),\n    mapping = aes(\n      label = Name,\n      geometry = geom\n    ),\n    size = 4,\n    family = \"caption_font\"\n  ) +\n  \n  # Plotting the peaks, and colouring by presence in Canterbury\n  geom_sf(\n    mapping = aes(\n      colour = in_canterbury,\n      size = in_canterbury\n    ),\n    pch = 2\n  ) +\n  \n  scale_fill_manual(\n    values = c(\"white\", \"lightpink\")\n  ) +\n  scale_colour_manual(\n    values = c(\"black\", \"red\")\n  ) +\n  guides(\n    fill = \"none\"\n  ) +\n  labs(\n    colour = \"Peaks within Canterbury Region?\",\n    size = \"Peaks within Canterbury Region?\",\n    title = \"Highlighting Peaks within Canterbury region\"\n  ) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(\n      fill = \"lightblue\"\n    ),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n(a) New Zealand Map with all the peaks\n\n\n\n\n\n\n\n\n\n\n\n(b) New Zealand Map focussing on peaks that intersect with Canterbury\n\n\n\n\n\n\nFigure 1: Spatial Subsetting and plotting with tidyverse and ggplot2 methods\n\n\n\n\nExample code for st_intersects() and st_disjoint() : these functions produce a sparse predicate list only. Hence, correct way to use them would be st_filter() with .predicate = &lt;function&gt; argument.\n\nnz_height |&gt; \n  st_intersects(\n    filter(nz, Name == \"Canterbury\")\n  )\n\nSparse geometry binary predicate list of length 101, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: 1\n 6: 1\n 7: 1\n 8: 1\n 9: 1\n 10: 1\n\n# The 70 peaks within Canterbury region\nnz_height |&gt; \n  st_filter(\n    filter(nz, Name == \"Canterbury\"),\n    .predicate = st_intersects\n  )\n\nSimple feature collection with 70 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1365809 ymin: 5158491 xmax: 1654899 ymax: 5350463\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 10 features:\n   t50_fid elevation                geometry\n1  2362630      2749 POINT (1378170 5158491)\n2  2362814      2822 POINT (1389460 5168749)\n3  2362817      2778 POINT (1390166 5169466)\n4  2363991      3004 POINT (1372357 5172729)\n5  2363993      3114 POINT (1372062 5173236)\n6  2363994      2882 POINT (1372810 5173419)\n7  2363995      2796 POINT (1372579 5173989)\n8  2363997      3070 POINT (1373796 5174144)\n9  2363998      3061 POINT (1373955 5174231)\n10 2363999      3077 POINT (1373984 5175228)\n\n# The 31 peaks outside Canterbury Region\nnz_height |&gt; \n  st_filter(\n    filter(nz, Name == \"Canterbury\"),\n    .predicate = st_disjoint\n  )\n\nSimple feature collection with 31 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1204143 ymin: 5048309 xmax: 1822492 ymax: 5650492\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 10 features:\n   t50_fid elevation                geometry\n1  2353944      2723 POINT (1204143 5049971)\n2  2354404      2820 POINT (1234725 5048309)\n3  2354405      2830 POINT (1235915 5048745)\n4  2369113      3033 POINT (1259702 5076570)\n5  2363996      2759 POINT (1373264 5175442)\n6  2364028      2756 POINT (1374183 5177165)\n7  2364029      2800 POINT (1374469 5176966)\n8  2364031      2788 POINT (1375422 5177253)\n9  2364166      2782 POINT (1383006 5181085)\n10 2364167      2905 POINT (1383486 5181270)\n\n\n\n\n4.2.2 Topological Relations\n\nTopological relations describe spatial relationships between objects using logical TRUE or FALSE statements (Egenhofer and Herring, 1990).\nSymmetrical vs. non-symmetrical relations:\n\nSymmetrical relations (e.g., equals, intersects, crosses) yield the same result when order of input is swapped.\nNon-symmetrical relations (e.g., contains, within) depend on the order of input geometries.\n\nBinary predicates in sf package test spatial relationships between vector geometries. See vignette(“sf3”). The following binary predicates exist in sf : —\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nSymmetrical?\n\n\n\n\nst_intersects\nChecks if geometries intersect.\nYes\n\n\nst_disjoint\nChecks if geometries do not intersect (are disjoint).\nYes\n\n\nst_touches\nChecks if geometries have at least one boundary point in common.\nYes\n\n\nst_crosses\nChecks if a geometry crosses another (e.g., a line crosses a polygon).\nYes\n\n\nst_overlaps\nChecks if geometries have some but not all interior points in common.\nYes\n\n\nst_equals\nChecks if geometries are topologically equal.\nYes\n\n\nst_within\nChecks if a geometry is completely contained within another.\nNo\n\n\nst_contains\nChecks if a geometry contains another completely.\nNo\n\n\nst_contains_properly\nChecks if a geometry contains another but not vice versa.\nNo\n\n\nst_covers\nChecks if a geometry covers another (includes boundary).\nNo\n\n\nst_covered_by\nChecks if a geometry is covered by another (includes boundary).\nNo\n\n\nst_equals_exact\nChecks if geometries are exactly equal within a given tolerance.\nYes\n\n\nst_is_within_distance\nChecks if geometries are within a specified distance from each other.\nYes\n\n\n\n\nSparse matrix output: Functions like st_intersects() use sparse matrices to save memory by only registering positive results; setting sparse = FALSE returns a dense matrix.\n\n\n\nCode\n# Create two polygons\n polygon1 &lt;- st_polygon(\n   list(matrix(c(0, 0, 1, 0, 1, 1, 0, 1, 0, 0),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n\n polygon2 &lt;- st_polygon(\n   list(matrix(c(0.5, 0.5, 1.5, 0.5, 1.5, 1.5, 0.5, 1.5, 0.5, 0.5),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n\n polygon3 &lt;- st_polygon(\n   list(matrix(c(0.2, 1.2,\n                 0.5, 1.2, \n                 0.5, 1.5, \n                 0.2, 1.5, \n                 0.2, 1.2),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n\n polygon4 &lt;- st_polygon(\n   list(matrix(c(1.2, 0.2, \n                 1.5, 0.2, \n                 1.5, 0.4, \n                 1.2, 0.4, \n                 1.2, 0.2),\n     ncol = 2,\n     byrow = TRUE\n   ))\n )\n \n # Convert to sf objects\n sf_poly1 &lt;- st_sfc(polygon1, crs = 4326)\n sf_poly2 &lt;- st_sfc(polygon2, crs = 4326)\n sf_poly3 &lt;- st_sfc(polygon3, crs = 4326)\n sf_poly4 &lt;- st_sfc(polygon4, crs = 4326)\n \n # Create a collection of points\n points &lt;- st_sfc(\n   st_point(c(0.25, 0.25)),\n   st_point(c(0.75, 0.75)),\n   st_point(c(1.25, 1.25)),\n   crs = 4326\n )\n\n sf_points &lt;- tibble(\n   point = c(\"p1\", \"p2\", \"p3\"),\n   geometry = points\n ) |&gt;\n   st_as_sf() |&gt;\n   st_set_crs(4326)\n\n# Keeping environment clean\nrm(polygon1, polygon2, \n   polygon3, polygon4,\n   points)\n\n# Visualize the objects\nggplot() +\n  geom_sf(data = sf_poly1, \n          aes(fill = \"sf_poly1\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_poly2, \n          aes(fill = \"sf_poly2\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_poly3, \n          aes(fill = \"sf_poly3\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_poly4, \n          aes(fill = \"sf_poly4\"),\n          alpha = 0.5) +\n  geom_sf(data = sf_points,\n          aes(fill = point),\n          pch = 21,\n          size = 4) +\n  labs(fill = NULL) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nFigure 2: Some example objects to demonstrate the topological relations\n\n\n\n\n\n\n#################### Symmetrical Relations ######################\n# The order in which sf objects are placed does not matter\n\n## st_intersects()----------------------------------------\nst_intersects(sf_poly1, sf_poly2, sparse = F) \n##      [,1]\n## [1,] TRUE\n\nst_intersects(sf_poly1, sf_points, sparse = F) \n##      [,1] [,2]  [,3]\n## [1,] TRUE TRUE FALSE\n\nst_intersects(sf_poly1, sf_poly3, sparse = F)\n##       [,1]\n## [1,] FALSE\n\nst_intersects(sf_poly2 ,sf_poly3, sparse = F) \n##      [,1]\n## [1,] TRUE\n\n\n# st_disjoint()------------------------------------------\nst_disjoint(sf_poly1, sf_poly4, sparse = F)\n##      [,1]\n## [1,] TRUE\n\nst_disjoint(sf_poly2, sf_poly3, sparse = F) \n##       [,1]\n## [1,] FALSE\n\n\n# st_touches()-------------------------------------------\nst_touches(sf_poly1, sf_poly2, sparse = F) \n##       [,1]\n## [1,] FALSE\n\nst_touches(sf_poly2, sf_poly3, sparse = F)\n##      [,1]\n## [1,] TRUE\n\nst_touches(sf_poly1, sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n\n\n# st_crosses()-------------------------------------------\nst_crosses(sf_poly1, sf_poly2, sparse = F)\n##       [,1]\n## [1,] FALSE\n\nst_crosses(sf_poly1, sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n\n# st_overlaps()\nst_overlaps(sf_poly1, sf_poly2, sparse = F)\n##      [,1]\n## [1,] TRUE\nst_overlaps(sf_poly1, sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\nst_overlaps(sf_poly3, sf_poly3, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n# st_equals()-------------------------------------------\nst_equals(sf_poly1, sf_poly1, sparse = F)\n##      [,1]\n## [1,] TRUE\n\n\n\n# st_equals_exact()-------------------------------------\nst_equals_exact(sf_poly1, sf_poly2, par = 0.1, sparse = F)\n##       [,1]\n## [1,] FALSE\nst_equals_exact(sf_poly1, sf_poly2, par = 1, sparse = F)\n##      [,1]\n## [1,] TRUE\n\n\n# st_is_within_distance()-------------------------------\nst_is_within_distance(sf_poly1, sf_poly2, dist = 0.1, sparse = F)\n##      [,1]\n## [1,] TRUE\nst_is_within_distance(sf_poly2, sf_poly3, dist = 0.1, sparse = F)\n##      [,1]\n## [1,] TRUE\nst_is_within_distance(sf_poly3, sf_poly4, dist = 0.1, sparse = F)\n##       [,1]\n## [1,] FALSE\nst_is_within_distance(sf_poly3, sf_poly4, dist = 13, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n#################### Non-Symmetrical Relations ####################\n# The order in which sf objects are placed changes the outcome\n\n# st_within()-------------------------------------------\nsf_points |&gt; \n  st_within(sf_poly1, sparse = F)\n##       [,1]\n## [1,]  TRUE\n## [2,]  TRUE\n## [3,] FALSE\n\nsf_poly1 |&gt; \n  st_within(sf_points, sparse = F)\n##       [,1]  [,2]  [,3]\n## [1,] FALSE FALSE FALSE\n\nsf_poly1 |&gt; \n  st_within(sf_poly2, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n# st_contains()-----------------------------------------\nsf_poly1 |&gt; \n  st_contains(sf_points, sparse = F)\n##      [,1] [,2]  [,3]\n## [1,] TRUE TRUE FALSE\n\nsf_points |&gt; \n  st_contains(sf_poly1, sparse = F)\n##       [,1]\n## [1,] FALSE\n## [2,] FALSE\n## [3,] FALSE\n\n\n# st_covers()-------------------------------------------\nsf_poly1 |&gt; \n  st_covers(sf_points, sparse = F)\n##      [,1] [,2]  [,3]\n## [1,] TRUE TRUE FALSE\n\nsf_poly2 |&gt; \n  st_covers(sf_poly1, sparse = F)\n##       [,1]\n## [1,] FALSE\n\n\n# st_covered_by()---------------------------------------\nsf_points |&gt; \n  st_covered_by(sf_poly1, sparse = F)\n##       [,1]\n## [1,]  TRUE\n## [2,]  TRUE\n## [3,] FALSE\n\n\n\n4.2.3 Distance Relations\n\nDistance relations are continuous, unlike binary topological relations which return TRUE/FALSE values.\nThe st_distance() function calculates distances between two sf objects, returning a matrix with units of measurement (e.g., meters).\nst_centroid(): Computes the geometric centroid of a spatial feature, useful for representing a region’s central point in distance calculations.\nMatrix output:\n\nResults are returned as a matrix, even for single value calculations.\nComputes a distance matrix between all combinations of features in objects (e.g., distances between multiple points and polygons).\n\nPoint-to-polygon distance: Represents the shortest distance from a point to any part of the polygon.\nUsage in distance-based joins: st_distance() is also used for performing joins based on distance criteria.\nAn example code to find distance between central points of Auckland and Canterbury Regions, vs. Top three peaks in New Zealand, returned as a matrix,a nd shown below as a beautiful table using {gt}.\n\n\n# Central points of Auckland and Canterbury Regions\ndf1 &lt;- nz |&gt; \n  filter(str_detect(Name, \"Auck|Canter\")) |&gt; \n  st_centroid() |&gt; \n  select(Name, geom)\n\n# Top 3 highest peaks in New Zealand\ndf2 &lt;- nz_height |&gt; \n  slice_max(order_by = elevation, n = 3)\n\n# Finding the distance matrix\nst_distance(df1, df2) |&gt; \n  as_tibble() |&gt; \n  mutate(state = c(\"Auckland\", \"Canterbury\")) |&gt; \n  relocate(state) |&gt; \n  mutate(\n    across(\n      .cols = -state,\n      .fns = as.numeric\n    )\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    decimals = 1,\n    scale_by = 1e-3\n  ) |&gt; \n  gt::cols_label(V1 = \"Highest Peak\", \n                 V2 = \"Second\",\n                 V3 = \"Third\",\n                 state = \"Centroid of the State\") |&gt; \n  gt::tab_header(\n    title = \"Distance in kilometers\"\n  ) |&gt; \n  gtExtras::gt_theme_538()\n\n\n\nTable 1: Code output for use of st_centroid() and st_distance()\n\n\n\n\n\n\n\n\n\nDistance in kilometers\n\n\nCentroid of the State\nHighest Peak\nSecond\nThird\n\n\n\n\nAuckland\n856.6\n857.3\n856.9\n\n\nCanterbury\n115.5\n115.4\n115.5\n\n\n\n\n\n\n\n\n\n\n\n\n4.2.4 DE-9IM Strings\n\nThe Dimensionally Extended 9-Intersection Model (DE-9IM) underlies binary spatial predicates. This model forms the basis for many spatial operations and helps create custom spatial predicates.\nOrigins:\n\nInitially named “DE + 9IM,” it refers to the dimensions of intersections between the boundaries, interiors, and exteriors of two geometries (Clementini and Di Felice 1995).\nIt applies to two-dimensional geometries (points, lines, polygons) in Euclidean space, requiring data in a projected coordinate reference system (CRS).\n\nHow DE-9IM Works:\n\nThe model visualizes intersections between components of two geometries (interior, boundary, exterior) in a 3x3 matrix form, indicating the dimension of the intersection (0 for points, 1 for lines, 2 for polygons, and F for false).\nFlattening this matrix row-wise results in the DE-9IM string: “212111212”.\n\nUsing st_relate(): The st_relate() function returns DE-9IM strings to describe spatial relations.\nDeveloping Custom Predicates:\n\nBy interpreting DE-9IM strings, custom binary spatial predicates like queen and rook relations can be created:\n\nQueen relations (shared border or point): Pattern F***T****.\nRook relations (shared linear intersection): Pattern F***1****.\n\nCustom functions using st_relate():\n\n\nst_queen = function(x, y) \n  st_relate(x, y, pattern = \"F***T****\")\n\nst_rook = function(x, y) \n  st_relate(x, y, pattern = \"F***1****\")\n\nThis identifies which geometries in a grid have queen or rook relations to the central geometry.\n\n\n\n4.2.5 Spatial Joining with st_join()\n\nSpatial joins combine datasets based on spatial relationships instead of shared key variables (as in non-spatial joins). It adds columns from a source object (y) to a target object (x).\nJoin Details:\n\nDefault behavior: A left join, which retains all rows from x and includes rows with no match from y.\nOperators: Uses st_intersects() by default but can be modified via the join argument.\nHandles all geometry types: Works for points, lines, and polygons, though joins involving polygons may create duplicate rows for multiple matches in y.\n\nFlexibility:\n\nInner joins: Set left = FALSE to include only matched rows.\n\nThe st_join() function: The join argument defines the topological operator to determine these relationships, with the default being st_intersects().\n\nWe can customize this behavior by choosing alternative functions such as st_contains, st_within, st_overlaps, st_touches, or st_disjoint, among others, each defining a different geometric predicate.\nFor example, st_contains selects features where geometries of x fully encompass those of y, while st_within does the reverse.\nAdditionally, advanced options like st_is_within_distance allow proximity-based joins, and st_relate supports customized spatial relationships using a pattern.\n\nExample: Getting 25 random points in the world, and seeing in which countries they fall in Figure 3.\n\n\n\nCode\n# Getting 25 random points on the world,a dn then seeing in which countries they fall\nrandom_points &lt;- tibble(\n  x = round(\n    runif(\n    25, \n    min = st_bbox(world)$xmin, \n    max = st_bbox(world)$xmax\n    ),\n    2\n  ),\n  y = round(\n    runif(\n    25, \n    min = st_bbox(world)$ymin, \n    max = st_bbox(world)$ymax\n    ),\n    2\n  ),\n  id = LETTERS[1:25]\n) |&gt; \n  st_as_sf(coords = c(\"x\", \"y\")) |&gt; \n  st_set_crs(value = crs(world))\n\n\n# Easiest (but not tidyverse) way to subset\n# world[random_points, ]\n\n# Tidyverse way to filter: Names of Countries in which they fall\nintersecting_countries &lt;- world |&gt; \n  st_filter(random_points) |&gt; \n  pull(name_long)\n\n# The power of spatial joins: A tibble of countries where each random\n# point falls. st_join() by default performs a left_join()\nst_join(\n  random_points, \n  world |&gt; select(name_long)\n) |&gt; \n  drop_na() |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_nytimes()\n\n\n\n\n\n\n\n\nid\ngeometry\nname_long\n\n\n\n\nI\nc(43.05, 61.96)\nRussian Federation\n\n\nN\nc(112.59, 71.68)\nRussian Federation\n\n\nO\nc(59.22, 33.55)\nIran\n\n\nP\nc(93.88, 52.24)\nRussian Federation\n\n\nR\nc(62.63, 51.25)\nKazakhstan\n\n\nS\nc(-17.61, -88.84)\nAntarctica\n\n\n\n\n\n\n\n\n\nCode\nset.seed(42)\n\nworld |&gt; \n  mutate(highlight = name_long %in% intersecting_countries) |&gt; \n  ggplot() +\n  geom_sf(\n    mapping = aes(\n      fill = highlight\n    ),\n    alpha = 0.5\n  ) +\n  scale_fill_manual(\n    values = c(\"transparent\", \"red\")\n  ) +\n  geom_sf(\n    data = random_points,\n    pch = 20,\n    size = 4,\n    colour = \"black\",\n    alpha = 0.5\n  ) +\n  ggrepel::geom_text_repel(\n    data = random_points,\n    mapping = aes(label = id, geometry = geometry),\n    size = 4,\n    colour = \"black\",\n    nudge_x = 2,\n    nudge_y = -2,\n    stat = \"sf_coordinates\"\n  ) +\n  labs(\n    title = \"25 random points on world map, and Countries in which they fall\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\nFigure 3: Using st_join() to spatially join two data sets, based on the st_intersect() relation\n\n\n\n\n\n\n\n4.2.6 Distance-based Joins\n\nDistance-based joins are used when geographic datasets are spatially proximate but do not intersect. The sf package enables such joins using spatial relationships like proximity.\nExample Dataset used:\n\ncycle_hire: Official cycle hire points.\ncycle_hire_osm: Cycle hire points from OpenStreetMap.\nRelationship: These datasets are geographically close but do not overlap, as verified using st_intersects(), which returns FALSE for all points.\n\nImplementation:\n\nCheck Proximity:\n\nUse st_is_within_distance() to determine points within a threshold distance (e.g., 20 meters).\n\nPerform Distance-based Join:\n\nApply st_join() with the st_is_within_distance predicate and a dist argument.\nThe resulting dataset may contain duplicate rows if points in the target object (cycle_hire) match multiple points in the source (cycle_hire_osm).\n\n\nKey Observations:\n\nJoins retain the geometry of features in the target dataset (cycle_hire).\nDistance-based joins are effective for linking datasets that are close geographically but do not overlap.\n\n\nFigure 4 visualizes the spatial relationship between two datasets, cycle_hire and cycle_hire_osm, using a proximity filter. The st_filter() function from the sf package identifies points in the cycle_hire dataset that are within 10 meters of points in cycle_hire_osm, leveraging the st_is_within_distance predicate. The result is a subset of cycle_hire points, which are plotted using ggplot2. The plot includes:\n\nFiltered cycle_hire points (dark blue, fully opaque).\nAll cycle_hire points (dark blue, semi-transparent) for context.\nAll cycle_hire_osm points (red, semi-transparent) to show the proximity relationship.\n\n\n\nCode\ndata(\"cycle_hire\")\ndata(\"cycle_hire_osm\")\n\nggplot() +\n  geom_sf(\n    data = cycle_hire,\n    colour = \"blue\",\n    alpha = 0.5\n  ) +\n  geom_sf(\n    data = cycle_hire_osm,\n    colour = \"red\",\n    alpha = 0.5\n  )\n\n\n\n\n\n\n\n\n\nCode\n# Official Cycle hire points with added info from OSM points within 10 metres\n# \n# cycle_hire |&gt; \n#   st_join(\n#     cycle_hire_osm, \n#     join = st_is_within_distance,\n#     dist = units::set_units(10, \"m\")\n#   )\n\n\nJust checking, whether any of the two points in these two data sets exactly match. Well, they don’t!\n\nst_intersects(cycle_hire, cycle_hire_osm, sparse = F) |&gt; any()\n\n[1] FALSE\n\n\nNow, in Figure 4, we highlight only those points of bike hire in the official data, which are within 10 metres of the OSM data. The important function here is st_filter() along with the argument .predicate = st_is_within_distance() and the argument dist = ... .\n\n\nCode\n# Plot only points which have a OSM point within 10 metres\ncycle_hire |&gt; \n  st_filter(\n    cycle_hire_osm,\n    .predicate = st_is_within_distance,\n    dist = units::set_units(10, \"m\")\n  ) |&gt; \n  ggplot() +\n  geom_sf(size = 3, alpha = 0.75, colour = \"darkblue\") +\n  geom_sf(\n    data = cycle_hire, \n    alpha = 0.2, \n    colour = \"blue\",\n    size = 1\n  ) +\n  geom_sf(\n    data = cycle_hire_osm, \n    alpha = 0.2, \n    colour = \"red\",\n    size = 1\n  )\n\n\n\n\n\n\n\n\nFigure 4: Official Cycle Hire Points Within 10 Meters of OpenStreetMap Locations\n\n\n\n\n\n\n\n4.2.7 Spatial Aggregation\n\nSpatial data aggregation condenses data into fewer rows by summarizing multiple values of a variable into a single value per grouping variable, similar to attribute data aggregation. Following two approaches exist: —\n\nBase R’s aggregate(): Groups values based on spatial relationships and summarizes them with a specified function (e.g., mean).\nTidyverse Approach (group_by() and summarize()): Combines st_join() with grouping and summarizing to perform spatial aggregation while allowing flexibility in function application and column naming. (This approach is better, as shown in Figure 5)\n\nOutput Differences:\n\naggregate() may result in NA for unmatched regions.\nTidyverse methods preserve unmatched region names and allow for more flexible aggregation functions and output formatting.\n\nFunctions like median(), sd(), or other statistical summarizers can replace mean() for different aggregation purposes.\n\n\ndata(\"nz_height\")\ndata(\"nz\")\n\nst_join(x = nz, y = nz_height) |&gt; \n  group_by(Name) |&gt; \n  summarise(elevation = mean(elevation, na.rm = T)) |&gt; \n  ggplot(\n    mapping = aes(fill = elevation)\n  ) +\n  geom_sf() +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Terrain 2\",\n    na.value = \"white\"\n  )\n\n\n\n\n\n\n\nFigure 5: Spatial data aggregation with st_join() from {sf} and summarise() from {tidyverse}\n\n\n\n\n\n\n\n4.2.8 Joining In-congruent Layers\n\nSpatial congruence occurs when two layers (aggregating object y and target object x) share borders, enabling accurate spatial aggregation. Incongruence arises when no shared borders exist, complicating spatial operations.\nExample of Congruence:\n\nAdministrative boundaries, such as districts made of smaller units, typically exhibit spatial congruence.\n\nIssue with Incongruence:\n\nIn-congruent layers, like sub-zones with differing borders from aggregating zones, result in inaccurate aggregations (e.g., centroids of sub-zones).\n\nSolution: Areal Interpolation: Transfers values between areal units using:\n\nSimple area-weighted methods: Proportionally assigns values based on area overlap. This is implemented using st_interpolate_aw().\nAdvanced methods: Include algorithms like ‘pycnophylactic’ interpolation.\n\nExample Dataset:\n\nThe spData package includes incongruent (sub-zones) and aggregating_zones (larger zones). The value column in incongruent represents total regional income in million Euros, which must be aggregated into aggregating_zones.\n\nImplementation: st_interpolate_aw():\n\nThe st_interpolate_aw() function in the sf package performs areal-weighted interpolation of polygon data, allowing attributes from one spatial object (x) to be transferred to another (to) based on area overlap. The extensive argument determines whether attributes are spatially extensive (e.g., population, summed across areas) or spatially intensive (e.g., density, averaged). Additional options include keep_NA (to retain or exclude NA features) and na.rm (to remove features with NA attributes from x).\nAggregated results depend on the variable type:\n\nExtensive variables: Values increase with area (e.g., total income).\nIntensive variables: Values remain constant irrespective of area (e.g., averages).\n\nst_interpolate_aw() handles spatially extensive variables (e.g., total income) by summing values across areas.\nIn st_interpolate_aw(), for spatially intensive variables (e.g., averages, percentages), set extensive = FALSE to use averages instead of sums.\nNote: Warning messages indicate the assumption of uniform attribute distribution across areas.\n\n\n\ndata(\"aggregating_zones\")\ndata(\"incongruent\")\n\n# The two overall main zones for which the total income needs to be computed\naggregating_zones\n\nSimple feature collection with 2 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417686.2 ymin: 443703.6 xmax: 422959.3 ymax: 447036.8\nProjected CRS: OSGB 1936 / British National Grid\n      geo_code geo_label geo_labelw                       geometry\n5164 E02002332 Leeds 003       &lt;NA&gt; MULTIPOLYGON (((418731.9 44...\n6631 E02002333 Leeds 004       &lt;NA&gt; MULTIPOLYGON (((419196.4 44...\n\n# The 9 smaller counties or districts or sub-units which are not\n# congruent with the main zones\nincongruent\n\nSimple feature collection with 9 features and 2 fields\nAttribute-geometry relationships: aggregate (1), NA's (1)\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417686.8 ymin: 443703 xmax: 422963 ymax: 446978\nProjected CRS: OSGB 1936 / British National Grid\n        level    value                       geometry\n1 Incongruent 4.037919 MULTIPOLYGON (((420799.6 44...\n2 Incongruent 5.014419 MULTIPOLYGON (((418664 4464...\n3 Incongruent 4.933000 MULTIPOLYGON (((419964 4462...\n4 Incongruent 5.120139 MULTIPOLYGON (((420368 4441...\n5 Incongruent 6.548912 MULTIPOLYGON (((420419.8 44...\n6 Incongruent 3.749791 MULTIPOLYGON (((421779 4451...\n7 Incongruent 5.432837 MULTIPOLYGON (((419577 4464...\n8 Incongruent 4.618049 MULTIPOLYGON (((417687.6 44...\n9 Incongruent 5.956771 MULTIPOLYGON (((418859.3 44...\n\n# We are using extensive = TRUE, because our variable is \n# total income, not average income\nincongruent |&gt; \n  # We need to keep only the numeric variable (and of course,\n  # the sticky geometry. Otherwise, R will not understand what\n  # to do with non-numeric columns)\n  select(value) |&gt; \n  st_interpolate_aw(aggregating_zones, extensive = TRUE)\n\nWarning in st_interpolate_aw.sf(select(incongruent, value), aggregating_zones,\n: st_interpolate_aw assumes attributes are constant or uniform over areas of x\n\n\nSimple feature collection with 2 features and 1 field\nAttribute-geometry relationship: aggregate (1)\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417686.2 ymin: 443703.6 xmax: 422959.3 ymax: 447036.8\nProjected CRS: OSGB 1936 / British National Grid\n     value                       geometry\n1 19.61613 MULTIPOLYGON (((418731.9 44...\n2 25.66872 MULTIPOLYGON (((419196.4 44..."
  },
  {
    "objectID": "book_solutions/chapter4.html#spatial-operations-on-raster-data",
    "href": "book_solutions/chapter4.html#spatial-operations-on-raster-data",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.3 Spatial operations on raster data",
    "text": "4.3 Spatial operations on raster data\n\nDemonstrates advanced spatial raster operations.\nProvides an alternative to manually creating datasets by accessing them from the spData package:\n\nelev: Represents elevation data.\ngrain: Represents grain-related data.\n\n\nelev &lt;- rast(system.file(\"raster/elev.tif\", \n                        package = \"spData\"))\n\ngrain &lt;- rast(system.file(\"raster/grain.tif\", \n                         package = \"spData\"))\n\n# plot(elev)\n# plot(grain)\n\nggplot() +\n  geom_spatraster(data = elev) +\n  labs(title = \"elev SpatRaster\", caption = \"data: {spData}\") +\n  scale_fill_grass_c()\n  \n\nggplot() +\n  geom_spatraster(data = grain) +\n  scale_fill_grass_d() +\n  labs(title = \"grain SpatRaster\", caption = \"data: {spData}\")\n\n\n\n\n\n\n\n\n\n\n\n(a) elev\n\n\n\n\n\n\n\n\n\n\n\n(b) grain\n\n\n\n\n\n\n\nFigure 6: Section 4.3: Raster Datasets used: plotted using ggplot2 and {tidyterra}\n\n\n\n\n4.3.1 Spatial subsetting\n\nSpatial subsetting allows extraction of raster data by location (coordinates) or spatial objects:\n\nterra::extract(): Extracts raster values directly using coordinates. (Note: A function with the same name exists in the tidyverse, so be careful to add package name at start).\n\nSubsetting with another raster object:\n\nUse a secondary raster as a spatial mask to subset the primary raster, using terra::crop() .\nExample shown below: Subsetting elev using a smaller raster clip_raster (defining a specific extent).\nTwo kinds of Spatial outputs from subsetting:\n\nUse the drop argument with the [ ] operator to return subsetting results as raster objects.\nExample: Subsets the first two cells of elev with elev[1:2, drop = FALSE], whereas elev[1:2] returns the cell values of first two cells only.\n\n\nMasking raster data with logical values:\n\nCreates a raster mask (rmask) with NA and TRUE values.\nMasks the primary raster (elev) to retain only values corresponding to TRUE in the mask using:\n\n[ ] operator - use TRUE and FALSE.\nmask() function - use TRUE and NA.\n\n\nThe terra::crop() function extracts a subset of a raster or vector object based on a specified extent, defined using another spatial object or terra::ext(). It retains the input’s resolution and CRS, focusing analysis on a specific region. Commonly used for preprocessing large datasets, it pairs well with terra::mask() for refined cropping.\nThe mask() function in the terra package applies a mask to a SpatRaster or SpatVector. It replaces values in a raster (x) with NA (or another value) where another raster or vector (mask) has NA or specified mask values. It’s useful for filtering, clipping, or focusing on specific areas.\nThe extract() function in the terra package retrieves values from a SpatRaster based on specified locations or geometries. Locations can be points (as a SpatVector, matrix, or data frame), cell numbers, or spatial objects like polygons. It supports methods for exact or weighted extraction, interpolation, and summary statistics for extracted data. Key arguments include:\n\nx: The SpatRaster to extract values from\ny: Locations (e.g., points, polygons, or cell numbers) to extract values for.\nfun: Summarizes extracted data for polygons (e.g., mean, sum).\ncells/xy: Optionally return cell numbers or coordinates.\nweights/exact: Extract weighted or exact fractions for polygons.\n\n\n\n# Let us extract some values from \"elev\" using coordinates\n# I want to extract coordiantes of \ncoords_extract &lt;- matrix(\n  c(-1.2, -1.2,\n    1.2, 1.2),\n  ncol = 2,\n  byrow = T\n)\n\ncoords_extract\n\n     [,1] [,2]\n[1,] -1.2 -1.2\n[2,]  1.2  1.2\n\nelev |&gt; \n  terra::extract(\n    y = coords_extract\n  )\n\n  elev\n1   31\n2    6\n\n# Let us create a new raster to clip the central four blocks of the elev raster\nclip_raster &lt;- rast(\n  xmin = -0.5, xmax = 0.5, \n  ymin = -0.5, ymax = 0.5,\n  resolution = 0.5, \n  vals = sample(1:25, 4)\n  )\n\n# Extracting only the values\nelev[clip_raster]\n\n  elev\n1   15\n2   16\n3   21\n4   22\n\n# Explaining the meaning of argument drop = FALSE in the \n# base R subsetting operator \"[]\"\nelev[clip_raster]\n\n  elev\n1   15\n2   16\n3   21\n4   22\n\nelev[clip_raster, drop = FALSE]    \n\nclass       : SpatRaster \ndimensions  : 2, 2, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -0.5, 0.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : elev \nname        : elev \nmin value   :   15 \nmax value   :   22 \n\n# Using the {terra} approach: with the function terra::crop()\nelev |&gt; \n  terra::crop(clip_raster)\n\nclass       : SpatRaster \ndimensions  : 2, 2, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -0.5, 0.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : elev \nname        : elev \nmin value   :   15 \nmax value   :   22 \n\n# Creating a temporary_mask object\ntemporary_mask &lt;- elev\nvalues(temporary_mask) &lt;- sample(c(NA, TRUE), 36,\n                                 replace = T)\n\nelev |&gt;\n  terra::mask(temporary_mask)\n\nclass       : SpatRaster \ndimensions  : 6, 6, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : elev \nname        : elev \nmin value   :    1 \nmax value   :   36 \n\n\nggplot() +\n  geom_spatraster(data = clip_raster) +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5)) +\n  scale_fill_grass_c(limits = c(1, 36))\n\nggplot() +\n  geom_spatraster(data = temporary_mask) +\n  scale_fill_discrete(na.value = \"white\") +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5))\n\nggplot() +\n  geom_spatraster(data = elev |&gt; mask(temporary_mask)) +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5)) +\n  scale_fill_grass_c(limits = c(1, 36))\n\n\n\n\n\n\n\n\n\n\n\n(a) Plotting clip_raster: a smaller raster\n\n\n\n\n\n\n\n\n\n\n\n(b) The temporary_mask raster\n\n\n\n\n\n\n\n\n\n\n\n(c) plotting the masked elev, based on a randomly generated temporary_mask\n\n\n\n\n\n\n\nFigure 7: Showing plots from the code of above\n\n\n\n\n\n4.3.3 Local operations\n\nLocal operations are cell-by-cell operations performed on one or more raster layers. Includes operations like addition, subtraction, squaring, logical comparisons, and logarithmic transformations. Examples are shown in Figure 8\nReclassification:\n\nNumeric values can be grouped into intervals (e.g., low, middle, high elevations).\nUse the classify() function with a reclassification matrix to assign new values to defined ranges.\n\n\n\nggplot() +\n  geom_spatraster(data = elev) +\n  ggtitle(\"`elev` - the original raster\") +\n  paletteer::scale_fill_paletteer_c(\"grDevices::terrain.colors\") +\n  theme(legend.position = \"bottom\")\n\nggplot() +\n  geom_spatraster(data = elev^2) +\n  ggtitle(\"elev^2\") +\n  paletteer::scale_fill_paletteer_c(\"grDevices::terrain.colors\") +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(30, \"pt\"))\n\nggplot() +\n  geom_spatraster(data = log2(elev)) +\n  ggtitle(\"log2(elev)\") +\n  paletteer::scale_fill_paletteer_c(\"grDevices::terrain.colors\") +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(30, \"pt\"))\n\n\nggplot() +\n  geom_spatraster(data = elev &gt; 10) +\n  ggtitle(\"elev &gt; 10\") +\n paletteer::scale_fill_paletteer_d(\"ggsci::alternating_igv\") +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(30, \"pt\"))\n\n\n\n\n\n\n\n\n\n\n(a) elev\n\n\n\n\n\n\n\n\n\n\n\n(b) elev^2\n\n\n\n\n\n\n\n\n\n\n\n(c) log2(elev)\n\n\n\n\n\n\n\n\n\n\n\n(d) elev &gt; 10\n\n\n\n\n\n\nFigure 8\n\n\n\n\n\nEfficient alternatives for operations:\n\napp(): The app() function in the {terra} package applies a user-defined or pre-existing function to each cell’s values of a SpatRaster, treating layers as columns in a matrix. Functions should return outputs divisible by the total cell count.\ntapp(): The tapp() function in the {terra} package applies a function to subsets of layers in a SpatRaster grouped by an index. It allows for aggregation or summarization of layers based on grouping criteria such as indices, time periods (e.g., “years”, “months”), or custom functions.\nlapp(): The lapp() function in the {terra} package applies a user-defined function to the layers of a SpatRaster or SpatRasterDataset, treating each layer as an argument to the function. The function must accept a vector of layer values and return a vector or matrix of the same or compatible size. This is useful for combining or transforming layers, such as performing arithmetic operations between them. An example of lapp() is the NDVI Calculation:\n\nNDVI (Normalized Difference Vegetation Index) is a local operation to assess vegetation:\n\nFormula: (NIR - Red) / (NIR + Red).\n\nCalculated from satellite data (e.g., Landsat 8) with red and NIR bands.\n\nPositive NDVI values (&gt; 0.2) indicate vegetation.\nLargest values correspond to dense forests, while lowest values are related to lakes and snowy areas.\n\n\n\n\n\nmulti_rast = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_rast)\n# Rescale values to actual values (stored integers to save disk space)\nmulti_rast = (multi_rast * 0.0000275) - 0.2\n# Remove negative values due to clouds etc.\nmulti_rast[multi_rast &lt; 0] = 0\nobject.size(multi_rast)\n\n1304 bytes\n\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\n\nndvi_rast = lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)\n\nggplot() +\n  geom_spatraster(\n    data = ndvi_rast,\n    mapping = aes(fill = lyr1)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Terrain 2\",\n    direction = -1,\n    limits = c(0, 1),\n    oob = scales::squish\n  ) +\n  labs(\n    title = \"Zion National Park - Satellite Photo Raster\",\n    subtitle = \"Using custom nvdi_fun() to find NVDI\\nand plot vegetation areas in {ggplot2}\",\n    fill = NULL\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.key.width = unit(40, \"pt\")\n  )\n\n\n\n\n\n\n\n\n\n\n4.3.4 Focal operations\n\nFocal operations consider a central cell and its neighbours within a defined neighbourhood (kernel, filter, or moving window).\n\nCommon neighbourhood size: 3x3 cells (central cell + 8 neighbours), but customizable sizes and shapes are supported.\nThe operation aggregates values within the neighbourhood and assigns the result to the central cell, iterating across all cells.\n\nImplementation in R:\n\nUse the focal() function to perform spatial filtering Figure 9. Parameters:\n\nw: Defines the weights of the moving window using a matrix, example in Figure 9 (c).\nfun: Specifies the aggregation function (e.g., min, sum, mean, var), as in Figure 9 (b)\n\n\nApplications:\n\nSpatial filtering or convolution for raster operations.\nLow-pass filters:\n\nUse the mean function to smooth and reduce extreme values.\nFor categorical data, replace the mean with the mode (most common value).\n\nHigh-pass filters:\n\nEnhance features using methods like Laplace or Sobel filters (e.g., line detection).\n\nTerrain processing:\n\nCompute topographic characteristics like slope, aspect, and flow directions using focal functions.\n\n\n\n\nggplot() +\n  geom_spatraster(data = elev) +\n  labs(title = \"elev SpatRaster\", caption = \"data: {spData}\")\n\nggplot() +\n  geom_spatraster(\n    data = elev |&gt; \n        terra::focal(\n        w = matrix(rep(1, 9), 3, 3),\n        fun = min\n      )\n  ) +\n  labs(title = \"Focal operation min on a 3X3 matric\",\n       subtitle = \"Simple min() function with na.rm = FALSE\")\n\nggplot() +\n  geom_spatraster(\n    data = elev |&gt; \n        terra::focal(\n        # Sobel filters (for edge detection):\n        w = matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow = 3),\n        fun = mean,\n        na.rm = TRUE\n      )\n  ) +\n  labs(\n    title = \"Focal operation min on a 3X3 matric\",\n    subtitle = \"Sobel filter matrix for edge detection, with mean() function\"\n  )\n\n\n\n\n\n\n\n\n\n\n(a) Original elev raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Focal operation with min() and a simple matrix of equal weights\n\n\n\n\n\n\n\n\n\n\n\n(c) Focal operation with mean() and a sobel filter matrix for edge detection\n\n\n\n\n\n\nFigure 9: Focal operations on Rasters using terra::focal()\n\n\n\n\n\n\n4.3.5 Zonal operations\n\nZonal operations aggregate raster cell values based on zones defined by a second raster with categorical values. Unlike focal operations, zones in zonal operations do not require neighboring cells to be adjacent.\nKey Characteristics:\n\nThe zonal() function in the terra package computes zonal statistics by summarizing the values of a SpatRaster for each “zone” defined by another SpatRaster. It applies a specified function (fun, e.g., mean, sum) to aggregate the data for each zone.\nThe result is typically a summary table, grouped by zones. Zones are defined by a secondary raster.\nOptional Output: A raster with calculated statistics for each zone can be generated by setting as.raster = TRUE.\n\nUsage:\n\nIdeal for summarizing raster values based on irregularly spread categorical zones.\nCommonly used in land classification, soil analysis, and other spatial analyses where zones are pre-defined.\n\n\nggplot() +\n  geom_spatraster(data = elev) +\n  labs(title = \"elev SpatRaster\", caption = \"data: {spData}\")\n  \n\nggplot() +\n  geom_spatraster(data = grain) +\n  labs(title = \"grain SpatRaster\", caption = \"data: {spData}\")\n\n\n\n\n\n\n\n\n\n\n\n(a) elev\n\n\n\n\n\n\n\n\n\n\n\n(b) grain\n\n\n\n\n\n\n\nFigure 10: The elev and grain rasters\n\n\n\n\nelev |&gt; \n  terra::zonal(\n    z = grain,\n    fun = mean\n  ) |&gt; \n  as_tibble()\n\n# A tibble: 3 × 2\n  grain  elev\n  &lt;chr&gt; &lt;dbl&gt;\n1 clay   14.8\n2 silt   21.2\n3 sand   18.7\n\n\n\n\n4.3.6 Global operations and distances\n\nGlobal operations consider the entire raster dataset as a single zone.\nCommon operations include:\n\nDescriptive statistics: Minimum, maximum, etc.\nDistance calculations: Compute distance from each cell to a target cell using terra::distance(). The terra::distance() function calculates the shortest distance from each cell in a raster to a set of target cells, which are identified based on a condition (e.g., where raster values are non-NA, equal to a specific value, or greater than a threshold). This is useful for spatial analysis, such as finding proximity to certain features or zones in a raster.\nWeighted distances: Factor in additional variables, such as elevation, to modify distance calculations.\nVisibility and viewshed analysis: Assess visible areas from a specific point.\n\nApplications:\n\nDistance to coastlines or other target areas.\nTopography-aware distance calculations.\nAdvanced spatial modeling like visibility analysis.\n\n\n\n# Create a sample SpatRaster\nr &lt;- rast(ncols = 10, nrows = 10, \n          xmin = 0, xmax = 10, \n          ymin = 0, ymax = 10)\nvalues(r) &lt;- NA\nvalues(r)[c(5, 15, 25)] &lt;- 1  # Assign specific cells as targets\n\n# Compute the distance to the non-NA cells\ndist_raster &lt;- distance(r)\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\ndist_raster &lt;- dist_raster * 1e-5\n\n# View the raster\nggplot() +\n  geom_spatraster(data = r) +\n  labs(title = \"Original Raster (Targets in Blue)\") +\n  theme(\n    legend.position = \"bottom\"\n  )\n\n# View the distance raster\nggplot() +\n  geom_spatraster(data = dist_raster) +\n  labs(title = \"Distance to Targets (in units)\",\n       fill = \"Distance in Degrees\") +\n  paletteer::scale_fill_paletteer_c(\"ggthemes::Red-Gold\") +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\n(a) Original raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Distance raster\n\n\n\n\n\n\n\nFigure 11: Using the terra::distance()\n\n\n\n\n\n4.3.7 Map algebra counterparts in vector processing\n\nEquivalence between raster and vector operations:\n\nDistance raster (global operation) ≈ Buffer operation (vector) (Section 5.2.5).\nRaster reclassification ≈ Dissolving vector boundaries (Section 4.2.5).\nRaster overlay with masks ≈ Vector clipping (Section 5.2.5).\nZonal operations ≈ Aggregating vector geometries by zones.\n\n\n\n\n4.3.8 Merging rasters\n\nCombines multiple raster datasets into a single raster. Often required for datasets spanning multiple spatial scenes (e.g., satellite imagery, elevation data).\nmerge():\n\nPlaces rasters side by side.\nFor overlapping areas, prioritizes values from the first raster.\n\n\n\naut &lt;- geodata::elevation_30s(country = \"AUT\", path = tempdir())\nggplot() +\n  geom_spatraster(data = aut) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Austria\")\n\n\n\n\n\n\n\ncze &lt;- geodata::elevation_30s(country = \"CZE\", path = tempdir())\nggplot() +\n  geom_spatraster(data = cze) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Czechia\")\n\n\n\n\n\n\n\nsvk &lt;- geodata::elevation_30s(country = \"SVK\", path = tempdir())\nggplot() +\n  geom_spatraster(data = svk) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Slovakia\")\n\n\n\n\n\n\n\naut_cze_svk &lt;- aut |&gt; \n  merge(svk) |&gt; \n  merge(cze)\n\nggplot() +\n  geom_spatraster(data = aut_cze_svk) +\n  scale_fill_wiki_c() +\n  ggtitle(\"Austria, Czechia and Slovakia\")\n\n\n\n\n\n\n\n\n\nmosaic():\n\nHandles overlaps by applying a function (e.g., mean) to the overlapping area.\nHelps smooth visible borders but may not eliminate them entirely."
  },
  {
    "objectID": "book_solutions/chapter4.html#exercises",
    "href": "book_solutions/chapter4.html#exercises",
    "title": "Chapter 4: Spatial data operations",
    "section": "4.4 Exercises",
    "text": "4.4 Exercises\n\nE1.\nIt was established in Section 4.2 that Canterbury was the region of New Zealand containing most of the 101 highest points in the country. How many of these high points does the Canterbury region contain?\nCanterbury contains 70 of these high points.\n\ndata(\"nz\")\ndata(\"nz_height\")\n\nnz_height |&gt; \n  st_intersection(\n    nz |&gt; filter(Name == \"Canterbury\")\n  ) |&gt; \n  nrow()\n\n[1] 70\n\n\nBonus: plot the result using the plot() function to show all of New Zealand, canterbury region highlighted in yellow, high points in Canterbury represented by red crosses (hint: pch = 7) and high points in other parts of New Zealand represented by blue circles. See the help page ?points for details with an illustration of different pch values.\n\nnz_height |&gt; \n  mutate(\n    in_canterbury = nz_height |&gt; \n      st_intersects(\n        nz |&gt; filter(Name == \"Canterbury\"),\n        sparse = FALSE\n      )\n  ) |&gt; \n  ggplot() +\n  geom_sf(\n    data = nz |&gt; mutate(fill_var = Name == \"Canterbury\"),\n    mapping = aes(fill = fill_var)\n  ) +\n  geom_sf(\n    mapping = aes(shape = in_canterbury, colour = in_canterbury)\n  ) +\n  scale_shape_manual(values = c(16, 4)) +\n  scale_colour_manual(values = c(\"blue\", \"red\")) +\n  scale_fill_manual(values = c(\"transparent\", \"yellow\")) +\n  labs(\n    fill = \"Is the region Canterbury?\",\n    colour = \"Peaks are in Canterbury?\",\n    shape = \"Peaks are in Canterbury?\"\n  ) +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\nE2.\nWhich region has the second highest number of nz_height points, and how many does it have?\nThe region with second highest number of nz_height points is West Coast. It has 22 such points.\n\nnz_height |&gt; \n  st_join(nz) |&gt; \n  st_drop_geometry() |&gt; \n  group_by(Name) |&gt; \n  count()\n\n# A tibble: 7 × 2\n# Groups:   Name [7]\n  Name                  n\n  &lt;chr&gt;             &lt;int&gt;\n1 Canterbury           70\n2 Manawatu-Wanganui     2\n3 Marlborough           1\n4 Otago                 2\n5 Southland             1\n6 Waikato               3\n7 West Coast           22\n\n\n\n\n\nE3.\nGeneralizing the question to all regions: how many of New Zealand’s 16 regions contain points which belong to the top 101 highest points in the country? Which regions?\n\nBonus: create a table listing these regions in order of the number of points and their name.\n\nSeven (7) regions of New Zealand contain points which belong to top 101 highest points in the country. The table is shown below.\n\nnz_height |&gt; \n  st_join(nz) |&gt; \n  st_drop_geometry() |&gt; \n  group_by(Name) |&gt; \n  count(name = \"Number of points\", sort = T) |&gt; \n  ungroup() |&gt; \n  mutate(`S.No.` = row_number()) |&gt; \n  relocate(`S.No.`) |&gt;\n  gt::gt() |&gt; \n  gtExtras::gt_theme_538() |&gt; \n  gt::tab_header(\n    title = \"Number of highest points in each region of New Zealand\"\n  )\n\n\n\nTable 2: Table listing the regions\n\n\n\n\n\n\n\n\n\nNumber of highest points in each region of New Zealand\n\n\nS.No.\nName\nNumber of points\n\n\n\n\n1\nCanterbury\n70\n\n\n2\nWest Coast\n22\n\n\n3\nWaikato\n3\n\n\n4\nManawatu-Wanganui\n2\n\n\n5\nOtago\n2\n\n\n6\nMarlborough\n1\n\n\n7\nSouthland\n1\n\n\n\n\n\n\n\n\n\n\n\nTest your knowledge of spatial predicates by finding out and plotting how US states relate to each other and other spatial objects.\n\n\nE4.\nThe starting point of this exercise is to create an object representing Colorado state in the USA. Do this with the command colorado = us_states[us_states$NAME == \"Colorado\",] (base R) or with the filter() function (tidyverse) and plot the resulting object in the context of US states.\n\ndata(\"us_states\")\n\ncolorado &lt;- us_states |&gt; \n  filter(NAME == \"Colorado\")\n\nggplot() +\n  geom_sf(data = colorado) +\n  ggtitle(\"Map of Colorado State\") +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  )\n\n\n\n\n\n\n\nFigure 12: Map of Colorado State\n\n\n\n\n\n\nCreate a new object representing all the states that geographically intersect with Colorado and plot the result (hint: the most concise way to do this is with the subsetting method [).\n\n\nggplot() +\n  geom_sf(\n    data = us_states,\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = colorado,\n    fill = \"yellow\"\n  ) +\n  geom_sf_text(\n    data = colorado,\n    mapping = aes(\n      label = NAME\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\"\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Map of USA states, with Colorado highlighted\"\n  )\n\n\n\n\n\n\n\nFigure 13: Colorado, within USA’s states; with projection changed to Albers Equal Area Projection\n\n\n\n\n\n\nCreate another object representing all the objects that touch (have a shared boundary with) Colorado and plot the result (hint: remember you can use the argument op = st_intersects and other spatial relations during spatial subsetting operations in base R).\n\n\nbordering &lt;- us_states |&gt; \n  mutate(\n    border_colorado = as_vector(\n      as_vector(\n        us_states |&gt; \n        st_intersects(colorado, sparse = FALSE)\n      )\n    )\n  )\n\nggplot() +\n  geom_sf(\n    data = bordering,\n    mapping = aes(\n      fill = border_colorado\n    )\n  ) +\n  scale_fill_manual(\n    values = c(\"transparent\", \"orange\")\n  ) +\n  geom_sf_text(\n    data = filter(bordering, border_colorado),\n    mapping = aes(\n      label = NAME\n    ),\n    family = \"caption_font\"\n  ) +\n  geom_sf(\n    data = colorado,\n    fill = \"red\"\n  ) +\n  geom_sf_text(\n    data = colorado,\n    mapping = aes(\n      label = NAME\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\"\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Map of USA states, with states bordering Colorado highlighted in orange\"\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\nBonus: create a straight line from the centroid of the District of Columbia near the East coast to the centroid of California near the West coast of the USA (hint: functions st_centroid(), st_union() and st_cast() described in Chapter 5 may help) and identify which states this long East-West line crosses.\n\n\nwdc_centre &lt;- st_centroid(\n  us_states |&gt; filter(NAME == \"District of Columbia\")\n) |&gt; \n  pull(geometry)\n\ncal_centre &lt;- st_centroid(\n  us_states |&gt; filter(NAME == \"California\")\n) |&gt; \n  pull(geometry)\n\nstraight_line &lt;- st_union(\n  wdc_centre,\n  cal_centre\n) |&gt; \n  st_cast(\n    \"LINESTRING\"\n  )\n\nus_states |&gt; \n  mutate(\n    on_the_way = as_vector(\n      st_intersects(\n        us_states, \n        straight_line, \n        sparse = FALSE\n      )\n    )\n  ) |&gt; \n  ggplot() +\n  geom_sf(\n    mapping = aes(\n      fill = on_the_way\n    )\n  ) +\n  scale_fill_manual(\n    values = c(\"transparent\", \"orange\")\n  ) +\n  geom_sf(\n    data = straight_line,\n    linewidth = 0.5\n  ) +\n  geom_sf(\n    data = cal_centre,\n    size = 2\n  ) +\n  geom_sf(\n    data = wdc_centre,\n    size = 2\n  ) +\n  coord_sf(\n    crs = \"EPSG:5070\"\n  ) +\n  labs(\n    subtitle = \"Line from Centroids of District of Columbia and California;\\nand highlighting the states that it crosses through\"\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nE5.\nUse dem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\")), and reclassify the elevation in three classes: low (&lt;300), medium and high (&gt;500). Secondly, read the NDVI raster (ndvi = rast(system.file(\"raster/ndvi.tif\", package = \"spDataLarge\"))) and compute the mean NDVI and the mean elevation for each altitudinal class.\n\ndem &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\nggplot() +\n  geom_spatraster(data = dem) +\n  paletteer::scale_fill_paletteer_c(\"grDevices::Terrain 2\") +\n  ggtitle(\"Base raster `dem`\")\n\ndem1 &lt;- dem\n\nvalues(dem1) &lt;- values(dem) |&gt; \n  as_tibble() |&gt; \n  mutate(\n    dem_class = case_when(\n      dem &lt; 300 ~ \"Low\",\n      dem &gt; 500 ~ \"High\",\n      .default = \"Medium\"\n    )\n  ) |&gt; \n  pull(dem_class)\n\nggplot() +\n  geom_spatraster(data = dem1) +\n  scale_fill_manual(values = c(\"#F1E4E3FF\", \"#00A600FF\", \"#EAB550FF\")) +\n  ggtitle(\"The raster `dem` with elevation classified into 3 levels\")\n\n\n\n\n\n\n\n\n\n\n(a) Base raster\n\n\n\n\n\n\n\n\n\n\n\n(b) Reclassified raster\n\n\n\n\n\n\nFigure 14: Classifying elevation into high, middle and low\n\n\n\n\n\nndvi &lt;- rast(system.file(\"raster/ndvi.tif\", package = \"spDataLarge\"))\n\ntibble(\n  elevation_class = values(dem1),\n  elevation = values(dem),\n  ndvi = values(ndvi)\n) |&gt; \n  group_by(elevation_class) |&gt; \n  summarise(\n    mean_elevation = mean(elevation),\n    mean_ndvi = mean(ndvi)\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    columns = c(mean_elevation, mean_ndvi)\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::tab_header(\n    title = \"Mean elevation and NDVI for each altitude class\"\n  ) |&gt; \n  gtExtras::gt_theme_538()\n\n\n\nTable 3: Mean elevation and NDVI for each altitude class\n\n\n\n\n\n\n\n\n\nMean elevation and NDVI for each altitude class\n\n\nElevation Class\nMean Elevation\nMean Ndvi\n\n\n\n\n1\n765.22\n−0.21\n\n\n2\n273.79\n−0.36\n\n\n3\n391.61\n−0.29\n\n\n\n\n\n\n\n\n\n\n\n\n\nE6.\nApply a line detection filter to rast(system.file(\"ex/logo.tif\", package = \"terra\")). Plot the result. Hint: Read ?terra::focal().\nThe code below demonstrates edge detection on a raster image using Sobel filters with the {terra} package in R. The Sobel filters, represented as matrices fx and fy, are defined for detecting edges in horizontal and vertical directions, respectively. The focal() function applies these filters to the raster image, performing convolution to emphasize areas of rapid intensity change (edges). The processed images are then plotted, one showing horizontal edges (filtered with fx) in black and white, and the other showing vertical edges (filtered with fy) in white and black. This illustrates how Sobel filters can be used for edge detection in spatial raster data.\nlogo &lt;- rast(system.file(\"ex/logo.tif\", package = \"terra\"))\n\nplot(logo)\n\n# Sobel filters (for edge detection):\nfx &lt;- matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow = 3)\nfy &lt;- matrix(c(1,0,-1,2,0,-2,1,0,-1), nrow = 3)\n\nlogo |&gt; \n  terra::focal(w = fx) |&gt; \n  plot(col = c(\"white\", \"black\"))\n\nlogo |&gt; \n  terra::focal(w = fy) |&gt; \n  plot(col = c(\"black\", \"white\"))\n\n\n\n\n\n\n\n\n\n\n\n(a) Base raster Logo\n\n\n\n\n\n\n\n\n\n\n\n(b) Horizontal edges detected with fx\n\n\n\n\n\n\n\n\n\n\n\n(c) Vertical edges detected with fy\n\n\n\n\n\n\n\nFigure 15: Edge detection with terra::focal()\n\n\n\n\n\n\nE7.\nCalculate the Normalized Difference Water Index (NDWI; (green - nir)/(green + nir)) of a Landsat image. Use the Landsat image provided by the spDataLarge package (system.file(\"raster/landsat.tif\", package = \"spDataLarge\")). Also, calculate a correlation between NDVI and NDWI for this area (hint: you can use the layerCor() function).\nThis code processes and visualizes raster data for Zion National Park, performing computations to derive vegetation and water indices and then plotting the results. The raster, containing layers for Red, Green, Blue, and Near Infrared (NIR) bands, is rescaled to real-world values, with negative values replaced by zeros.\nUsing custom functions, the NDVI (Normalized Difference Vegetation Index) and NDWI (Normalized Difference Water Index) are calculated from the NIR, Red, and Green bands. The resulting indices are converted into a tidy SpatRaster format for plotting.\nThe code below also calculates the correlation between the NDVI and NDWI layers as -0.96, thus telling us the NDVI and NDWI are negatively correlated (inversely correlated).\n\n#################### LONG, BASE R METHOD ########################\n\n#################### I Don't Use This ###########################\n\n# Download the Zion National Park Raster File with layers of \n# Red, Green, Blue and NIR (Near Infra Red)\nlandsat &lt;- rast(\n  system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\n)\n\n# Applying a scale factor to return values to actual ones.\n# The data-set was scaled to save disk space\nlandsat = (landsat * 0.0000275) - 0.2\n\n# Remove and replace negative values, since these were due to clouds\nlandsat[landsat &lt; 0] = 0\n\n# Write a custom function for computing values of \n# NDVI (normalized difference vegetation index) in R\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\n\n# Create a new raster with NDVI values using terra::lapp()\nlandsat_ndvi &lt;- lapp(landsat[[c(4, 3)]], fun = ndvi_fun)\n\n# Write a custom function for computing values of \n# NDWI (normalized difference water index) in R\nndwi_fun = function(nir, green){\n  (green - nir) / (nir + green)\n}\n\n# Create a new raster with NDVI values using terra::lapp()\nlandsat_ndwi &lt;- lapp(landsat[[c(4, 2)]], fun = ndwi_fun)\n\ncor(\n  values(landsat_ndvi),\n  values(landsat_ndwi),\n  use = \"complete.obs\"\n)\n\n# The correlation is -0.96. NDVI and NDWI are negatively correlated.\n\n\n###################### THE TIDY APPROACH #######################\n\n# Download the Zion National Park Raster File with layers of \n# Red, Green, Blue and NIR (Near Infra Red)\nlandsat &lt;- rast(system.file(\"raster/landsat.tif\", package = \"spDataLarge\")) |&gt;\n  \n  # Applying a scale factor to return values to actual ones,\n  # The data-set was scaled to save disk space.\n  multiply_by(0.0000275) |&gt;\n  subtract(0.2) |&gt; \n  \n  # Remove and replace negative values, since these were due to clouds\n  mutate(across(everything(), ~ ifelse(. &lt; 0, 0, .)))\n\n# Write a custom function for computing values of \n# NDVI (normalized difference vegetation index) in R\nndvi_fun &lt;- function(nir, red) {\n  (nir - red) / (nir + red)\n}\n\n# Write a custom function for computing values of \n# NDWI (normalized difference water index) in R\nndwi_fun &lt;- function(nir, green) {\n  (green - nir) / (green + nir)\n}\n\n# Doing the tidy data wrangling magic with tidyverse and tidyterra\nlandsat1 &lt;- landsat |&gt; \n  as_tibble(xy = TRUE) |&gt; \n  mutate(\n    ndvi = ndvi_fun(landsat_4, landsat_3),\n    ndwi = ndwi_fun(landsat_4, landsat_2)\n  ) |&gt; \n  select(-starts_with(\"landsat\")) |&gt; \n  tidyterra::as_spatraster(\n    crs = st_crs(landsat)\n  )\n\n# Labeller for the facets\nlyr_labels &lt;- c(\n  \"normalized difference vegetation index\",\n  \"normalized difference water index\"\n) |&gt; \n  str_to_title()\nnames(lyr_labels) &lt;- c(\"ndvi\", \"ndwi\")\n\nlayerCor(landsat1, fun = cor, use = \"complete.obs\") |&gt; \n  round(digits = 2)\n\n      [,1]  [,2]\n[1,]  1.00 -0.96\n[2,] -0.96  1.00\n\n\nThe ggplot2 visualization in Figure 16 uses facets to compare NDVI and NDWI values across the area, with clear labelling and a perceptually uniform colour scale.\n\n# The actual final plot\nggplot() +\n  geom_spatraster(data = landsat1) +\n  scale_fill_grass_c(\n    na.value = \"white\"\n  ) +\n  facet_wrap(~lyr, labeller = labeller(lyr = lyr_labels)) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Comparing NDVI and NDWI values\",\n    subtitle = \"Zion National Park area SpatRaster\",\n    fill = \"Value\"\n  ) +\n  theme_minimal(\n    base_family = \"caption_font\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    text = element_text(\n      hjust = 0.5,\n      vjust = 0.5\n    )\n  )\n\n\n\n\n\n\n\nFigure 16: Comparing NDVI and NDWI values\n\n\n\n\n\n\n\n\nE8.\nA StackOverflow post (stackoverflow.com/questions/35555709) shows how to compute distances to the nearest coastline using raster::distance(). Try to do something similar but with terra::distance(): retrieve a digital elevation model of Spain, and compute a raster which represents distances to the coast across the country (hint: use geodata::elevation_30s()). Convert the resulting distances from meters to kilometers. Note: it may be wise to increase the cell size of the input raster to reduce compute time during this operation (aggregate()).\nThis code demonstrates the steps to compute and visualize the distance to the nearest coastline for Spain. First, it loads elevation data for Spain and nearby areas ( Figure 17 (a) ), as well as for Spain’s political boundaries ( Figure 17 (b) ), ensuring the inclusion of surrounding countries and water bodies. The raster is then aggregated for efficiency.\nInitial visualizations are created: one showing elevation for Spain and neighbouring areas, and another isolating only Spain.\nA binary raster is created where water is marked as TRUE (1) and land as NA. The distance() function calculates the distance of each land cell to the nearest water cell, with values converted to kilometres. ( Figure 17 (c) )\nFinally, the raw distance raster is masked to display only distances within Spain, producing a final visualization of Spain with distances to its nearest coastline ( Figure 17 (d) ). The Figure 17 includes multiple stages of the process, from raw data to the final processed map.\n\n# Full Spain and nearby Land Data\nspain_land &lt;- geodata::elevation_30s(\n  country = \"Spain\", \n  path = tempdir(),\n  \n  # Use mask = FALSE to ensure that other countries are not shown as NA\n  mask = FALSE)\n\n# Data for only Sapin Political Boundaries Land\nspain_only &lt;- geodata::elevation_30s(\n  country = \"Spain\", \n  path = tempdir()\n  )\n\nspain_working_land &lt;- spain_land |&gt; \n  aggregate(fact = 5)\n\nspain_working_only &lt;- spain_only |&gt; \n  aggregate(fact = 5)\n\nggplot() +\n  geom_spatraster(data = spain_working_land) +\n  scale_fill_terrain_c(\n    direction = -1\n  ) +\n  labs(\n    title = \"Land map of Spain and nearby areas\",\n    subtitle = \"Water / Sea is shown as transparent values (NA)\",\n    fill = \"Elevation (m)\"\n  ) \n\nggplot() +\n  geom_spatraster(data = spain_working_only) +\n  scale_fill_terrain_c(\n    direction = -1\n  ) +\n  labs(\n    title = \"Land map of only Spain\",\n    subtitle = \"Water + nearby countries are shown as transparent values (NA)\",\n    fill  = \"Elevation (m)\"\n  ) \n\n# Start with a simple raster where only water is TRUE (1) \n# and land is FALSE (0)\ntemp &lt;- is.na(spain_working_land)\n\n# Convert land (i.e. FALSE) into NA\ntemp[temp == 0] &lt;- NA\n\n# Compute distance of from nearest non-NA (i.e. Water / Sea)\ntemp &lt;- distance(temp)\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n# Divide by 1000 to convert into KM\ntemp &lt;- temp / 1000\n\nggplot() +\n  geom_spatraster(data = temp) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::heat.colors\",\n    direction = -1,\n  ) +\n  \n  labs(\n    fill = \"Distance from\\nwater (km)\",\n    title = \"Raw Spatraster of distance from Sea / Ocean\"\n  )\n\n# Convert this raw distance vector to mask and only show Spain\ntemp_spain &lt;- temp |&gt; \n  # Mask it with only the map of Spain Raster\n  mask(spain_working_only) \n\nggplot() +\n  geom_spatraster(data = temp_spain) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::heat.colors\",\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    fill = \"Distance\\n(km)\",\n    title = \"Spain: distances to nearest Coastline\"\n  )\n\n\n\n\n\n\n\n\n\n\n(a) Land map of Spain and nearby areas\n\n\n\n\n\n\n\n\n\n\n\n(b) Land map of only Spain\n\n\n\n\n\n\n\n\n\n\n\n(c) Raw Spatraster of distance from coastline for entire landmass\n\n\n\n\n\n\n\n\n\n\n\n(d) Final product: Spain with distances to nearest Coastline\n\n\n\n\n\n\nFigure 17: Steps in Computing the distance to nearest Coastline for Spain\n\n\n\n\n\n\n\nE9.\nTry to modify the approach used in the above exercise by weighting the distance raster with the elevation raster; every 100 altitudinal meters should increase the distance to the coast by 10 km. Next, compute and visualize the difference between the raster created using the Euclidean distance (E7) and the raster weighted by elevation.\nThe code below performs a spatial analysis and visualization of the relationship between elevation and distance to the coastline for Spain. It begins by visualizing Spain’s elevation using a raster dataset (spain_working_only). It then calculates and visualizes the Euclidean distance from each point to the nearest coastline (temp_spain), as already done in Exercise E7.\nA new raster (spain_weighted) is computed by weighting the Euclidean distance with elevation, where every 100 meters of elevation increases the effective distance to the coastline by 10 km.\nThe difference between the Euclidean distance raster and the elevation-weighted distance raster is then calculated and visualized (spain_difference).\nThe code uses the ggplot2 package to display these rasters as separate maps, with clear titles and color scales to interpret the elevation, distances, and differences.\n\nggplot() +\n  geom_spatraster(data = spain_working_only) +\n  scale_fill_wiki_c() +\n  labs(\n    fill = \"Altitude (m)\",\n    title = \"1. Elevation map of Spain\"\n  )\n\nggplot() +\n  geom_spatraster(data = temp_spain) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::heat.colors\",\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    fill = \"Distance\\n(km)\",\n    title = \"2. Spain: euclidean distances to nearest Coastline\"\n  )\n\nspain_weighted &lt;- temp_spain + ((spain_working_only/100) * 10)\n\nggplot() +\n  geom_spatraster(data = spain_weighted) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::heat.colors\",\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    fill = \"Distance\\n(km)\",\n    title = \"3. Spain: distance to coastline weighted by elevation\"\n  )\n\nspain_difference &lt;- spain_weighted - temp_spain\n\nggplot() +\n  geom_spatraster(data = spain_difference) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::heat.colors\",\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    fill = \"Difference\\nin Distance\\n(km)\",\n    title = \"4. Difference between 2nd and 3rd maps\"\n  )\n\n\n\n\n\n\n\n\n\n\n(a) Elevation map of Spain\n\n\n\n\n\n\n\n\n\n\n\n(b) Spain: euclidean distances to nearest Coastline\n\n\n\n\n\n\n\n\n\n\n\n(c) Spain: distance to coastline weighted by elevation\n\n\n\n\n\n\n\n\n\n\n\n(d) Difference between 2nd and 3rd maps\n\n\n\n\n\n\nFigure 18: Algebra on Rasters"
  },
  {
    "objectID": "book_solutions/chapter2.html",
    "href": "book_solutions/chapter2.html",
    "title": "Chapter 2: Geographic data in R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "book_solutions/chapter2.html#introduction",
    "href": "book_solutions/chapter2.html#introduction",
    "title": "Chapter 2: Geographic data in R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "book_solutions/chapter2.html#vector-data",
    "href": "book_solutions/chapter2.html#vector-data",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.2 Vector Data",
    "text": "2.2 Vector Data\n\nVector Data: Represents geographic features using points, lines, and polygons based on coordinate reference systems (CRS).\n\nExample: London’s coordinates c(-0.1, 51.5) in geographic CRS or c(530000, 180000) in projected CRS (British National Grid).\n\nCRS Overview:\n\nGeographic CRS uses lon/lat (0° longitude and latitude origin).\nProjected CRS, like the British National Grid, is based on Easting/Northing coordinates with positive values.\n\nKey dependencies / libraries used by the sf Package:\n\nGDAL: Handles geographic data formats\nPROJ: For CRS transformations\nGEOS: Supports planar geometry for projected data\nS2: Manages spherical geometry for unprojected data (e.g., lon/lat), toggleable with sf::sf_use_s2(FALSE).\n\nGeometry Engines:\n\nPlanar (GEOS): For 2D projected data.\nSpherical (S2): For 3D unprojected data.\n\n\n\n2.2.1 Introduction to Simple Features\n\nSimple Features (SF): Hierarchical model by OGC (Open Geospatial Consortium); supports multiple geometry types.\nCore Types: sf package in R supports 7 core geometry types (points, lines, polygons, and their “multi” versions).\nLibrary Integration: sf replaces sp, rgdal, rgeos; unified interface for GEOS (geometry), GDAL (data I/O), PROJ (CRS).\nNon-Planar Support: Integrates s2 for geographic (lon/lat) operations, used by default for accuracy on spherical geometries.\nData Storage: SF objects are data frames with a spatial column (geometry or geom).\nVignettes: Documentation accessible with vignette(package = \"sf\") for practical use and examples.\nPlotting: plot(sf_object) maps all variables, unlike single-map GIS tools.\nSummary: summary() gives spatial and attribute data insights.\nSubset: SF objects subsettable like data frames, retaining spatial metadata.\n\n\nworld\n\nSimple feature collection with 177 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n# A tibble: 177 × 11\n   iso_a2 name_long continent region_un subregion type  area_km2     pop lifeExp\n * &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 FJ     Fiji      Oceania   Oceania   Melanesia Sove…   1.93e4  8.86e5    70.0\n 2 TZ     Tanzania  Africa    Africa    Eastern … Sove…   9.33e5  5.22e7    64.2\n 3 EH     Western … Africa    Africa    Northern… Inde…   9.63e4 NA         NA  \n 4 CA     Canada    North Am… Americas  Northern… Sove…   1.00e7  3.55e7    82.0\n 5 US     United S… North Am… Americas  Northern… Coun…   9.51e6  3.19e8    78.8\n 6 KZ     Kazakhst… Asia      Asia      Central … Sove…   2.73e6  1.73e7    71.6\n 7 UZ     Uzbekist… Asia      Asia      Central … Sove…   4.61e5  3.08e7    71.0\n 8 PG     Papua Ne… Oceania   Oceania   Melanesia Sove…   4.65e5  7.76e6    65.2\n 9 ID     Indonesia Asia      Asia      South-Ea… Sove…   1.82e6  2.55e8    68.9\n10 AR     Argentina South Am… Americas  South Am… Sove…   2.78e6  4.30e7    76.3\n# ℹ 167 more rows\n# ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nnames(world)\n\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n\nclass(world)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n########### THE GEOMETRY COLUMN IS STICKY ################\nsummary(world[\"lifeExp\"])\n\n    lifeExp                 geom    \n Min.   :50.62   MULTIPOLYGON :177  \n 1st Qu.:64.96   epsg:4326    :  0  \n Median :72.87   +proj=long...:  0  \n Mean   :70.85                      \n 3rd Qu.:76.78                      \n Max.   :83.59                      \n NA's   :10                         \n\n\n\n\nCode\nplot(world)\n\n\n\n\n\n\n\n\nFigure 1: The basic plot() function on a sf object produced multiple plots, one for each of the non-geometry variables (columns) in the plotted dataset.\n\n\n\n\n\n\n\n2.2.2 Why Simple Features?\n\nCross-Compatibility: SF model is compatible with many GIS tools (e.g., QGIS, PostGIS), enabling easy data transfer.\nAdvantages of sf in R:\n\nData Handling: Fast reading/writing of spatial data.\nPlotting: Improved plotting speed and performance.\nData Frame-Like: sf objects behave like data frames.\nConsistent Naming: sf functions are intuitive, starting with st_.\nTidyverse-Friendly: Works well with |&gt; and integrates with tidyverse packages.\n\nData Import Options:\n\nread_sf(): Imports data as a tidy tibble (quietly).\nst_read(): Imports data as a base R data frame (verbose).\n\nPopularity: sf is the primary package for spatial vector data in R, preferred over alternatives like spatstat and terra.\n\n\nworld_dfr &lt;- st_read(system.file(\"shapes/world.shp\", package = \"spData\"))\n## Reading layer `world' from data source \n##   `C:\\Users\\dradi\\AppData\\Local\\R\\win-library\\4.3\\spData\\shapes\\world.shp' \n##   using driver `ESRI Shapefile'\n## Simple feature collection with 177 features and 10 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\nworld_dfr &lt;- read_sf(system.file(\"shapes/world.shp\", package = \"spData\"))\n\nclass(world_dfr)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n2.2.3 Basic Maps\n\nPlotting in sf:\n\nplot() creates multi-panel plots for multiple variables or a single-panel plot for one variable.\nSupports fixed color customization using col and border arguments.\n\n\n\n\nCode\nplot(world)\n\n\n\n\n\n\n\n\nFigure 2: The base plot() function creates a faceted output with a map for each variable other than geometry\n\n\n\n\n\n\nLayering Plots: Add layers to existing plots with add = TRUE. Use reset = FALSE for plots with a key.\nOverlaying Data: Circles representing population size can be plotted using cex and st_centroid().\nBounding Box Expansion: expandBB adjusts the plot boundaries (bottom, left, top, right).\nLimitations: Base plot() is simple but limited in functionality; use tmap for advanced maps.\n\n\n\n2.2.4 Geometry Types\n\nGeometry Basics:\n\nCore components of simple features; sf supports 18 types.\nFocus on 7 common types: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.\n\nEncoding Standards:\n\nWKB (Well-known binary): Hexadecimal, computer-friendly format.\nWKT (Well-known text): Human-readable format, often shown for explanation.\n\nCommon Geometries:\n\nPOINT: Single coordinate (e.g., POINT (5 2)).\nLINESTRING: Connected sequence of points (e.g., LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)).\nPOLYGON: Closed ring of points (e.g., POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))).\n\nMulti-Geometries:\n\nMULTIPOINT: Multiple points (e.g., MULTIPOINT (5 2, 1 3, 3 4, 3 2)).\nMULTILINESTRING: Multiple linestrings (e.g., MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))).\nMULTIPOLYGON: Multiple polygons (e.g., MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))).\n\nGeometry Collection:\n\nMix of geometry types (e.g., GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))).\n\n\n\n\n2.2.5 The sf Class\n\nStructure of sf Objects: Composed of geometries (sfc object) and non-geographic attributes (data.frame or tibble).\nCreation of sf Objects: Steps:\n\nCreate geometry (sfg) with functions like st_point()\nConvert to geometry column (sfc) with CRS using function st_sfc(..., crs = \"...\")\nCombine attributes (data.frame) with sfc using function st_sf(..., geometry = ...)\n\n\n\n\nCharacteristics:\n\nsf objects have dual class: sf and data.frame.\nSpatial attributes stored in a geometry column.\nsf behaves like a data.frame but with spatial extension.\n\n\n\n\n2.2.6 Simple Feature Geometries (sfg)\nAn sfg object represents a single simple feature geometry. A simple feature geometry column (sfc) is a collection of sfg objects and can also include information about the coordinate reference system (CRS) being used.\nGeometries can be created using st_ functions or imported from existing spatial files.\n\nsfg Creation Functions:\n\nst_point(): Create a single point.\nst_linestring(): Create a linestring.\nst_polygon(): Create a polygon.\nst_multipoint(): Create a multipoint.\nst_multilinestring(): Create a multilinestring.\nst_multipolygon(): Create a multipolygon.\nst_geometrycollection(): Create a geometry collection.\n\nInput Data Types:\n\nNumeric Vector: Single points.\nMatrix: Sets of points for multipoint or linestring.\nList: Complex structures for multilinestrings, (multi)polygons, or geometry collections.\n\nExamples:\n\n\nCode\n\n# Create a point\npoint &lt;- st_point(c(8, 3))  # POINT (8 3)\nprint(point)\nggplot(point) +\n  geom_sf()\n\n# Create a multipoint\nmultipoint_matrix &lt;- rbind(c(8, 3), c(2, 5), c(5, 7), c(7, 3))\nmultipoint &lt;- st_multipoint(multipoint_matrix)  # MULTIPOINT ((8 3), (2 5), (5 7), (7 3))\nprint(multipoint)\nggplot(multipoint) +\n  geom_sf()\n\n# Create a linestring\nlinestring_matrix &lt;- rbind(c(2, 8), c(6, 6), c(7, 2), c(5, 3), c(8, 4))\nlinestring &lt;- st_linestring(linestring_matrix)  # LINESTRING (2 8, 6 6, 7 2, 5 3, 8 4)\nprint(linestring)\nggplot(linestring) +\n  geom_sf()\n\n# Create a polygon\npolygon_list &lt;- list(rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8)))\npolygon &lt;- st_polygon(polygon_list)  # POLYGON ((2 8, 4 3, 7 2, 6 7, 2 8))\nprint(polygon)\nggplot(polygon) +\n  geom_sf()\n\n# Polygon with a hole\npolygon_border &lt;- rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8))\npolygon_hole &lt;- rbind(c(4, 6), c(5, 6), c(5, 5), c(4, 5), c(4, 6))\npolygon_with_hole_list &lt;- list(polygon_border, polygon_hole)\npolygon_with_hole &lt;- st_polygon(polygon_with_hole_list)  # POLYGON with a hole\nprint(polygon_with_hole)\nggplot(polygon_with_hole) +\n  geom_sf()\n\n# Create a multilinestring\nmultilinestring_list = list(\n  rbind(c(2, 8), c(6, 6), c(7, 2), c(5, 3), c(8, 4)),\n  rbind(c(3, 2), c(5, 8))\n)\nmultilinestring = st_multilinestring(multilinestring_list)  # MULTILINESTRING\nprint(multilinestring)\nggplot(multilinestring) +\n  geom_sf()\n\n# Create a multipolygon\nmultipolygon_list = list(\n  list(rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8))),\n  list(rbind(c(0, 3), c(2, 3), c(2, 4), c(0, 4), c(0, 3)))\n)\nmultipolygon = st_multipolygon(multipolygon_list)  # MULTIPOLYGON\nprint(multipolygon)\nggplot(multipolygon) +\n  geom_sf()\n\n# Create a geometry collection\ngeometrycollection_list = list(st_multipoint(multipoint_matrix), st_linestring(linestring_matrix))\ngeometry_collection = st_geometrycollection(geometrycollection_list)  # GEOMETRYCOLLECTION\nprint(geometry_collection)\nggplot(geometry_collection) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) A point\n\n\n\n\n\n\n\n\n\n\n\n(b) A multipoint\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) A linestring\n\n\n\n\n\n\n\n\n\n\n\n(d) A polygon\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e) Polygon with a hole\n\n\n\n\n\n\n\n\n\n\n\n(f) Multilinestring\n\n\n\n\n\n\n\n\n\n\n\n\n\n(g) Multipolygon\n\n\n\n\n\n\n\n\n\n\n\n(h) Geometry Collection\n\n\n\n\n\n\n\nFigure 3: Creating different sample geometry objects in R with {sf}\n\n\n\n\n\n2.2.8 The sfheaders Package\n\nOverview:\n\nsfheaders (Cooley 2024) is an R package designed to efficiently create and manipulate sf objects from vectors, matrices, and data frames.\nIt does not rely on the sf library and instead uses underlying C++ code, enabling faster operations and the potential for further development with compiled code.\n\nCompatibility:\n\nAlthough separate from sf, it is fully compatible, producing valid sf objects like sfg, sfc, and sf.\n\nKey Functionality:\n\nConverts:\n\nVector → sfg_POINT\nMatrix → sfg_LINESTRING\nData Frame → sfg_POLYGON\n\nCreates sfc and sf objects using similar syntax.\n\nAdvantages:\n\nsfheaders is optimized for high-speed ‘deconstruction’ and ‘reconstruction’ of sf objects and casting between geometry types, offering faster performance than sf in many cases.\n\n\n\n\n2.2.9 Spherical Geometry Operations with S2\n\nConcept:\n\nSpherical geometry operations acknowledge Earth’s roundness, as opposed to planar operations that assume flat surfaces.\nSince sf version 1.0.0, R integrates with Google’s S2 spherical geometry engine, enabling accurate global spatial operations.\nS2 supports operations like distance, buffer, and area calculations, allowing accurate geocomputation on a spherical Earth model.\nKnown as a Discrete Global Grid System (DGGS), S2 is similar to other systems like H3, which is a global hexagonal index.\n\nS2 Mode:\n\nBy default, S2 is enabled in sf. Verify with:\nsf_use_s2()\nTurning Off S2:\nsf_use_s2(FALSE)\n\nS2 Limitations and Edge Cases:\n\nSome operations may fail due to S2’s stricter definitions, potentially affecting legacy code. Error messages such as Error in s2_geography_from_wkb ... might require turning off S2.\n\nRecommendation:\n\nKeep S2 enabled for accurate global calculations unless specific operations necessitate its deactivation."
  },
  {
    "objectID": "book_solutions/chapter2.html#raster-data",
    "href": "book_solutions/chapter2.html#raster-data",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.3 Raster Data",
    "text": "2.3 Raster Data\n\nThe raster data model represents the world as a continuous grid of cells (pixels). Focuses on regular grids, where each cell is of constant size, though other grid types (e.g., rotated, sheared) exist.\nStructure:\n\nComprises a raster header and a matrix of equally spaced cells.\nThe raster header includes:\n\nCRS (Coordinate Reference System)\nExtent (geographical area covered)\nOrigin (starting point, often the lower left corner; the terra package defaults to the upper left).\n\nExtent is defined by:\n\nNumber of columns (ncol)\nNumber of rows (nrow)\nCell size resolution\n\n\nCell Access and Modification:\n\nCells can be accessed and modified by:\n\nCell ID\nExplicitly specifying row and column indices.\n\nThis matrix representation is efficient as it avoids storing corner coordinates (unlike vector polygons).\n\nData Characteristics:\n\nEach cell can hold a single value, which can be either:\n\nContinuous (e.g., elevation, temperature)\nCategorical (e.g., land cover classes).\n\n\nApplications:\n\nRaster maps are useful for continuous phenomena (e.g., temperature, population density) and can also represent discrete features (e.g., soil classes).\n\n\n\n2.3.1 R Packages for Working with Raster Data\n\nSeveral R packages for reading and processing raster datasets have emerged over the last two decades. The raster package was the first significant advancement in R’s raster capabilities when launched in 2010. It was the premier package until the development of terra and stars, both offering powerful functions for raster data.\nThis book emphasizes terra, which replaces the older, slower raster package.\nComparison of terra and stars:\n\n\n\n\n\n\n\n\n\nFeature\nterra\nstars\n\n\n\n\nPrimary Focus\nRegular grids\nSupports regular, rotated, sheared, rectilinear, and curvilinear grids\n\n\nData Structure\nOne or multi-layered rasters\nRaster data cubes with multiple layers, time steps, and attributes\n\n\nMemory Management\nUses C++ code and pointers for data storage\nUses lists of arrays for smaller rasters; file paths for larger ones\n\n\nVector Data Integration\nUses its own class SpatVector but supports sf objects\nClosely related to vector objects/functions in sf\n\n\nFunctions & Methods\nLarge number of built-in, purpose-specific functions (e.g., re-sampling, cropping)\nMix of built-in functions (st_ prefix), existing dplyr functions, and custom methods for R functions\n\n\nConversion Between Packages\nConversion to stars with st_as_stars()\nConversion to terra with rast()\n\n\nPerformance\nGenerally optimized for speed and memory efficiency\nFlexible, but performance varies based on data type and structure\n\n\nBest Use Cases\nSingle or multi-layer rasters; fast processing\nComplex data cubes with layers over time and multiple attributes\n\n\nProgramming Language Basis\nPrimarily C++\nR with some C++ integration\n\n\n\n\n\n2.3.2 Introduction to terra\n\nThe terra package is designed for handling raster objects in R, supporting a range of functions to create, read, export, manipulate, and process raster datasets.\n\nWhile its functionality is similar to the older raster package, terra offers improved computational efficiency.\nDespite terra’s advantages, the raster class system remains popular due to its widespread use in other R packages.\nterra provides seamless translation between the two object types using functions like raster(), stack(), and brick() for backward compatibility.\n\nKey Features:\n\nLow-Level Functionality: Includes functions that help in building new tools for raster data processing.\nMemory Management: Supports processing of large raster datasets by dividing them into smaller chunks for iterative processing, allowing operations beyond available RAM capacity.\n\n\n\n\nCode\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", \n                              package = \"spDataLarge\")\nmy_rast &lt;- rast(raster_filepath)\n\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\next(my_rast)\n## SpatExtent : -113.239583212784, -112.85208321281, 37.1320834298579, 37.5129167631658 (xmin, xmax, ymin, ymax)\n\nprint(my_rast)\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\n\nDedicated Reporting Functions:\n\ndim(): Number of rows, columns, and layers.\nncell(): Total number of cells (pixels).\nres(): Spatial resolution.\next(): Spatial extent.\ncrs(): Coordinate reference system (CRS).\ninMemory(): Checks if data is stored in memory or on disk.\nsources: Shows file location.\n\nAccessing Full Function List:\n\nRun help(\"terra-package\") to see all available terra functions.\n\n\n\n\n2.3.3 Basic Map-Making\n\nPlotting with terra:\n\nThe terra package offers a simple way to create basic visualizations using the plot() function, specifically designed for SpatRaster objects.\n\n\n\n\nCode\nplot(my_rast)\n\n\n\n\n\n\n\n\nFigure 4: An example raster data displayed with {terra} using plot()\n\n\n\n\n\n\nAdvanced Plotting Options:\n\nplotRGB(): A specialized function in terra for creating color composite plots using three layers (e.g., red, green, blue bands) from a SpatRaster object.\ntmap Package (Tennekes 2018): Useful for creating both static and interactive maps for raster and vector data.\nrasterVis Package (2023): Includes functions such as levelplot() to create advanced visualizations, including faceted plots for displaying changes over time.\n\n\n\n\n2.3.4 Raster Classes\n\nThe SpatRaster class in terra represents raster objects. Rasters are commonly created by reading a file using rast()\n\nterra supports reading various formats via GDAL, only loading the header and a file pointer into RAM.\n\nCreating Rasters from Scratch: Use rast() to make new raster objects:\n\nFills values row-wise from the top left corner.\nResolution depends on rows, columns, and extent; defaults to degrees (WGS84 CRS).\n\n\n\n\nCode\n# Create a new SpatRaster object: a checkerboard design\nnew_raster = rast(nrows = 50, ncols = 50, \n                  xmin = 0, xmax = 50, \n                  ymin = 0, ymax = 50,\n                  vals = rep(c(1, 0.25, 0.75, 0.5), \n                             times = 12)) \n\n\n# Plot the new raster\nplot(new_raster, \n     col = c(\"darkblue\", \n             \"white\",\n             \"blue\",\n             \"lightblue\"), # Use blue and white for the design\n     axes = TRUE, \n     box = FALSE)\n\n\n\n\n\n\n\n\nFigure 5: Creating a new raster from scratch\n\n\n\n\n\n\nHandling Multi-Layer Rasters:\n\nSpatRaster supports multi-layer rasters, such as satellite or time-series data:\n\nUse nlyr() to get the number of layers:\nAccess layers with [[ or $.\nUse subset() for layer extraction:\n\n\nCombining Raster Layers:\n\nMerge SpatRaster layers using c():\n\nSaving SpatRaster Objects:\n\nSince they often point to files, direct saving to .rds or .rda isn’t feasible.\nSolutions:\n\nwrap(): Creates a temporary object for saving or cluster use.\nwriteRaster(): Saves as a regular raster file."
  },
  {
    "objectID": "book_solutions/chapter2.html#coordinate-reference-systems",
    "href": "book_solutions/chapter2.html#coordinate-reference-systems",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.4 Coordinate Reference Systems",
    "text": "2.4 Coordinate Reference Systems\n\nCRSs (Coordinate Reference Systems) are essential for spatial data, defining how spatial elements correspond to the Earth’s surface (or other celestial bodies).\nTypes of CRSs:\n\nGeographic CRSs:\n\nRepresent data on a three-dimensional surface (e.g., latitude and longitude).\nCoordinate units are typically degrees.\n\nProjected CRSs:\n\nRepresent data on a two-dimensional, flat plane.\nTransform spherical Earth data into a flat map.\nCoordinate units can be in meters, feet, etc.\n\n\n\n\n2.4.1 Geographic Coordinate Reference Systems\n\nGeographic CRSs use longitude and latitude to identify locations on Earth.\n\nLongitude: Measures East-West position relative to the Prime Meridian.\nLatitude: Measures North-South position relative to the equatorial plane.\nDistances are measured in angular units (degrees), not meters, impacting spatial measurements (explored further in Section 7).\n\nThe Earth can be modeled as spherical or ellipsoidal.\n\nSpherical models: Simplify calculations by assuming Earth is a perfect sphere.\nEllipsoidal models: More accurately represent Earth with distinct equatorial and polar radii. The equatorial radius is about 11.5 km longer than the polar radius due to Earth’s compression.\n\nDatum refers to the model describing the relationship between coordinate values and actual locations on Earth. A datum consists of:\n\nEllipsoid: An idealized mathematical model of the Earth’s shape, which helps to approximate the Earth’s surface.\nOrigin Point: A fixed starting point for the coordinate system, where the ellipsoid is anchored to Earth.\nOffset and Orientation: How the ellipsoid is aligned with respect to the actual shape of the Earth.\n\n\n\n\nThe two types of Datums are: —\n\nGeocentric datum (e.g., WGS84): Centered at Earth’s center of gravity, providing global consistency but less local accuracy.\nLocal datum (e.g., NAD83): Adjusted for specific regions to better align with the Earth’s surface, accounting for local geographic variations (e.g., mountain ranges).\n\n\n\n\n2.4.2 Projected Coordinate Reference Systems\n\nProjected CRSs are based on geographic CRSs and use map projections to represent Earth’s three-dimensional surface in Easting and Northing (x and y) values. These CRSs rely on Cartesian coordinates on a flat surface, with an origin and linear units (e.g., meters).\nDeformations:\n\nThe conversion from 3D to 2D inherently introduces distortions. Projected CRSs can only preserve one or two of the following properties:\n\nArea: Preserved in equal-area projections.\nDirection: Preserved in azimuthal projections.\nDistance: Preserved in equidistant projections.\nShape: Preserved in conformal projections.\n\n\n\n\n\nTypes of Projections and Their Characteristics\n\n\n\n\n\n\n\n\n\nType of Projection\nDescription\nCommon Properties Preserved\nBest Used For\n\n\n\n\nConic\nProjects Earth’s surface onto a cone.\nArea, shape\nMaps of mid-latitude regions\n\n\nCylindrical\nProjects Earth’s surface onto a cylinder.\nDirection, shape\nWorld maps\n\n\nPlanar (Azimuthal)\nProjects onto a flat surface at a point or line.\nDistance, direction\nPolar region maps\n\n\n\n\n\nDeformations by Projection Type\n\n\n\n\n\n\n\n\nProperty\nDefinition\nProjection Type That Preserves It\n\n\n\n\nArea\nThe relative size of regions is maintained.\nEqual-area projections (e.g., Albers)\n\n\nDirection\nBearings from the center are accurate.\nAzimuthal projections (e.g., Lambert)\n\n\nDistance\nCorrect distances are preserved along specific lines or from specific points.\nEquidistant projections (e.g., Equirectangular)\n\n\nShape\nLocal angles and shapes are maintained, though areas are distorted.\nConformal projections (e.g., Mercator)\n\n\n\n\nUse the Map Projection Explorer for details.\nUse st_crs() for querying CRSs in sf objects and crs() for terra objects.\n\n\n\nCode\nsf_proj_info(type = \"proj\") |&gt; \n  as_tibble() |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 1: A list of the available projections supported by the PROJ library"
  },
  {
    "objectID": "book_solutions/chapter2.html#units",
    "href": "book_solutions/chapter2.html#units",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.5 Units",
    "text": "2.5 Units\n\nCRSs include spatial units information, which is crucial for accurately interpreting distance and area.\nCartographic best practices suggest adding scale indicators on maps to show the relationship between map and ground distances.\nUnits in sf Objects:\n\nsf objects natively support units for geometric data, ensuring outputs from functions like st_area() come with a units attribute.\nThis feature, supported by the units package, avoids confusion across different CRSs, which may use meters, feet, etc.\nTo convert units, use units::set_units()\n\nUnits in Raster Data:\n\nUnlike sf, raster packages do not natively support units.\nUsers should be cautious when working with raster data to convert units properly.\nAn example to calculate the area of India in square meters and then, square kilometres\n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(units)\n\n# Calculate the area of India in square meters\nindia_area &lt;- rnaturalearth::ne_countries() |&gt; \n  filter(admin == \"India\") |&gt; \n  st_area()\nindia_area\n\n3.150428e+12 [m^2]\n\n# Convert area to square kilometers\nprint(paste(\"Area of India in square kilometers:\", format(set_units(india_area, km^2))))\n\n[1] \"Area of India in square kilometers: 3150428 [km^2]\"\n\n# Convert area to hectares\nprint(paste(\"Area of India in hectares:\", format(set_units(india_area, ha))))\n\n[1] \"Area of India in hectares: 315042827 [ha]\"\n\n# Convert area to acres\nprint(paste(\"Area of India in acres:\", format(set_units(india_area, acre))))\n\n[1] \"Area of India in acres: 778484666 [acre]\""
  },
  {
    "objectID": "book_solutions/chapter2.html#exercises",
    "href": "book_solutions/chapter2.html#exercises",
    "title": "Chapter 2: Geographic data in R",
    "section": "2.6 Exercises",
    "text": "2.6 Exercises\n\n\nE1\nUsing summary() on the geometry column of the world data object in the spData package provides valuable information about the spatial characteristics of the dataset:\n\nGeometry Type:\n\nThe output will indicate the type of geometries present in the world data object. Here, it is MULTIPOLYGON suggesting that the dataset represents the outlines of countries or regions in MULTIPLOYGON formats.\n\nNumber of Countries:\n\nThe summary will show the number of geometries or features present, which corresponds to the number of countries or regions represented in the world dataset. Here, it is 177 countries.\n\nCoordinate Reference System (CRS):\n\nThe output will include details about the CRS, and in the present case it is EPSG:4326.\n\n\n\nsummary((spData::world$geom))\n\n MULTIPOLYGON     epsg:4326 +proj=long... \n          177             0             0 \n\n\n\n\n\nE2\nTo generate the world map, you can run the following code (as shown in Section 2.2.3):\n\nCode\nlibrary(spData)\nplot(world[3:6])\nplot(world[\"pop\"])\n\n\n\n\n\n\n\n\n\n\nFigure 6: Reproducing Figure 2.4 of the book\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Reproducing Figure 2.4 of the book\n\n\n\n\n\n\n\nSimilarities:\n\nThe map displays country boundaries and highlights the global population distribution as shown in the book.\nThe color scale representing population data is consistent with that described in the book, with larger populations shown with more intense colors.\n\nDifferences:\n\nThe aspect ratio or positioning of the map might vary depending on your screen resolution and window size.\nThe color theme and legend display may differ if your R setup or graphic device uses default settings different from those in the book.\n\ncex Argument: This parameter controls the size of plotting symbols in R. It is a numeric value that acts as a multiplier for the default size of symbols.\n\nSetting cex to values larger than 1 enlarges symbols, while values less than 1 shrink them.\n\nReason for cex = sqrt(world$pop) / 10000 : The code sets cex to sqrt(world$pop) / 10000 to scale the size of the points on the map in proportion to the population of each country. This square root transformation is used to moderate the variation in symbol sizes because population values can vary significantly between countries. Dividing by 10,000 helps to reduce the symbol size to a reasonable range for plotting.\n\nOther Ideas: —\n\nBubble Plot: Overlay a bubble plot on the map with points sized by population.\n\n\n\nCode\nplot(world[\"pop\"])\npoints(st_coordinates(st_centroid(world$geom)), \n       cex = sqrt(world$pop) / 5000, \n       col = \"red\", pch = 19)\n\n\n\n\n\n\n\n\n\n\nChoropleth Map: Use color gradients to represent population density.\n\n\n\nCode\nlibrary(tmap)\ntm_shape(world) +\n  tm_polygons(\"pop\", style = \"jenks\", \n              palette = \"Blues\", \n              title = \"Population\")\n\n\n\n\n\n\n\n\n\n\nLog Transformation: Visualize population using a log scale for better differentiation.\n\n\n\nCode\nworld$log_pop = log10(world$pop + 1)\nplot(world[\"log_pop\"])\n\n\n\n\n\n\n\n\n\n\n\n\nE3\nTo create a map of Nigeria in context and customize it using the plot() function, you can follow these steps:\nStep 1: Load Necessary Libraries and Data: Make sure you have the spData package loaded and access to the world spatial data.\nStep 2: Plotting Nigeria in Context: You can plot Nigeria by subsetting the world data and adjusting parameters such as lwd (line width), col (color), and expandBB (expanding the bounding box). Here’s an example code snippet:\nStep 3: Annotating the Map: To annotate the map with text labels, you can use the text() function. Here’s an example where we add the name of Nigeria and its capital, Abuja:\nStep 4: Exploring the text() Documentation\n\nlwd: This argument controls the line width for the borders of the countries.\ncol: This argument sets the fill color for the countries. You can customize it based on your preference.\nexpandBB: This argument expands the bounding box of the plot, which can help visualize nearby areas more clearly.\n\n\n\n\nE4\nTo create an empty SpatRaster object with 10 columns and 10 rows, assign random values between 0 and 10, and then plot it, you can use the terra package in R. Here’s how you can do it:\n\n\nCode\nlibrary(terra)\n\n# Create an empty SpatRaster object with 10 columns and 10 rows\nmy_raster &lt;- rast(nrows = 10, ncols = 10)\n\n# Assign random values between 0 and 10\nvalues(my_raster) &lt;- runif(ncell(my_raster), min = 0, max = 10)\n\n# Plot the raster\nplot(my_raster, main = \"Random Values Raster\")\n\n\n\n\n\n\n\n\n\n\n\n\nE5\nTo read in the raster/nlcd.tif file from the spDataLarge package and examine its properties, you can follow these steps in R:\n\nlibrary(spDataLarge)\nlibrary(terra)\n\n# Read the raster file\nnlcd_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\nInformation You Can Obtain: —\n\nBasic Properties: The print(nlcd_raster) command will provide you with information about the raster, including its dimensions, number of layers, and type of data.\n\n# Check the basic properties of the raster\nprint(nlcd_raster)\n\nclass       : SpatRaster \ndimensions  : 1359, 1073, 1  (nrow, ncol, nlyr)\nresolution  : 31.5303, 31.52466  (x, y)\nextent      : 301903.3, 335735.4, 4111244, 4154086  (xmin, xmax, ymin, ymax)\ncoord. ref. : NAD83 / UTM zone 12N (EPSG:26912) \nsource      : nlcd.tif \ncolor table : 1 \ncategories  : levels \nname        :   levels \nmin value   :    Water \nmax value   : Wetlands \n\n\nSummary Statistics: The summary(nlcd_raster) function will give you basic statistics about the raster values, such as minimum, maximum, and mean values. In this case, it tells the number of cells with Forest, Shrubland, Barren, Developed, Cultivated, Wetlands and Other land-use types.\n\n# Get summary statistics\nsummary(nlcd_raster)\n\n        levels     \n Forest    :52620  \n Shrubland :37463  \n Barren    : 7290  \n Developed : 1203  \n Cultivated:  596  \n Wetlands  :  443  \n (Other)   :  421  \n\n\nExtent: The ext(nlcd_raster) command will provide the geographical extent of the raster, showing the minimum and maximum x and y coordinates.\n\n# Check the extent of the raster\next(nlcd_raster)\n\nSpatExtent : 301903.344386758, 335735.354381954, 4111244.46098842, 4154086.47216415 (xmin, xmax, ymin, ymax)\n\n\nRows and Columns: You can find the number of rows and columns in the raster using nrow(nlcd_raster) and ncol(nlcd_raster).\n\n# Get the number of rows and columns\nnrow(nlcd_raster)\n\n[1] 1359\n\nncol(nlcd_raster)\n\n[1] 1073\n\n\nCoordinate Reference System (CRS): The crs(nlcd_raster) command will return the CRS of the raster, which is essential for spatial analyses.\n\n# Get the coordinate reference system (CRS)\nstr_view(crs(nlcd_raster))\n\n[1] │ PROJCRS[\"NAD83 / UTM zone 12N\",\n    │     BASEGEOGCRS[\"NAD83\",\n    │         DATUM[\"North American Datum 1983\",\n    │             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n    │                 LENGTHUNIT[\"metre\",1]]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433]],\n    │         ID[\"EPSG\",4269]],\n    │     CONVERSION[\"UTM zone 12N\",\n    │         METHOD[\"Transverse Mercator\",\n    │             ID[\"EPSG\",9807]],\n    │         PARAMETER[\"Latitude of natural origin\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8801]],\n    │         PARAMETER[\"Longitude of natural origin\",-111,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8802]],\n    │         PARAMETER[\"Scale factor at natural origin\",0.9996,\n    │             SCALEUNIT[\"unity\",1],\n    │             ID[\"EPSG\",8805]],\n    │         PARAMETER[\"False easting\",500000,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8806]],\n    │         PARAMETER[\"False northing\",0,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8807]]],\n    │     CS[Cartesian,2],\n    │         AXIS[\"(E)\",east,\n    │             ORDER[1],\n    │             LENGTHUNIT[\"metre\",1]],\n    │         AXIS[\"(N)\",north,\n    │             ORDER[2],\n    │             LENGTHUNIT[\"metre\",1]],\n    │     USAGE[\n    │         SCOPE[\"Engineering survey, topographic mapping.\"],\n    │         AREA[\"North America - between 114°W and 108°W - onshore and offshore. Canada - Alberta; Northwest Territories; Nunavut; Saskatchewan. United States (USA) - Arizona; Colorado; Idaho; Montana; New Mexico; Utah; Wyoming.\"],\n    │         BBOX[31.33,-114,84,-108]],\n    │     ID[\"EPSG\",26912]]\n\n\nResolution: You can check the resolution of the raster with the res(nlcd_raster) function, which will indicate the size of each pixel.\n\n# Check the resolution of the raster\nres(nlcd_raster)\n\n[1] 31.53030 31.52466\n\n\nValues: The values(nlcd_raster) command allows you to access the actual values contained in the raster. Here, I am printing only the first few values.\n\n# Get the values of the raster\nvalues(nlcd_raster) |&gt; head()\n\n     levels\n[1,]      4\n[2,]      4\n[3,]      5\n[4,]      4\n[5,]      4\n[6,]      4\n\n\n\n\n\n\nE6\nTo check the Coordinate Reference System (CRS) of the raster/nlcd.tif file from the spDataLarge package, you can use the following steps in R. The CRS provides essential information about how the spatial data is projected on the Earth’s surface.\n\nlibrary(spDataLarge)\nlibrary(terra)\n\n# Read the raster file\nnlcd_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\n# Check the coordinate reference system (CRS)\nnlcd_crs &lt;- crs(nlcd_raster)\nnlcd_crs |&gt; str_view()\n\n[1] │ PROJCRS[\"NAD83 / UTM zone 12N\",\n    │     BASEGEOGCRS[\"NAD83\",\n    │         DATUM[\"North American Datum 1983\",\n    │             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n    │                 LENGTHUNIT[\"metre\",1]]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433]],\n    │         ID[\"EPSG\",4269]],\n    │     CONVERSION[\"UTM zone 12N\",\n    │         METHOD[\"Transverse Mercator\",\n    │             ID[\"EPSG\",9807]],\n    │         PARAMETER[\"Latitude of natural origin\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8801]],\n    │         PARAMETER[\"Longitude of natural origin\",-111,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8802]],\n    │         PARAMETER[\"Scale factor at natural origin\",0.9996,\n    │             SCALEUNIT[\"unity\",1],\n    │             ID[\"EPSG\",8805]],\n    │         PARAMETER[\"False easting\",500000,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8806]],\n    │         PARAMETER[\"False northing\",0,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8807]]],\n    │     CS[Cartesian,2],\n    │         AXIS[\"(E)\",east,\n    │             ORDER[1],\n    │             LENGTHUNIT[\"metre\",1]],\n    │         AXIS[\"(N)\",north,\n    │             ORDER[2],\n    │             LENGTHUNIT[\"metre\",1]],\n    │     USAGE[\n    │         SCOPE[\"Engineering survey, topographic mapping.\"],\n    │         AREA[\"North America - between 114°W and 108°W - onshore and offshore. Canada - Alberta; Northwest Territories; Nunavut; Saskatchewan. United States (USA) - Arizona; Colorado; Idaho; Montana; New Mexico; Utah; Wyoming.\"],\n    │         BBOX[31.33,-114,84,-108]],\n    │     ID[\"EPSG\",26912]]\n\n\nUnderstanding the CRS Information: —\nThe output from the crs(nlcd_raster) command will typically include details such as:\n\nProjection Type: Indicates whether the CRS is geographic (latitude and longitude) or projected (a flat representation). Here, it is North American NAD83 / UTM Zone 12 N\nDatum: Information about the geodetic datum used, which is crucial for accurately locating points on the Earth’s surface. Here, it is North American Datum 1983.\nCoordinate Units: Specifies the units of measurement used for the coordinates, such as degrees (for geographic CRSs) or meters (for projected CRSs). Here, it is in metres, as shown in:\nLENGTHUNIT[\"metre\",1]\nEPSG Code: If applicable, the output might include an EPSG code, which is a standardized reference number for a specific CRS. This code can be used to look up more detailed information about the CRS. Here, it is: —\nID[\"EPSG\",26912]\nTransformation Parameters: If it’s a projected CRS, the output may include parameters related to the projection method, such as central meridian, standard parallels, and false easting/northing. Here, they are: —\n|         PRIMEM[\"Greenwich\",0,     \n│             ANGLEUNIT[\"degree\",0.0174532925199433]],     \n│         ID[\"EPSG\",4269]], \n|\n|\n│     CONVERSION[\"UTM zone 12N\",     \n│         METHOD[\"Transverse Mercator\",     \n│             ID[\"EPSG\",9807]],     \n│         PARAMETER[\"Latitude of natural origin\",0,     \n│             ANGLEUNIT[\"degree\",0.0174532925199433],     \n│             ID[\"EPSG\",8801]],     \n│         PARAMETER[\"Longitude of natural origin\",-111,     \n|             ANGLEUNIT[\"degree\",0.0174532925199433],     \n│             ID[\"EPSG\",8802]],     \n│         PARAMETER[\"Scale factor at natural origin\",0.9996,\n│             SCALEUNIT[\"unity\",1],     \n│             ID[\"EPSG\",8805]],     \n│         PARAMETER[\"False easting\",500000,     \n│             LENGTHUNIT[\"metre\",1],     \n│             ID[\"EPSG\",8806]],     \n│         PARAMETER[\"False northing\",0,     \n│             LENGTHUNIT[\"metre\",1],     \n│             ID[\"EPSG\",8807]]],"
  },
  {
    "objectID": "book_solutions.html",
    "href": "book_solutions.html",
    "title": "Book Solutions",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nJan 19, 2025\n\n\nChapter 8: Geographic data I/O\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 8 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nJan 10, 2025\n\n\nChapter 7: Reprojecting geographic data\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 7 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nDec 27, 2024\n\n\nChapter 6: Raster-vector interactions\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 6 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nDec 16, 2024\n\n\nChapter 5: Geometry operations\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 4 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nNov 16, 2024\n\n\nChapter 4: Spatial data operations\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 4 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nNov 8, 2024\n\n\nChapter 3: Attribute data operations\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 3 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nNov 3, 2024\n\n\nChapter 2: Geographic data in R\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 2 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "book_solutions/chapter3.html",
    "href": "book_solutions/chapter3.html",
    "title": "Chapter 3: Attribute data operations",
    "section": "",
    "text": "sf for vector data manipulation (link)\nterra for raster data manipulation (link)\ndplyr for data frame operations (link)\nspData for example datasets (link)"
  },
  {
    "objectID": "book_solutions/chapter3.html#introduction",
    "href": "book_solutions/chapter3.html#introduction",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\n\nAttribute Data: Non-spatial info tied to geographic data (e.g., bus stop name or elevation).\n\nVector Example: A bus stop’s location as POINT (-0.098 51.495) with attributes like its name.\nRaster Example: Pixel values represent attributes (e.g., elevation); location defined by matrix indices and resolution.\n\nChapter Focus:\n\nManipulating geographic objects using attributes (e.g., names, elevations).\nTechniques: subsetting, aggregation, joining data, creating new variables.\nVector and raster data operations are similar and interchangeable (e.g., subsetting, spatial joins).\n\n\n\n\nCode\nlibrary(sf)        # Handling Simple Features in R\nlibrary(terra)     # Handling Rasters in R\nlibrary(tidyverse) # Data Wrangling\n\nlibrary(spData)    # Spatial Data-sets"
  },
  {
    "objectID": "book_solutions/chapter3.html#vector-attribute-manipulation",
    "href": "book_solutions/chapter3.html#vector-attribute-manipulation",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.2 Vector Attribute Manipulation",
    "text": "3.2 Vector Attribute Manipulation\n\nsf Package:\n\nExtends base R’s data.frame with a geometry column (sfc class) for spatial features (points, lines, polygons).\nGeometry column often named geometry or geom, but customizable.\n\nManipulation Methods:\n\n\nCode\nmethods(class = \"sf\") |&gt; \n  as_tibble() |&gt;\n  rename(methods = x) |&gt; \n  mutate(methods = str_replace_all(methods, \",sf\", \"  \")) |&gt; \n  mutate(methods = str_replace_all(methods, \".sf\", \"  \")) |&gt; \n  gt::gt() |&gt; \n  gt::tab_header(\n    title = \"Methods available\"\n  ) |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 1: Methods available for the class ‘sf’ in R using {sf} package\n\n\n\n\n\n\nMethods available\n\n\n\n\n\n\n\n\n\n\n\nMethods like aggregate(), cbind(), merge(), and rbind() work seamlessly with sf objects.\nCompatible with tidyverse functions (dplyr, tidyr) and can be used with data.table (partial compatibility noted in issue #2273).\nDropping geometry (st_drop_geometry()) can speed up attribute data operations when spatial data is not required.\n\n\n# Original 'world' dataset\ndim(world)\n## [1] 177  11\nclass(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Dropping the geometry column: Effects\nst_drop_geometry(world) |&gt; \n  dim()\n## [1] 177  10\nst_drop_geometry(world) |&gt; \n  class()\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nAdvantages:\n\nsf’s integration with the tidyverse allows robust, efficient data manipulation.\nCompatible with tidyverse functions (e.g., dplyr), making it versatile for data analysis.\n\n\n\n\n\n\n\n\nRelevant Topic\n\n\n\nMajor Pitfalls of Using Spatial Data with the Tidyverse\n\nName Clashes\n\nFunctions like select() from dplyr can mask similar functions from the raster package.\nUse fully qualified names (e.g., dplyr::select()) to avoid conflicts.\n\nCompatibility Issues with sp Package\n\nThe older sp package does not integrate well with tidyverse functions.\nRequires conversion between sp to sf object types using functions like st_as_sf().\n\nHandling Multipolygon Objects\n\nMultiple geometries in objects can cause unexpected plotting results.\nResolve issues by casting to simpler geometry types using st_cast(to = \"POLYGON\").\n\nSpatial Subsetting Challenges\n\nVerbose syntax when using tidyverse functions like filter() with spatial predicates like st_intersects().\nMay result in altered row names, complicating joins and comparisons.\nOther option is spatial subsetting using base R\n\nlnd_buff = lnd[1, ] %&gt;% \n  st_transform(crs = 27700) %&gt;%  # uk CRS\n  st_buffer(500000) %&gt;%\n  st_transform(crs = 4326)\nnear_lnd = world[lnd_buff, ]\nworld_poly = world %&gt;% \n  st_cast(to = \"POLYGON\")\nnear_lnd_new = world_poly[lnd_buff, ]\nnear_lnd_tidy = world %&gt;% \n  filter(st_intersects(., lnd_buff, sparse = FALSE))\n\n\nRow Name Alterations\n\nTidyverse operations may drop or alter row names, affecting joins and comparisons. See related discussion in tidyverse/dplyr#366.\n\nAttribute Alteration Pitfall\n\nResults from tidyverse functions may differ from base R operations due to row name discrepancies.\nExample functions: filter() vs base R subsetting ([]).\n\nIssues with bind_rows()\n\nbind_rows() fails on spatial objects; use alternatives like setting geometries to NULL with st_set_geometry() before combining.\n\nLimited Raster Data Support\n\nTidyverse integration with raster data is minimal.\nInitial efforts like tabularaster, sfraster, and stars aim to enhance support.\n\n\n\n\n\n3.2.1 Vector Attribute Sub-setting\n\nBase R Sub-setting:\n\nUses [ operator and subset() function for rows and columns selection.\nSyntax: object[i, j] returns rows indexed by i and columns by j.\n\ndplyr Sub-setting Functions:\n\nfilter() and slice() for rows, select() for columns.\nselect(): Subsets columns by name or position.\nHelper functions in select() like contains(), starts_with(), num_range().\n\nExtracting a Single Column:\n\nUse pull() (dplyr), $, or [[ (base R).\n\nRow Selection:\n\nslice(): Selects rows by index.\nfilter(): Filters rows based on conditions.\n\nComparison Operators:\n\nStandard operators can be used in filter(): &lt;, &gt;, &lt;=, &gt;=, ==, !=.\n\n\nThe dplyr functions (filter(), select(), pull()) are intuitive and integrate well with the tidyverse workflows.\n\n\n3.2.2 Chaining Commands with Pipes\n\nPipe Operator:\n\n%&gt;% (from the magrittr package) and native |&gt; (from R 4.1.0 onwards) enable chaining commands, improving readability and flow of code.\nThe output of one function becomes the input of the next.\nAlternative: Nested Function Calls: The same operation without pipes uses nested functions, which is harder to read.\n\nSplitting into Multiple Lines:\n\nUseful for debugging and inspecting intermediate results but can clutter the environment.\n\nKey Packages:\n\ndplyr: Provides verbs like filter(), select(), slice(), and supports pipe workflows.\nmagrittr: Provides %&gt;% operator for chaining functions.\n\n\n\n\n3.2.3 Vector Attribute Aggregation\n\nAggregation is summarizing data using one or more grouping variables, often leading to a smaller dataset. It is useful for data reduction, especially when working with large datasets.\nBase R Approach\n\nUsing aggregate():\n\naggregate() groups data and applies a function (e.g., sum). Result: A non-spatial data frame with two columns (continent, pop).\n\nUsing aggregate.sf():\n\nFor spatial objects (sf), use aggregate() with by argument. This results in an sf object with eight features representing continents.\n\n\ndplyr Approach\n\nUsing group_by() and summarize():\n\nEquivalent to aggregate(), but offers flexibility and control:\n\ngroup_by() defines grouping variables.\nsummarize() applies aggregation functions.\n\n\n\n\n\n\nCode\nlibrary(dplyr)\nworld |&gt;\n  group_by(continent) |&gt;\n  summarize(pop = sum(pop, na.rm = TRUE))\n\n\nSimple feature collection with 8 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n# A tibble: 8 × 3\n  continent                      pop                                        geom\n  &lt;chr&gt;                        &lt;dbl&gt;                              &lt;GEOMETRY [°]&gt;\n1 Africa                  1154946633 MULTIPOLYGON (((36.86623 22, 36.69069 22.2…\n2 Antarctica                       0 MULTIPOLYGON (((-180 -89.9, 180 -89.9, 180…\n3 Asia                    4311408059 MULTIPOLYGON (((36.14976 35.82153, 35.9050…\n4 Europe                   669036256 MULTIPOLYGON (((26.29 35.29999, 25.74502 3…\n5 North America            565028684 MULTIPOLYGON (((-82.26815 23.18861, -82.51…\n6 Oceania                   37757833 MULTIPOLYGON (((166.7932 -15.66881, 167.00…\n7 Seven seas (open ocean)          0 POLYGON ((68.935 -48.625, 68.8675 -48.83, …\n8 South America            412060811 MULTIPOLYGON (((-66.95992 -54.89681, -66.4…\n\n\n\nMore details on grouped data and summarize() from the dplyr package vignettes.\n\n\n\n\n\n\n\nRelevant Topic\n\n\n\ndplyr functions are highly effective when applied to grouped data frames (grouped_df objects). Here are the main points covered:\n\nGrouping Data: Use group_by() to create groups within a data frame based on one or more variables.\n\nTo count rows in each group, use tally().\n\nAccessing Group Metadata:\n\ngroup_keys(): Shows underlying group data. Details here.\ngroup_vars(): Retrieves names of the grouping variables. Details here.\n\nModifying Groups:\n\nTo overwrite or add grouping variables, use .add = TRUE with group_by(). Read more.\nTo remove groups, use ungroup().\n\nVerbs and Grouping:\n\nsummarise(): Computes summary statistics per group. The .groups argument controls grouping structure. More on summarise().\n\nColumn Manipulation:\n\nselect() retains grouping variables by default. More on select().\nrename() and relocate() function the same way for grouped and ungrouped data. Details here.\n\nSorting Groups:\n\narrange(): Sorts data, with .by_group = TRUE option to sort within groups. More on arrange().\n\n\n\n\n\nCheck out Chapter 5 of R for Data Science.\n\n\n\n3.2.4 Vector Attribute Joining\n\nJoining involves combining tables based on a shared key variable. In R, dplyr functions like left_join() and inner_join() are commonly used for this purpose.\n\nThe join functions in dplyr (left_join, inner_join, etc.) follow conventions from SQL, allowing easy and consistent data merging.\nThese functions work similarly for both non-spatial (data.frame) and spatial (sf) objects. The geometry list column in sf objects is the key difference.\n\nWhen merging an sf object with a data.frame\n\nThe resulting object remains an sf object, keeping its spatial features intact while adding new columns for coffee production.\n\nHandling Key Variables:\n\nIf datasets have key variables with matching names (e.g., name_long), joining works automatically.\nIf the key variables differ, either:\n\nRename the variable to match, or\nUse the by argument to specify the joining variables explicitly.\n\n\nInner Joins:\n\nAn inner join keeps only the rows with matching key variables in both datasets. This reduces the number of rows, depending on the overlap in key variables.\n\nTroubleshooting Joins:\n\nIf some rows are missing in the result (e.g., due to differing key names like “Congo, Dem. Rep. of”), identify mismatches using setdiff().\nUse regex matching from the stringr package to identify correct key names for adjustments.\n\nReversing Joins:\n\nYou can also join starting with a non-spatial dataset and adding spatial variables from an sf object.\nThe result will be a non-spatial data.frame (tibble), unless explicitly converted to an sf object using st_as_sf().\n\nFurther Resources:\n\nChapter 13 on Relational Data in R for Data Science by Grolemund and Wickham (2016)\nThe documentation describing joins with data.table package.\nThe join vignette in the geocompkg package, which is summarized below: —\n\n\n\n\n\n\n\n\nRelevant Topic\n\n\n\nSpatial Joins Extended\n\nSpatial Joins: Combines attributes from different datasets based on a common key, useful for integrating non-spatial (attribute) data with spatial data.\n\n\nLeft Join\n\nAdds attributes to all observations from the left dataset with matched values from the right.\n\n\n\nJoining by Different Column Names\n\nCase: If key columns have different names, use a named vector to specify the keys\nIssue: Duplicate columns (e.g., tbl_1_var.x and tbl_2_var.y). Resolved by specifying all keys.\n\n\n\nJoining with a Non-Spatial First Argument\n\nDropping Geometry: st_drop_geometry() removes spatial attributes, allowing joins with standard data frames.\n\n\n\nInner Join\n\nKeeps only rows with matching keys in both datasets.\n\n\n\n\n\n\n3.2.5 Creating attributes and removing spatial information\n\nCreating new attributes:\n\nCalculate a new attribute using mutate() from dplyr. Example: population / area.\nUse mutate() to add the new column without overwriting the geometry column.\n\nCombining columns:\n\nUse unite() from tidyr to merge two or more columns into one (e.g., continent and region_un).\nunite() allows setting a separator (e.g., :) and can optionally remove the original columns.\n\nSplitting columns:\n\nUse separate_wider_position() and separate_wider_delim()from tidyr to split a combined column back into its original components.\n\nRenaming columns:\n\nUse rename() from dplyr for renaming specific columns.\nFor renaming all columns, use setNames() with a character vector for new names.\n\nRemoving geometry:\n\nUse st_drop_geometry() to drop the spatial information while retaining the attributes in a non-spatial data.frame. This method is preferred over manually selecting non-geometry columns as it avoids unintended issues."
  },
  {
    "objectID": "book_solutions/chapter3.html#manipulating-raster-objects",
    "href": "book_solutions/chapter3.html#manipulating-raster-objects",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.3 Manipulating Raster Objects",
    "text": "3.3 Manipulating Raster Objects\n\nRaster Data Model:\n\nRepresents continuous surfaces, unlike vector data which use discrete entities (points, lines, polygons).\nUseful for representing spatial phenomena like elevation, temperature, and land cover.\n\nCreating a Raster Object:\n\nUse rast() function to create raster objects.\nThe vals argument assigns numeric values to each cell.\n\nCategorical Raster Values:\n\nCan hold logical or factor (categorical) values.\nExample: Creating a raster for soil types (clay, silt, sand).\n\nRaster Attribute Table (RAT):\n\nStores additional information about raster values, accessible with cats().\nEach layer’s attribute data can be modified with levels().\n\nColor Table:\n\nCategorical rasters can store color information using a color table with RGB (Red, Green, Blue) or RGBA (Red, Green, Blue, Alpha) columns.\nUse coltab() to view or set color tables.\nSaving the raster (e.g., as GeoTIFF) includes the color table information.\n\n\n\n3.3.1 Raster subsetting\n\nRaster Subsetting:\n\nInvolves selecting specific parts of a raster dataset using the base R subsetting operator [ , ].\nSubsetting Methods:\n\nRow-Column Indexing: Accesses cells using specific row and column coordinates.\nCell IDs: Accesses cells using unique numeric identifiers for each raster cell.\nCoordinates and Spatial Objects: These methods are used for spatial subsetting, using another spatial object to subset a raster.\n\n\nExamples:\n\nAccessing the top-left pixel value using row-column indexing:\n\n\n\n\nCode\n# A simple raster\n  elev &lt;- rast(\n    nrows = 10, ncols = 10,\n    xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n    vals = 1:100\n    ) \n\n# A raster with categorical levels\ngrain &lt;- rast(\n  nrows = 10, ncols = 10,\n  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n  vals = sample(\n    x = c(\"Wheat\", \"Rice\", \"Maize\", \"Others\"),\n    size = 100,\n    replace = TRUE\n  )\n)\n\n    # Print the \"elev\" object to visualize the design\n    print(elev)\n## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 0.3, 0.3  (x, y)\n## extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n## source(s)   : memory\n## name        : lyr.1 \n## min value   :     1 \n## max value   :   100\n\n    # Plot the raster object to visualize the matrix as an image\n    plot(\n      elev, \n      main = \"Raster Object with a Sequential Pattern\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n\n    # Accessing using row number and column number\n    elev[1, 1]\n##   lyr.1\n## 1     1\n\n    elev[10,5]\n##   lyr.1\n## 1    95\n\n    plot(\n      grain,\n      main = \"Raster Object with 4 categorical levels\"\n    )\n\n\n\n\n\n\n\n\n\nCode\n\n    # Accessing using row number and column number\n\n    grain[1,1]\n##   lyr.1\n## 1  Rice\n\n    grain[10, 10]\n##    lyr.1\n## 1 Others\n\n    # A multilayered raster - combining both\n    two_layers &lt;- c(elev, grain)\n\n    print(two_layers)\n## class       : SpatRaster \n## dimensions  : 10, 10, 2  (nrow, ncol, nlyr)\n## resolution  : 0.3, 0.3  (x, y)\n## extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n## source(s)   : memory\n## names       : lyr.1, lyr.1 \n## min values  :     1, Maize \n## max values  :   100, Wheat\n    names(two_layers) &lt;- c(\"Continuous variable\", \n                           \"Categorical variable\")\n    plot(\n      two_layers\n    )\n\n\n\n\n\n\n\n\n\n\nAccessing the first cell using its Cell ID:\n\n\n\nCode\n# Accessing raster values using cell ID\nelev[1]\n##   lyr.1\n## 1     1\nelev[95]\n##   lyr.1\n## 1    95\n\n\n\nSubsetting Multi-layered Rasters:\n\nFor multi-layer raster objects (e.g., two_layers = c(grain, elev)), subsetting returns values from each layer:\n\n\n\ntwo_layers[1]\n\n  Continuous variable Categorical variable\n1                   1                 Rice\n\n\n\nTo extract all cell values from a raster:\n\n\n# Extracting all values - single layer raster\nelev[][1:10]  \n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# It is Equivalent to using the values() function\nvalues(elev)[1:10]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# Extracting all values - multi-layer raster\n# It returns a data.frame\nvalues(two_layers) |&gt; \n  as_tibble()\n\n# A tibble: 100 × 2\n   `Continuous variable` `Categorical variable`\n                   &lt;int&gt;                  &lt;int&gt;\n 1                     1                      3\n 2                     2                      3\n 3                     3                      3\n 4                     4                      2\n 5                     5                      1\n 6                     6                      1\n 7                     7                      3\n 8                     8                      3\n 9                     9                      1\n10                    10                      2\n# ℹ 90 more rows\n\n\n\nModifying Raster Values:\n\nChange specific cell values by combining subsetting with assignment:\n\n\n\nelev[5, 5] = 0  # Sets the value of the 1 central cells to 0\n\nplot(elev)\n\n\n\n\n\n\n\n\n\nModify multiple cells simultaneously:\n\n\nelev[5, c(5,6)] = 0  # Sets the value of the central 2 cells to 0\n\nplot(elev)\n\n\n\n\n\n\n\n\n\nReplacing Values in Multi-layered Rasters:\n\nModify cell values in a multi-layer raster using a matrix with corresponding layers and cell indices:\n\n\n\n# Assigns new values for Cell ID 1 in both layers\ntwo_layers[45] = cbind(c(1), c(4))  \n\nplot(two_layers)\n\n\n\n\n\n\n\n\nThis subsetting approach allows efficient extraction and manipulation of raster cell values, enabling the customization of raster datasets for specific analytical needs.\n\n\n3.3.2 Summarizing Raster Objects\n\nDescriptive Statistics:\n\nThe terra package provides functions for summarizing raster objects.\nPrinting a raster object directly shows the minimum and maximum values.\nThe summary() function provides detailed statistics:\n\nFor continuous rasters: Minimum, maximum, quartiles, and count of NAs.\nFor categorical rasters: Counts of each unique class.\n\n\n\n\nsummary(two_layers)\n##  Continuous.variable Categorical.variable\n##  Min.   :  1.00      Maize :18           \n##  1st Qu.: 24.75      Others:26           \n##  Median : 50.50      Rice  :31           \n##  Mean   : 50.06      Wheat :25           \n##  3rd Qu.: 75.25                          \n##  Max.   :100.00\n\n\nCustom Summary Statistics:\n\nThe global() function calculates additional statistics like standard deviation and can be used to apply custom summary statistics.\n\n\n\nglobal(two_layers, sum)\n\n                      sum\nContinuous variable  5006\nCategorical variable  263\n\nglobal(two_layers, mean)\n\n                      mean\nContinuous variable  50.06\nCategorical variable  2.63\n\n\n\nFrequency Table:\n\nThe freq() function generates a frequency table for categorical raster values, showing counts of each category.\n\n\n\n\nCode\nfreq(two_layers$`Categorical variable`) |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 2: Frequency table using freq() on raster objects\n\n\n\n\n\n\n\n\n\nlayer\nvalue\ncount\n\n\n\n\n1\nMaize\n18\n\n\n1\nOthers\n26\n\n\n1\nRice\n31\n\n\n1\nWheat\n25\n\n\n\n\n\n\n\n\n\n\n\nVisualization of Raster Statistics:\n\nSeveral functions like hist(), boxplot(), and density() work directly with raster objects to visualize statistics.\nIf visualization functions do not support raster objects, values can be extracted using values() for further plotting.\n\nHandling Function Name Clashes:\n\nSome functions (e.g., extract()) exist in multiple packages like terra and tidyr, leading to conflicts.\nTo avoid issues, call functions with full namespaces (e.g., tidyr::extract()).\n\nUse detach() to unload conflicting packages, but be cautious as it may impact dependent packages."
  },
  {
    "objectID": "book_solutions/chapter3.html#exercises",
    "href": "book_solutions/chapter3.html#exercises",
    "title": "Chapter 3: Attribute data operations",
    "section": "3.4 Exercises",
    "text": "3.4 Exercises\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(terra)\nlibrary(spData)\ndata(us_states)\ndata(us_states_df)\n\n\nE1\nCreate a new object called us_states_name that contains only the NAME column from the us_states object using either base R ([) or tidyverse (select()) syntax. What is the class of the new object and what makes it geographic?\n\nus_states_name &lt;- us_states |&gt; \n  select(NAME)\n\nclass(us_states_name)\n\n[1] \"sf\"         \"data.frame\"\n\n\nThe new object of the class sf, and the stickiness of the geometry column makes it a geographical dataset.\n\n\n\nE2\nSelect columns from the us_states object which contain population data. Obtain the same result using a different command (bonus: try to find three ways of obtaining the same result). Hint: try to use helper functions, such as contains or matches from dplyr (see ?contains).\n\nus_states |&gt; \n  select(contains(\"pop\"))\n\nus_states |&gt; \n  select(where(is.double)) |&gt; \n  select(-AREA)\n\nus_states |&gt; \n  select(5:6)\n\nThe above three methods all select the columns total_pop_10 and total_pop_15 . Notice that the column geometry is sticky, and can be removed using st_drop_geometry().\n\n\n\nE3\nFind all states with the following characteristics (bonus: find and plot them):\n\nBelong to the Midwest region.\nThe code shown below gives out the names of all such states.\n\n\nus_states |&gt; \n  filter(REGION == \"Midwest\") |&gt; \n  pull(NAME) |&gt; \n  paste(collapse = \", \")\n\n[1] \"Indiana, Kansas, Minnesota, Missouri, North Dakota, South Dakota, Illinois, Iowa, Michigan, Nebraska, Ohio, Wisconsin\"\n\n\n\nBelong to the West region, have an area below 250,000 km2and in 2015 a population greater than 5,000,000 residents (hint: you may need to use the function units::set_units() or as.numeric()).\nOnly Washington State qualifies all three conditions. Code is shown below.\n\n\nus_states |&gt; \n  filter(REGION == \"West\") |&gt; \n  filter(total_pop_15 &gt; 5e6) |&gt; \n  filter(as.numeric(AREA) &lt; 250000)\n\nSimple feature collection with 1 feature and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 45.54774 xmax: -116.916 ymax: 49.00236\nGeodetic CRS:  NAD83\n  GEOID       NAME REGION          AREA total_pop_10 total_pop_15\n1    53 Washington   West 175436 [km^2]      6561297      6985464\n                        geometry\n1 MULTIPOLYGON (((-122.7699 4...\n\nus_states |&gt; \n  filter(REGION == \"West\") |&gt; \n  filter(total_pop_15 &gt; 5e6) |&gt; \n  filter(AREA &lt; units::set_units(250000, \"km2\"))\n\nSimple feature collection with 1 feature and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 45.54774 xmax: -116.916 ymax: 49.00236\nGeodetic CRS:  NAD83\n  GEOID       NAME REGION          AREA total_pop_10 total_pop_15\n1    53 Washington   West 175436 [km^2]      6561297      6985464\n                        geometry\n1 MULTIPOLYGON (((-122.7699 4...\n\n\n\nBelong to the South region, had an area larger than 150,000 km2 and a total population in 2015 larger than 7,000,000 residents.\nThe states that fulfil these conditions are Florida, Georgia and Texas.\n\n\n\nCode\nus_states |&gt; \n  filter(REGION == \"South\") |&gt; \n  filter(AREA &gt; units::set_units(150000, \"km2\")) |&gt; \n  filter(total_pop_15 &gt; 7e6) |&gt; \n  pull(NAME)\n\n\n[1] \"Florida\" \"Georgia\" \"Texas\"  \n\n\n\n\n\nE4\nWhat was the total population in 2015 in the us_states dataset? What was the minimum and maximum total population in 2015?\nThe total population in the us_states dataset in the year 2015 was 314,375,347. The minimum total population in 2015 was 579,679 (Wyoming), and the maximum total population was 38,421,464 (California).\n\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  summarise(\n    total_pop_15 = sum(total_pop_15)\n  )\n## # A tibble: 1 × 1\n##   total_pop_15\n##          &lt;dbl&gt;\n## 1    314375347\n\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  slice_min(order_by = total_pop_15, n = 1)\n##   GEOID    NAME REGION            AREA total_pop_10 total_pop_15\n## 1    56 Wyoming   West 253309.6 [km^2]       545579       579679\n\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  slice_max(order_by = total_pop_15, n = 1)\n##   GEOID       NAME REGION            AREA total_pop_10 total_pop_15\n## 1    06 California   West 409747.1 [km^2]     36637290     38421464\n\n\n\n\nE5\nHow many states are there in each region?\nThe number of states in each region are shown in Table 3 below.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  count(REGION, name = \"Number of States\") |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 3: Table showing number of states in each region.\n\n\n\n\n\n\n\n\n\nREGION\nNumber of States\n\n\n\n\nNorteast\n9\n\n\nMidwest\n12\n\n\nSouth\n17\n\n\nWest\n11\n\n\n\n\n\n\n\n\n\n\n\n\n\nE6\nWhat was the minimum and maximum total population in 2015 in each region? What was the total population in 2015 in each region?\nThe minimum and maximum total population in 2015 in each region is shown in Table 4 (a). The total population in each region in 2015 is shown in Table 4 (b).\n\n\nCode\nus_states |&gt; \n  as_tibble() |&gt; \n  group_by(REGION) |&gt; \n  slice_min(order_by = total_pop_15, n = 1) |&gt; \n  select(REGION, NAME, total_pop_15) |&gt; \n  ungroup() |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    columns = total_pop_15,\n    decimals = 0\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_538()\nus_states |&gt; \n  as_tibble() |&gt; \n  group_by(REGION) |&gt; \n  summarise(\n    total_population_2015 = sum(total_pop_15)\n  ) |&gt; \n  select(REGION, total_population_2015) |&gt; \n  ungroup() |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    columns = total_population_2015,\n    decimals = 0\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 4: Region-wise total and minimum-maximum populations\n\n\n\n\n\n\n\n\n\n(a) Minimum and maximum populations, region-wise, in 2015\n\n\n\n\n\nRegion\nName\nTotal Pop 15\n\n\n\n\nNorteast\nVermont\n626,604\n\n\nMidwest\nNorth Dakota\n721,640\n\n\nSouth\nDistrict of Columbia\n647,484\n\n\nWest\nWyoming\n579,679\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Total population, region-wise, in 2015\n\n\n\n\n\nRegion\nTotal Population 2015\n\n\n\n\nNorteast\n55,989,520\n\n\nMidwest\n67,546,398\n\n\nSouth\n118,575,377\n\n\nWest\n72,264,052\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE7\nAdd variables from us_states_df to us_states, and create a new object called us_states_stats. What function did you use and why? Which variable is the key in both datasets? What is the class of the new object?\nThe function we use to accomplish this task is left_join() and the key in both datasets are the state names, called NAME in us_states dataset, and state in us_states_df dataset.\nThe class of the new object depends on which object is used first on the left_join() function, if us_states (an sf object) is used first, the class of new object is sf . However, if the us_states_df (a data frame) is used first, the resulting object is a data.frame or tibble.\n\nus_states |&gt; \n  left_join(us_states_df, by = join_by(NAME == state)) |&gt; \n  class()\n## [1] \"sf\"         \"data.frame\"\n\nus_states_df |&gt; \n  left_join(us_states, by = join_by(state == NAME)) |&gt; \n  class()\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nE8\nus_states_df has two more rows than us_states. How can you find them? (Hint: try to use the dplyr::anti_join() function.)\nThe two rows that more more in us_states_df are shown below: —\n\nus_states_df |&gt; \n  anti_join(us_states, by = join_by(state == NAME)) |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\nTable 5: The two extra rows in us_states_df\n\n\n\n\n\n\n\n\n\nState\nMedian Income 10\nMedian Income 15\nPoverty Level 10\nPoverty Level 15\n\n\n\n\nAlaska\n29509\n31455\n64245\n72957\n\n\nHawaii\n29945\n31051\n124627\n153944\n\n\n\n\n\n\n\n\n\n\n\n\n\nE9\nWhat was the population density in 2015 in each state? What was the population density in 2010 in each state?\nThe Table 6 shows the population density.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  mutate(\n    population_density_2010 = total_pop_10 / as.numeric(AREA),\n    population_density_2015 = total_pop_15 / as.numeric(AREA),\n    .keep = \"unused\"\n  ) |&gt; \n  select(-GEOID) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    decimals = 1\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 6: A table showing population density in 2010 and 2015 in each state\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE10\nHow much has population density changed between 2010 and 2015 in each state? Calculate the change in percentages and map them.\nThe Table 7 shows how much the population density has changed between 2010 and 2015 in each state. The Figure 1 shows the percentage change in a map of the US.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  as_tibble() |&gt; \n  mutate(\n    population_density_2010 = total_pop_10 / as.numeric(AREA),\n    population_density_2015 = total_pop_15 / as.numeric(AREA),\n    change_in_density = (population_density_2015 - population_density_2010)/population_density_2010,\n    .keep = \"unused\"\n  ) |&gt; \n  select(-GEOID) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    decimals = 1\n  ) |&gt; \n  gt::fmt_percent(\n    columns = change_in_density\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 7: Table showing change in population density between 2010 and 2015\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nus_states |&gt; \n  mutate(\n    population_density_2010 = total_pop_10 / as.numeric(AREA),\n    population_density_2015 = total_pop_15 / as.numeric(AREA),\n    change_in_density = (population_density_2015 - population_density_2010)/population_density_2010,\n    .keep = \"unused\"\n  ) |&gt; \n  ggplot() +\n  geom_sf(\n    mapping = aes(\n      fill = change_in_density\n    )\n  ) +\n  geom_sf_text(\n    mapping = aes(\n      label = paste0(\n        round(\n          change_in_density * 100,\n          1\n        ),\n        \"%\"\n      )\n    ),\n    size = 3\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Red-Green Diverging\",\n    labels = scales::label_percent(),\n    name = \"Change in population density between 2010 and 2015\",\n    limits = c(-0.05, 0.1)\n  ) +\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"bottom\",\n    legend.title.position = \"top\"\n  )\n\n\n\n\n\n\n\n\nFigure 1: Map of the change in population density\n\n\n\n\n\n\n\n\nE11\nChange the columns’ names in us_states to lowercase. (Hint: helper functions - tolower() and colnames() may help.)\nA very easy method is using the janitor package and the function clean_names()\n\n\nCode\nus_states |&gt; \n  janitor::clean_names() |&gt; \n  as_tibble() |&gt; \n  print(n = 5)\n\n\n# A tibble: 49 × 7\n  geoid name   region   area total_pop_10 total_pop_15                  geometry\n  &lt;chr&gt; &lt;chr&gt;  &lt;fct&gt;  [km^2]        &lt;dbl&gt;        &lt;dbl&gt;        &lt;MULTIPOLYGON [°]&gt;\n1 01    Alaba… South  1.34e5      4712651      4830620 (((-88.20006 34.99563, -…\n2 04    Arizo… West   2.95e5      6246816      6641928 (((-114.7196 32.71876, -…\n3 08    Color… West   2.70e5      4887061      5278906 (((-109.0501 41.00066, -…\n4 09    Conne… Norte… 1.30e4      3545837      3593222 (((-73.48731 42.04964, -…\n5 12    Flori… South  1.51e5     18511620     19645772 (((-81.81169 24.56874, -…\n# ℹ 44 more rows\n\n\n\n\n\nE12\nUsing us_states and us_states_df create a new object called us_states_sel. The new object should have only two variables: median_income_15 and geometry. Change the name of the median_income_15 column to Income.\nThe new object us_states_sel is created as shown below.\n\n\nCode\nus_states_sel &lt;- us_states |&gt; \n  left_join(us_states_df, by = join_by(NAME == state)) |&gt; \n  select(Income = median_income_15, geometry)\n\nus_states_sel\n\n\nSimple feature collection with 49 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -124.7042 ymin: 24.55868 xmax: -66.9824 ymax: 49.38436\nGeodetic CRS:  NAD83\nFirst 10 features:\n   Income                       geometry\n1   22890 MULTIPOLYGON (((-88.20006 3...\n2   26156 MULTIPOLYGON (((-114.7196 3...\n3   30752 MULTIPOLYGON (((-109.0501 4...\n4   33226 MULTIPOLYGON (((-73.48731 4...\n5   24654 MULTIPOLYGON (((-81.81169 2...\n6   25588 MULTIPOLYGON (((-85.60516 3...\n7   23558 MULTIPOLYGON (((-116.916 45...\n8   25834 MULTIPOLYGON (((-87.52404 4...\n9   27315 MULTIPOLYGON (((-102.0517 4...\n10  24014 MULTIPOLYGON (((-92.01783 2...\n\n\n\n\n\nE13\nCalculate the change in the number of residents living below the poverty level between 2010 and 2015 for each state. (Hint: See ?us_states_df for documentation on the poverty level columns.) Bonus: Calculate the change in the percentage of residents living below the poverty level in each state.\nThe Table 8 shows the change in the number of residents living below the poverty level between 2010 and 2015 for each state.\n\n\nCode\nus_states_df |&gt; \n  mutate(\n    change_in_poverty = poverty_level_15 - poverty_level_10\n  ) |&gt; \n  select(state, change_in_poverty) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(decimals = 0) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::opt_interactive() \n\n\n\n\nTable 8: The change in the number of residents living below the poverty level between 2010 and 2015 for each state\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Table 9 shows the change in the percentage of residents living below the poverty level in each state.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  left_join(us_states_df, by = join_by(NAME == state)) |&gt; \n  as_tibble() |&gt; \n  mutate(\n    state = NAME,\n    poverty_2010 = poverty_level_10 / total_pop_10,\n    poverty_2015 = poverty_level_15 / total_pop_15,\n    change_in_poverty = poverty_2015 - poverty_2010,\n    .keep = \"none\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::fmt_percent() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 9: Table showing the change in the percentage of residents living below the poverty level in each state.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE14\nWhat was the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region? Bonus: What is the region with the largest increase in people living below the poverty line?\nThe the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region are shown in Table 10 below.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  select(state = NAME, region = REGION) |&gt; \n  left_join(us_states_df) |&gt; \n  as_tibble() |&gt; \n  group_by(region) |&gt; \n  summarise(\n    minimum_poverty_2015 = min(poverty_level_15),\n    maximum_poverty_2015 = max(poverty_level_15),\n    average_poverty_2015 = mean(poverty_level_15)\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::fmt_number(decimals = 0)\n\n\n\n\nTable 10: A table showing the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region\n\n\n\n\n\n\n\n\n\nRegion\nMinimum Poverty 2015\nMaximum Poverty 2015\nAverage Poverty 2015\n\n\n\n\nNorteast\n69,233\n3,005,943\n804,465\n\n\nMidwest\n79,758\n1,801,118\n799,155\n\n\nSouth\n108,315\n4,472,451\n1,147,575\n\n\nWest\n64,995\n6,135,142\n1,016,665\n\n\n\n\n\n\n\n\n\n\nAs evident in Table 11, the region with the largest increase in people living below the poverty line is the South Region.\n\n\nCode\nus_states |&gt; \n  st_drop_geometry() |&gt; \n  select(state = NAME, region = REGION) |&gt; \n  as_tibble() |&gt; \n  left_join(us_states_df) |&gt; \n  group_by(region) |&gt; \n  summarise(\n    change_total_poverty = sum(poverty_level_15) - sum(poverty_level_10)\n  ) |&gt; \n  arrange(desc(change_total_poverty)) |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::fmt_number(decimals = 0)\n\n\n\n\nTable 11: Table showing the region with the largest increase in people living below the poverty line\n\n\n\n\n\n\n\n\n\nRegion\nChange Total Poverty\n\n\n\n\nSouth\n2,718,396\n\n\nWest\n2,102,479\n\n\nMidwest\n1,095,133\n\n\nNorteast\n877,493\n\n\n\n\n\n\n\n\n\n\n\n\n\nE15\nCreate a raster from scratch, with nine rows and columns and a resolution of 0.5 decimal degrees (WGS84). Fill it with random numbers. Extract the values of the four corner cells.\n\n# Load the terra package\nlibrary(terra)\n\n# Create a raster with 9 rows and 9 columns, resolution of 0.5 degrees\nr &lt;- rast(nrows = 9, ncols = 9, \n          resolution = 0.5, \n          crs = \"EPSG:4326\")\n\n# Fill the raster with random numbers\nvalues(r) &lt;- runif(ncell(r))\n\n# Print the raster\nprint(r)\n## class       : SpatRaster \n## dimensions  : 360, 720, 1  (nrow, ncol, nlyr)\n## resolution  : 0.5, 0.5  (x, y)\n## extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :        lyr.1 \n## min value   : 4.599569e-06 \n## max value   : 9.999993e-01\n\nplot(r)\n\n\n\n\n\n\n\n# Extract the values of the four corner cells\n# Top-left (1, 1), Top-right (1, 9), Bottom-left (9, 1), \n# # Bottom-right (9, 9)\n\nr[1,1]\n##       lyr.1\n## 1 0.3572785\nr[1,9]\n##       lyr.1\n## 1 0.2861174\nr[9,1]\n##       lyr.1\n## 1 0.2665531\nr[9,9]\n##       lyr.1\n## 1 0.5069412\n\n\n\n\nE16\nWhat is the most common class of our example raster grain?\n\n\nCode\ngrain_order &lt;-  c(\"clay\", \"silt\", \"sand\")\ngrain_char &lt;- sample(grain_order, 36, replace = TRUE)\ngrain_fact &lt;-  factor(grain_char, levels = grain_order)\ngrain &lt;-rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, \n             ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\nanswer &lt;- freq(grain) |&gt; \n  arrange(desc(count))\n\ngt::gt(answer) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 12: The count of different classes in the example raster grain.\n\n\n\n\n\n\n\n\n\nLayer\nValue\nCount\n\n\n\n\n1\nsilt\n14\n\n\n1\nclay\n13\n\n\n1\nsand\n9\n\n\n\n\n\n\n\n\n\n\nThe most common class is the silt .\n\n\n\nE17\nPlot the histogram and the boxplot of the dem.tif file from the spDataLarge package (system.file(\"raster/dem.tif\", package = \"spDataLarge\")).\nThe plots are shown in Figure 2\n\ntemp_rast &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\nhist(temp_rast)\n\nboxplot(temp_rast)\n\n# Using ggplot2 methods\n\ntemp_rast |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  ggplot(aes(dem)) +\n  geom_histogram(\n    fill = \"white\",\n    colour = \"grey20\"\n  )\n\ntemp_rast |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  ggplot(aes(dem)) +\n  geom_boxplot(\n    fill = \"white\",\n    colour = \"grey20\",\n    staplewidth = 0.5\n  )\n\n\n\n\n\n\n\n\n\n\n(a) Histogram of the raster dem.tif using base R hist()\n\n\n\n\n\n\n\n\n\n\n\n(b) Boxplot of the raster dem.tif using base R boxplot()\n\n\n\n\n\n\n\n\n\n\n\n(c) Histogram of the values in raster dem.tif using ggplot2\n\n\n\n\n\n\n\n\n\n\n\n(d) Boxplot of the values in raster dem.tif using ggplot2\n\n\n\n\n\n\nFigure 2: Plots produced for question E17"
  },
  {
    "objectID": "book_solutions/chapter5.html",
    "href": "book_solutions/chapter5.html",
    "title": "Chapter 5: Geometry operations",
    "section": "",
    "text": "Code\nlibrary(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(magrittr)  # Using pipes with raster objects\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\nlibrary(patchwork) # Composing plots"
  },
  {
    "objectID": "book_solutions/chapter5.html#introduction",
    "href": "book_solutions/chapter5.html#introduction",
    "title": "Chapter 5: Geometry operations",
    "section": "5.1 Introduction",
    "text": "5.1 Introduction\n\nPrevious chapters introduced geographic datasets’ structure (Chapter 2), attribute-based manipulation (Chapter 3), and spatial relations (Chapter 4).\nFocus of this chapter: Manipulating geographic elements of spatial objects.\n\nExamples: Creating buffers, simplifying/converting vector geometries, and raster aggregation/resampling.\n\nSection 5.2: Transforming vector geometries using:\n\nUnary operations: Simplifications, buffers, centroids, and affine transformations (Sections 5.2.1–5.2.4).\nBinary operations: Modifying geometries through clipping and unions (Sections 5.2.5–5.2.7).\nType transformations: Converting geometry types, e.g., polygons to lines (Section 5.2.8).\n\nSection 5.3: Raster transformations:\n\nAlter pixel size, resolution, extent, and origin.\nAlign raster datasets for map algebra."
  },
  {
    "objectID": "book_solutions/chapter5.html#geometric-operations-on-vector-data",
    "href": "book_solutions/chapter5.html#geometric-operations-on-vector-data",
    "title": "Chapter 5: Geometry operations",
    "section": "5.2 Geometric operations on vector data",
    "text": "5.2 Geometric operations on vector data\n\nFocus: Operations that modify the geometry of vector (sf) objects.\nKey distinction: Works directly on geometry-level objects of class sfc, in addition to sf objects.\nExamples: Drilling into geometry to transform, simplify, or reshape vector data.\n\n\n5.2.1 Simplification\n\nGeneralizes vector geometries (lines/polygons) for smaller scale maps, reducing memory, disk space, and bandwidth usage. Useful for publishing interactive maps by simplifying complex geometries.\nKey Functions and Algorithms:\n\nst_simplify() from the sf package (Pebesma and Bivand 2023):\n\nImplements the Douglas-Peucker algorithm (Douglas and Peucker 1973).\nControlled by dTolerance (generalization level in metres, or map units).\nSimplifies individual geometries but does not preserve topology, leading to overlaps or holes.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\ntopology (noun): the way in which parts of something are organized, arranged or connected\n\n\n\nms_simplify() from the rmapshaper package (Teucher and Russell 2023):\n\nUses the Visvalingam algorithm (Visvalingam and Whyatt 1993).\nRetains topology by default (keep_shapes = TRUE) and allows fine control over the vertex retention (keep: the % of vertices that are to be retained, given as a proportion).\n\nsmooth() from the smoothr package:\n\nSmooths edges using techniques like Gaussian kernel regression, Chaikin’s algorithm, or spline interpolation.\nDoes not reduce vertex count and does not preserve topology.\nKey parameter: smoothness (controls Gaussian bandwidth).\n\nExamples of Simplification are shown in Figure 1\nApplications of Smoothing:\n\nSuitable for geometries derived from raster vectorization (e.g., Chapter 6).\n\n\n\n\nCode\n# Download India's Official states' map from\n# https://github.com/Aditya-Dahiya/projects_presentations/tree/main/data/india_map\n\n#### Base Map\nindia_states &lt;- read_sf(\"India_State_Boundary.shp\")\n\ng &lt;- india_states |&gt; \n  ggplot() +\n  geom_sf() +\n  theme_minimal() +\n  labs(\n    title = \"Base Map of India: in full detail\",\n    subtitle = \"Source: Census of India\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_1.png\"),\n  plot = g,\n  height = 1600,\n  width = 1200,\n  units = \"px\"\n)\n\n#### st_simplify()\ng &lt;- india_states |&gt; \n  st_simplify(dTolerance = 100000) |&gt;    # 100 km tolerance\n  ggplot() +\n  geom_sf() +\n  theme_minimal() +\n  labs(\n    title = \"India: st_simplify(dTolerance = 100000)\",\n    subtitle = \"Douglas-Peucker algorithm. Topology is lost.\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_2.png\"),\n  plot = g,\n  height = 1600,\n  width = 1200,\n  units = \"px\"\n)\n\n#### rmapshaper::ms_simplify()\ng &lt;- india_states |&gt; \n  rmapshaper::ms_simplify(keep = 0.0001, keep_shapes = TRUE) |&gt;    \n  ggplot() +\n  geom_sf() +\n  theme_minimal() +\n  labs(\n    title = \"India: rmapshaper::ms_simplify(keep_shapes = TRUE)\",\n    subtitle = \"Visvalingam algorithm. Topology is retained.\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_3.png\"),\n  plot = g,\n  height = 1600,\n  width = 1200,\n  units = \"px\"\n)\n\n#### smoothr::smooth() - 3 methods\ng &lt;- india_states |&gt; \n  st_simplify(dTolerance = 10000) |&gt;  # To save computing time\n  smoothr::smooth(method = \"ksmooth\",\n                  smoothness = 5) |&gt;    \n  ggplot() +\n  geom_sf() +\n  theme_minimal() +\n  labs(\n    title = \"smoothr::smooth(method = \\\"ksmooth\\\")\",\n    subtitle = \"Gaussian kernel regression. Topology is lost.\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_4.png\"),\n  plot = g,\n  height = 1600,\n  width = 1200,\n  units = \"px\"\n)\n\ng &lt;- india_states |&gt; \n  st_simplify(dTolerance = 50000) |&gt;  # To save computing time\n  smoothr::smooth(method = \"chaikin\") |&gt;    \n  ggplot() +\n  geom_sf() +\n  theme_minimal() +\n  labs(\n    title = \"smoothr::smooth(method = \\\"chaikin\\\")\",\n    subtitle = \"Chaikin’s corner cutting algorithm. Topology is lost.\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_5.png\"),\n  plot = g,\n  height = 1600,\n  width = 1200,\n  units = \"px\"\n)\n\ng &lt;- india_states |&gt; \n  st_simplify(dTolerance = 50000) |&gt;  # To save computing time\n  smoothr::smooth(method = \"spline\") |&gt;    \n  ggplot() +\n  geom_sf() +\n  theme_minimal() +\n  labs(\n    title = \"smoothr::smooth(method = \\\"spline\\\")\",\n    subtitle = \"Spline interpolation. Topology is lost.\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_6.png\"),\n  plot = g,\n  height = 1600,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\n\n\nOfficial Map of India (full details)\n\n\n\n\n\n\n\nUsing st_simplify(dTolerance = 100000), i.e. 100 km resolution\n\n\n\n\n\n\n\n\n\nUsing rmapshaper::ms_simplify(keep_shape = TRUE) to retain topology\n\n\n\n\n\n\n\nUsing gaussian kernel regression with smoothr::smooth(method = “ksmooth”)\n\n\n\n\n\n\n\n\n\nUsing Chalkin’s corner cutting algorithm with smoothr::smooth(method = “chalkin”)\n\n\n\n\n\n\n\nUsing spline interpolation with smoothr::smooth(method = “spline”)\n\n\n\n\n\n\nFigure 1\n\n\n\n\nsmoothr\nA short note on the {smoothr} package (Strimas-Mackey 2023), which uses three different types of algorithms:-.\n\n\n\n\n\n\nNote\n\n\n\n\n\nCode\nlibrary(sf)\nlibrary(smoothr)\nlibrary(tidyverse)\n\n# Smooth polygons using different methods\np_smooth_chaikin &lt;- smooth(jagged_polygons, method = \"chaikin\")\np_smooth_ksmooth &lt;- smooth(jagged_polygons, method = \"ksmooth\")\np_smooth_spline &lt;- smooth(jagged_polygons, method = \"spline\")\n\n# Combine data for plotting\nplot_data &lt;- bind_rows(\n  mutate(st_as_sf(p_smooth_chaikin), method = \"chaikin\"),\n  mutate(st_as_sf(p_smooth_ksmooth), method = \"ksmooth\"),\n  mutate(st_as_sf(p_smooth_spline), method = \"spline\"),\n  mutate(st_as_sf(jagged_polygons), method = \"original\")\n)\n\n# Assign colors to methods\nmethod_colors &lt;- c(\n  chaikin = \"#E41A1C\",\n  ksmooth = \"#4DAF4A\",\n  spline = \"#377EB8\"\n)\n\n# Convert geometry for plotting\nplot_data &lt;- plot_data |&gt; \n  mutate(geometry = st_sfc(geometry)) |&gt; \n  st_as_sf()\n\np2 &lt;- plot_data |&gt; \n  filter(method != \"original\")\n\np1 &lt;- plot_data |&gt; \n  filter(method == \"original\") |&gt; \n  select(-method)\n\n# Plot with ggplot2\ng &lt;- ggplot(data = p2) +\n  geom_sf(aes(geometry = geometry, \n              color = method),\n          size = 0.7,\n          linewidth = 0.5,\n          fill = \"transparent\") +\n  geom_sf(\n    data = p1,\n    fill = alpha(\"grey50\", 0.5),\n    colour = \"transparent\"\n  ) +\n  scale_color_manual(values = method_colors) +\n  facet_grid(id ~ method) +\n  guides(fill = \"none\") +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    plot.title.position = \"plot\",\n    strip.text.y = element_blank()\n    ) +\n  labs(\n    title = \"Simplification with {smoothr}\",\n    colour = \"Method\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"ch5-2-1_7.png\"),\n  plot = g,\n  height = 2000,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\n5.2.2 Centroids\n\nIdentify the center of geographic objects, creating single-point representations of complex geometries using st_centroid()\nTypes of Centroids: (shown in Figure 2)\n\nGeographic Centroid (center of mass):\n\nBalances a spatial object (like balancing a plate).\nUseful for creating simple point representations or estimating distances between polygons.\nCalculated with st_centroid() from the sf package.\nLimitation: Centroids may fall outside the object (e.g., doughnut-shaped polygons).\n\nPoint on Surface:\n\nEnsures the point lies within the object boundaries.\nUseful for labeling irregular polygons, such as islands or multipolygon geometries.\nCalculated with st_point_on_surface().\n\n\nOther Centroid Types: Chebyshev center and visual center\n\n\n\nCode\nsysfonts::font_add_google(\"Saira Extra Condensed\", \"caption_font\")\nshowtext::showtext_auto()\n\nggplot2::theme_set(\n  theme_minimal(\n    base_size = 30,\n    base_family = \"caption_font\"\n  ) +\n    theme(\n      text = element_text(\n        lineheight = 0.3,\n        hjust = 0.5\n      ),\n      plot.title.position = \"plot\"\n    )\n)\n\n# Focussing on the Island Chains of India\nandaman &lt;- india_states |&gt; \n  filter(\n    State_Name == \"Andaman & Nicobar\"\n  )\n  \ng1 &lt;- ggplot(andaman) +\n  geom_sf() +\n  labs(\n    title = \"Base Map\",\n    subtitle = \"Andaman & Nicobar\\nIslands (India)\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_sf(\n    data = andaman\n    ) +\n  geom_sf(\n    data = st_centroid(andaman),\n    colour = \"red\",\n    size = 4, \n    pch = 1,\n    stroke = 2\n  ) +\n  labs(\n    title = \"st_centroid()\",\n    subtitle = \"Andaman & Nicobar\\nIslands (India)\"\n  )\n\ng3 &lt;- ggplot() +\n  geom_sf(\n    data = andaman\n    ) +\n  geom_sf(\n    data = st_centroid(andaman, of_largest_polygon = TRUE),\n    colour = \"red\",\n    size = 4, \n    pch = 1,\n    stroke = 2,\n    fill = \"transparent\"\n  ) +\n  labs(\n    title = \"st_centroid\\n(of_largest_polygon = TRUE)\",\n    subtitle = \"Andaman & Nicobar\\nIslands (India)\"\n  )\n\ng4 &lt;- ggplot() +\n  geom_sf(\n    data = andaman\n    ) +\n  geom_sf(\n    data = st_point_on_surface(andaman),\n    colour = \"red\",\n    size = 4, \n    pch = 1,\n    stroke = 2,\n    fill = \"transparent\"\n  ) +\n  labs(\n    title = \"st_point_on_surface()\",\n    subtitle = \"Andaman & Nicobar\\nIslands (India)\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-2_1.png\"),\n  plot = patchwork::wrap_plots(g1, g2, g3, g4, nrow = 1),\n  height = 1900,\n  width = 2400,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 2: Various centroids using st_centroid() and st_point_on_surface()\n\n\n\n\n\n5.2.3 Buffers\n\nBuffers are polygons representing areas within a specified distance from a geometric feature (point, line, or polygon).\nPurpose: Used for geographic data analysis (not just visualization). Examples:\n\nHow many points are within a given distance of a line?\nWhich demographic groups are within travel range of a new shop?\n\nst_buffer() from the sf package. Example Visualization is shown in Figure 3\n\nInput: Geometry and dist (distance in CRS units, e.g., meters).\nOutput: One buffer polygon per geometry feature.\n\nOther Key Arguments in st_buffer():\n\nnQuadSegs (GEOS engine):\n\nNumber of segments per quadrant (default: 30).\nAdjust: Decrease for memory concerns, or increase for high resolution output.\n\nmax_cells (S2 engine):\n\nHigher values create smoother buffers (slower computation).\n\nendCapStyle and joinStyle (GEOS engine):\n\nControl buffer edge appearance (useful for lines).\n\nsingleSide (GEOS engine):\n\nBuffer on one or both sides of the geometry.\n\n\n\n\n\nCode\na1 &lt;- andaman |&gt; \n  st_cast(\"POLYGON\")\n\na2 &lt;- st_buffer(a1, dist = 20000) |&gt; \n  mutate(id = as_factor(row_number()))\n\na3 &lt;- st_buffer(a1, dist = 20000, nQuadSegs = 0.5) |&gt; \n  mutate(id = as_factor(row_number()))\n\ng1 &lt;- ggplot() +\n  geom_sf(data = a1) +\n  labs(\n    title = \"Base Map with\\nst_cast(\\\"POLYGON\\\")\",\n    subtitle = \"Nicobar Islands\"\n  ) +\n  coord_sf(\n    ylim = c(6.5, 9.5),\n    default_crs = 4326\n  )\n\ng2 &lt;- ggplot() +\n  geom_sf(\n    data = a2,\n    mapping = aes(fill = id),\n    alpha = 0.2,\n    colour = \"transparent\"\n  ) +\n  geom_sf(\n    data = a1\n  ) +\n  labs(\n    title = \"With 20 km buffer\\n around each island\",\n    subtitle = \"Nicobar Islands; each\\nbuffer in separate colour\"\n  ) +\n  theme(legend.position = \"none\") +\n  coord_sf(\n    ylim = c(6.5, 9.5),\n    default_crs = 4326\n  )\n\n\ng3 &lt;- ggplot() +\n  geom_sf(\n    data = a3,\n    mapping = aes(fill = id),\n    alpha = 0.2,\n    colour = \"transparent\"\n  ) +\n  geom_sf(\n    data = a1\n  ) +\n  labs(\n    title = \"With 20 km buffer\\n around each island\",\n    subtitle = \"Nicobar Islands;\\narugment (nQuadSegs = 1)\"\n  ) +\n  theme(legend.position = \"none\") +\n  coord_sf(\n    ylim = c(6.5, 9.5),\n    default_crs = 4326\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-3_1.png\"),\n  plot = patchwork::wrap_plots(g1, g2, g3, nrow = 1),\n  height = 1200,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 3: Use of st_buffer()\n\n\n\n\n\n5.2.4 Affine Transformations\n\nDefinition: Transformations that preserve lines and parallelism but not necessarily angles or lengths.\nTypes of Affine Transformations:\n\nShifting (Translation): Moves every point by a constant distance.\n\nExample: Adding a vector to shift all y-coordinates north by 400 km distance while keeping x-coordinates unchanged using:\nn_shift &lt;- n1 |&gt; \n  add(c(0, 400000)) |&gt; \n  st_set_crs(st_crs(n1))\nNote: This converts the CRS of the new sfc object to NA and thus needs st_set_crs() to return it back to the original CRS.\n\nScaling: Enlarges or shrinks geometries.\n\nGlobal Scaling:\n\nMultiplies all coordinates relative to the origin, preserving topological relations.\n\nLocal Scaling:\n\nScales geometries around specific points (e.g., centroids).\nSteps:\n\nShift geometries so the centroid becomes (0,0).\nScale by a factor.\nShift back to original centroid coordinates.\n\n\n\nRotation: Rotates coordinates using a rotation matrix.\n\nRotation matrix: Define a function to create the rotation matrix and apply it to the geometry. R=[cosθ/sinθ​ − sinθ/cosθ​]\n\n\nReplacing Old Geometry: Once the affine transformation has been completed, use st_set_geometry() from the sf package to finally Replace original geometry with scaled versions (shifted, rotated or scaled)\nApplications:\n\nShifting: For label placement.\nScaling: In non-contiguous cartograms.\nRotation: Correcting distorted geometries during re-projection.\n\n\n\n\nCode\nsysfonts::font_add_google(\"Saira Extra Condensed\", \"caption_font\")\nshowtext::showtext_auto()\n\nggplot2::theme_set(\n  theme_minimal(\n    base_size = 30,\n    base_family = \"caption_font\"\n  ) +\n    theme(\n      text = element_text(\n        lineheight = 0.3,\n        hjust = 0.5\n      ),\n      plot.title.position = \"plot\",\n      plot.title = element_text(hjust = 1),\n      plot.subtitle = element_text(hjust = 1),\n      panel.grid = element_line(\n        linewidth = 0.2\n      )\n    )\n)\n\ndf1 &lt;- andaman |&gt; \n  st_cast(\"POLYGON\") |&gt; \n  mutate(id = row_number()) |&gt; \n  filter(id &lt; 10) |&gt; \n  mutate(\n    name = case_when(\n      id %in% c(4,8, 9, 7) ~ \"Nicobar Islands\",\n      .default = \"Andaman Islands\"\n    )\n  )\n\n\n# Pull out only sfc class (i.e. geometry for Andaman Islands)\na1 &lt;- df1 |&gt; \n  filter(name == \"Andaman Islands\") |&gt; \n  st_geometry()\n\n# Pull out only sfc class (i.e. geometry for Nicobar Islands)\nn1 &lt;- df1 |&gt; \n  filter(name == \"Nicobar Islands\") |&gt; \n  st_geometry()\n\n\ng1 &lt;- df1 |&gt; \n  ggplot(aes(fill = name)) +\n  geom_sf(colour = \"transparent\") +\n  geom_sf_text(aes(label = id)) +\n  coord_sf(\n    ylim = c(7, 13.5),\n    default_crs = 4326\n  ) +\n  labs(\n    title = \"Base Map\",\n    subtitle = \"10 Largest Islands amongst\\nAndamand and Nicobar Island chain\",\n    fill = NULL, x = NULL, y = NULL\n  ) +\n  scale_fill_manual(values = c(\"#89973DFF\", \"#E8B92FFF\")) +\n  theme(\n    legend.position = \"left\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_sf(data = a1, fill = \"#89973DFF\", colour = \"transparent\") +\n  geom_sf(data = n1, fill = \"#E8B92FFF\", colour = \"transparent\") +\n  coord_sf(\n    ylim = c(7, 13.5),\n    default_crs = 4326\n  ) + \n  labs(\n    title = \"Plotting as separate\\nsfc objects\",\n    subtitle = \"10 Largest Islands\"\n  )\n\n#################### Shifting #########################\n\nn_shift &lt;- n1 |&gt; \n  add(c(0, 400000)) |&gt; \n  st_set_crs(st_crs(n1))\n\ng3 &lt;- ggplot() +\n  geom_sf(data = a1, fill = \"#89973DFF\", colour = \"transparent\") +\n  geom_sf(\n    data = n_shift, \n    fill = \"#E8B92FFF\", \n    colour = \"transparent\"\n    ) +\n  coord_sf(\n    ylim = c(7, 13.5),\n    default_crs = 4326\n  ) +\n  labs(\n    title = \"Shifting sfc objects\",\n    subtitle = \"Bring Nicobar Islands\\ncloser to the Andamans\"\n  )\n\n#################### Scaling ##########################\n\nn1_centroid &lt;- st_centroid(n1)\n\nn1_scale &lt;- (n1 - n1_centroid) |&gt; \n  multiply_by(2.5) |&gt; \n  add(n1_centroid) |&gt; \n  st_set_crs(st_crs(n1))\n\ng4 &lt;- ggplot() +\n  geom_sf(data = a1, fill = \"#89973DFF\", colour = \"transparent\") +\n  geom_sf(\n    data = n1_scale, \n    fill = \"#E8B92FFF\", \n    colour = \"transparent\"\n    ) +\n  coord_sf(\n    ylim = c(7, 13.5),\n    default_crs = 4326\n  ) + \n  labs(\n    title = \"Scaling sfc objects\",\n    subtitle = \"Enlarging Nicobar Islands\\nby 2.5 times.\"\n  )\n\n##################### Rotation ########################\nrotation = function(a){\n  r = a * pi / 180 #degrees to radians\n  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)\n} \n\nn1_rotate &lt;- (n1 - n1_centroid) |&gt; \n  multiply_by(rotation(90)) |&gt; \n  add(n1_centroid) |&gt; \n  st_set_crs(st_crs(n1))\n\n\ng5 &lt;- ggplot() +\n  geom_sf(data = a1, fill = \"#89973DFF\", colour = \"transparent\") +\n  geom_sf(\n    data = n1_rotate, \n    fill = \"#E8B92FFF\", \n    colour = \"transparent\"\n    ) +\n  coord_sf(\n    ylim = c(7, 13.5),\n    default_crs = 4326\n  ) + \n  labs(\n    title = \"Rotating sfc objects\",\n    subtitle = \"Rotating Nicobar Islands\\nclockwise by 90 degrees\"\n  )\n\ng &lt;- patchwork::wrap_plots(g1, g3, g4, g5) +\n  patchwork::plot_layout(widths = c(1,1,1,1,1), nrow = 1)\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-4_1.png\"),\n  plot = g,\n  height = 1200,\n  width = 2500,\n  units = \"px\"\n)\n\n\n\n\n\nData Viz demonstration\nHere’s a more visually appealing version of the same graphic, produced using complete code given on this page.\n\n\n\nThis plot demonstrates the application of spatial transformations on the Andaman and Nicobar Islands using the `sf` package in R. It showcases four techniques: base mapping, northward shifting, scaling (enlargement), and rotation (90° clockwise), highlighting their effects on spatial geometries. The `facet_wrap` function neatly organizes the transformations for comparison, while `geom_sf` and custom labels enhance the visualization.\n\n\n\n\n5.2.5 Clipping\n\nDefinition: A form of spatial subsetting that modifies the geometry column of affected features. Applies to lines, polygons, and their multi equivalents (not points).\nPurpose: Identifies or extracts areas of overlap or subsets of spatial features. Commonly used in geographic data analysis to focus on regions of interest.\nLogical Operations and Spatial Equivalents. Inspired by Figure 12.1 of R for Data Science (2e). Spatial equivalents to logical operators (e.g., AND, OR, NOT) allow flexible geometry subsetting (as shown in Figure 4)\n\nIntersection (AND): st_intersection()\nUnion (OR): st_union()\nDifference (NOT): st_difference()\nExclusive OR (XOR): st_sym_difference()\n\nApplications:\n\nIdentifying overlapping regions.\nCreating subsets of spatial data for specific analysis or visualization.\n\n\n\n\nCode\nsysfonts::font_add_google(\"Nova Mono\", \"body_font\")\nshowtext::showtext_auto()\n\ntheme_custom &lt;- function(...) {\n  ggthemes::theme_map(\n    base_size = 20,\n    base_family = \"body_font\"\n    ) +\n    labs(\n      x = NULL, y = NULL\n    ) +\n    theme(\n      plot.title = element_text(\n        hjust = 0.5,\n        lineheight = 0.3,\n        margin = margin(5,0,2,0, \"mm\")\n      ),\n      plot.margin = margin(0,0,0,0, \"mm\"),\n      ...\n    )\n}\n# Define the center points of the circles\nsf_circles &lt;- tibble(\n  x = c(0, 2, 4, 1, 3),\n  y = c(0, 0, 0, -1, -1),\n  colour_var = c(\"blue\", \"black\", \"red\", \"yellow\", \"green\"),\n  label_var = LETTERS[1:5]\n  ) |&gt; \n  # Convert the points to an sf object\n  st_as_sf(\n  coords = c(\"x\", \"y\"), \n  crs = NA\n  ) |&gt; \n  # Create circular geometries using st_buffer\n  mutate(geometry = st_buffer(geometry, dist = 1))\n\ng1 &lt;- sf_circles |&gt; \n  ggplot(\n    mapping = aes(\n      label = label_var\n      )\n    ) +\n  geom_sf(\n    fill = \"transparent\",\n    linewidth = 0.5,\n    colour = \"grey10\"\n  ) +\n  geom_sf_text(\n    colour = \"grey10\",\n    fontface = \"bold\",\n    size = 16,\n    family = \"body_font\"\n  ) +\n  labs(\n    title = \"5 overlapping circles plotted with {sf}\"\n  ) + \n  theme_custom()\n\n# Naming the individual circles\n\npull_a_circle &lt;- function(ch_pick){\n  sf_circles |&gt; \n    filter(label_var == ch_pick)\n}\na1 &lt;- pull_a_circle(\"A\")  \nb1 &lt;- pull_a_circle(\"B\")  \nc1 &lt;- pull_a_circle(\"C\")  \nd1 &lt;- pull_a_circle(\"D\")  \ne1 &lt;- pull_a_circle(\"E\")  \n\ng2 &lt;- g1 +\n  geom_sf(\n    data = a1 |&gt; st_difference(d1),\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  ggtitle(\"A |&gt; st_difference(D)\")\n\ng3 &lt;- g1 +\n  geom_sf(\n    data = d1 |&gt; st_difference(a1),\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  ggtitle(\"D |&gt; st_difference(A)\")\n\ng4 &lt;- g1 +\n  geom_sf(\n    data = d1 |&gt; st_difference(a1) |&gt; st_difference(b1),\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  ggtitle(\"D |&gt; st_difference(A) |&gt;\\nst_difference(B)\")\n\ng5 &lt;- g1 +\n  geom_sf(\n    data = a1 |&gt; st_union(d1),\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  ggtitle(\"st_union(A, D)\")\n\ng6 &lt;- g1 +\n  geom_sf(\n    data = a1 |&gt; st_intersection(d1),\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  ggtitle(\"st_intersection(A, D)\")\n\ng7 &lt;- g1 +\n  geom_sf(\n    data = st_sym_difference(a1, d1),\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  ggtitle(\"st_sym_difference(A, D)\")\n\nnon_overlap &lt;- a1 |&gt; \n            st_sym_difference(d1) |&gt; \n            st_sym_difference(b1) |&gt; \n            st_sym_difference(c1) |&gt; \n            st_sym_difference(e1)\ng8 &lt;- g1 +\n  geom_sf(\n    data = non_overlap,\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  labs(title = \"An st_sym_difference() chain\")\n\noverlap &lt;- a1 |&gt; \n  st_intersection(d1) |&gt; \n  st_union(st_intersection(d1, b1)) |&gt; \n  st_union(st_intersection(b1, e1)) |&gt; \n  st_union(st_intersection(e1, c1))\n\ng9 &lt;- g1 +\n  geom_sf(\n    data = overlap,\n    fill = alpha(\"grey\", 0.7)\n  ) +\n  labs(title = \"A st_union() and\\nst_interaction() chain\")\n\ncustom_layout_design &lt;- \"\n  AAAAAA\n  AAAAAA\n  BBCCDD\n  BBCCDD\n  EEFFGG\n  EEFFGG\n  HHHIII\n  HHHIII\n\"\n\ng &lt;- patchwork::wrap_plots(\n  g1, g2, g3, g4, g5, g6, g7, g8, g9\n  ) + \n  patchwork::plot_layout(\n    design = custom_layout_design\n  ) +\n  patchwork::plot_annotation(\n    title = \"Clipping {sf} objects\\n(Boolean Algebra examples)\",\n    subtitle = \"Using functions like st_intersection(), st_union(), st_difference()\\n& st_sym_difference()\",\n    theme = theme(\n      plot.title = element_text(\n        family = \"body_font\",\n        size = 54, \n        lineheight = 0.3,\n        hjust = 0.5,\n        face = \"bold\"\n      ),\n      plot.subtitle = element_text(\n        family = \"body_font\",\n        size = 30, \n        lineheight = 0.3,\n        hjust = 0.5\n      )\n    )\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-5_1.png\"),\n  plot = g,\n  height = 2000,\n  width = 1600,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: Various methods and examples (inspired by Boolean Algebra) for clipping {sf} objects in R\n\n\n\n\n\n5.2.6 Sub-setting and Clipping\n\nClipping: Modifies geometry to match a subsetting object. Subsetting: Selects features that intersect or partly intersect with a clipping object. An example: Points randomly distributed within the bounding box of the five concentric circles. Some points are inside one circle, some inside two circles, or neither. Then, we subset points intersecting with one, two or no circles.\nKey Functions:\n\nst_sample(): Generates random points within a geometry.\nClipping and Subsetting Approaches:\n\nWay #1: Use the intersection of x and y (x_and_y) as a direct subsetting object: p[x_and_y]\nWay #2: Find the intersection between points (p) and x_and_y, modifying overlapping geometries: st_intersection(p, x_and_y) , or, using st_interesects() when working in a pipe (|&gt;) chain.\nWay #3: Use st_intersects() to determine logical overlap between p and the subsetting objects: sel_p_xy = st_intersects(p, x, sparse = FALSE)[, 1] & st_intersects(p, y, sparse = FALSE)[, 1] and then subset, using p_xy3 = p[sel_p_xy]\n\n\nPreferred Implementation:\n\nWay #2 (concise and efficient) and it is the tidyverse approach with |&gt; compatibility. Example shown in Figure 5\n\n\n\n\nCode\nsysfonts::font_add_google(\"Fira Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\ntheme_custom &lt;- function(...) {\n  ggthemes::theme_map(\n    base_size = 20,\n    base_family = \"body_font\"\n    ) +\n    labs(\n      x = NULL, y = NULL\n    ) +\n    theme(\n      plot.title = element_text(\n        hjust = 0.5,\n        lineheight = 0.3,\n        margin = margin(5,0,2,0, \"mm\")\n      ),\n      plot.margin = margin(0,0,0,0, \"mm\"),\n      ...\n    )\n}\n# Define the center points of the circles\nsf_circles &lt;- tibble(\n  x = c(0, 2, 4, 1, 3),\n  y = c(0, 0, 0, -1, -1),\n  colour_var = c(\"blue\", \"black\", \"red\", \"yellow\", \"green\"),\n  label_var = LETTERS[1:5]\n  ) |&gt; \n  # Convert the points to an sf object\n  st_as_sf(\n  coords = c(\"x\", \"y\"), \n  crs = NA\n  ) |&gt; \n  # Create circular geometries using st_buffer\n  mutate(geometry = st_buffer(geometry, dist = 1))\n\n# Naming the individual circles\npull_a_circle &lt;- function(ch_pick){\n  sf_circles |&gt; \n    filter(label_var == ch_pick)\n}\na1 &lt;- pull_a_circle(\"A\")  \nb1 &lt;- pull_a_circle(\"B\")  \nc1 &lt;- pull_a_circle(\"C\")  \nd1 &lt;- pull_a_circle(\"D\")  \ne1 &lt;- pull_a_circle(\"E\")  \n\none_circle &lt;- a1 |&gt; \n            st_sym_difference(d1) |&gt; \n            st_sym_difference(b1) |&gt; \n            st_sym_difference(c1) |&gt; \n            st_sym_difference(e1)\noverlap &lt;- a1 |&gt; \n  st_intersection(d1) |&gt; \n  st_union(st_intersection(d1, b1)) |&gt; \n  st_union(st_intersection(b1, e1)) |&gt; \n  st_union(st_intersection(e1, c1))\nrm(a1, b1, c1, d1, e1)\n\nset.seed(42)\n\nrandom_points &lt;- sf_circles |&gt; \n  # Get a bounding box\n  st_bbox() |&gt; \n  # Covert it into a polygon\n  st_as_sfc() |&gt; \n  \n  # Get a sample of points within this polygon\n  st_sample(size = 100) |&gt; \n  \n  # Convert into a sf object\n  st_as_sf() |&gt; \n  \n  # Add identifiers for where the points fall\n  mutate(\n    colour_var = case_when(\n      st_intersects(x, overlap, sparse = F) ~ \"Two Circles\",\n      st_intersects(x, one_circle, sparse = F) ~ \"One Circle\",\n      .default = \"Outside\"\n    ),\n    colour_var = fct(\n      colour_var,\n      levels = c(\n        \"Outside\",\n        \"One Circle\",\n        \"Two Circles\"\n      )\n    )\n  )\n\ng &lt;- ggplot() +\n  geom_sf(\n    data = sf_circles, \n    fill = \"transparent\",\n    linewidth = 0.2,\n    colour = \"grey10\"\n    ) +\n  geom_sf(\n    data = random_points,\n    mapping = aes(\n      geometry = x,\n      colour = colour_var\n    ),\n    alpha = 0.75,\n    size = 0.7,\n    stroke = 0.1\n  ) +\n  labs(\n    title = \"Clipping and Subsetting\",\n    subtitle = \"Subsetting random points into those that overlap none, one or two circles\",\n    colour = \"Point lies within\"\n  ) +\n  paletteer::scale_colour_paletteer_d(\"khroma::highcontrast\") +\n  ggthemes::theme_map(\n    base_family = \"body_font\",\n    base_size = 16\n  ) +\n  theme(\n    plot.title = element_text(\n      size = 24,\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5,\n      lineheight = 0.3,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.5, 0),\n    legend.justification = c(0.5, 1),\n    legend.direction = \"horizontal\",\n    legend.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5\n    ),\n    legend.margin = margin(0,0,0,0, \"mm\"),\n    legend.key.size = unit(5, \"pt\"),\n    legend.title.position = \"top\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-6_1.png\"),\n  plot = g,\n  height = 500,\n  width = 800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 5: Sub-setting points with clipped {sf} objects - an example\n\n\n\n\n\n5.2.7 Geometry Unions\n\nSpatial Aggregation and Geometry Dissolution:\n\nSpatial aggregation dissolves boundaries of touching polygons within the same group automatically. Example: Aggregating 22 districts of the State of Haryana into an overall boundary map with aggregate() (base R approach) or summarize() (tidyverse approach), for example in Figure 6\nGeometric Operation Behind the Scenes: Functions aggregate() and summarize() internally call st_union() from the sf package to dissolve boundaries and merge geometries.\n\nUnion of Geometries: Visualization Insight example is shown below.\n\n\n\nCode\nsysfonts::font_add_google(\"Fira Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\nharyana1 &lt;- read_sf(here::here(\n  \"data\", \"haryana_map\",\n  \"HARYANA_DISTRICT_BDY.shp\"\n))\n\ng1 &lt;- haryana1 |&gt;\n  ggplot() +\n  geom_sf(\n    aes(fill = District)\n  ) +\n  ggthemes::theme_map(\n    base_family = \"body_font\"\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Districts of Haryana State (India)\",\n    subtitle = \"The raw map, showing each district.\"\n  )  +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5,\n      lineheight = 0.35\n    ),\n    legend.position = \"none\"\n  )\n\ng2 &lt;- haryana1 |&gt;\n  st_union() |&gt; \n  ggplot() +\n  geom_sf() +\n  ggthemes::theme_map(\n    base_family = \"body_font\"\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Boundary of Haryana State (India)\",\n    subtitle = \"Generated using sf::st_union()\"\n  )  +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5,\n      lineheight = 0.35\n    ),\n    legend.position = \"none\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-7_2.png\"),\n  plot = (g1 + g2),\n  height = 400,\n  width = 600,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 6: A district map of Haryana, converted into an outer boundary map using st_union()\n\n\n\n\n\nCode\nsysfonts::font_add_google(\"Fira Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\nharyana &lt;- read_sf(\n  here::here(\n    \"data\", \"haryana_map\",\n    \"HARYANA_SUBDISTRICT_BDY.shp\"\n  )\n) |&gt; \n  janitor::clean_names() |&gt; \n  st_simplify(dTolerance = 100) |&gt; \n  mutate(\n    district = str_replace_all(district, \"&gt;\", \"A\"),\n    district = str_replace_all(district, \"\\\\|\", \"I\"),\n    district = str_to_title(district),\n    tehsil = str_to_title(str_replace_all(tehsil, \"&gt;\", \"A\"))\n  )\n\ng1 &lt;- ggplot() +\n  geom_sf(data = haryana, linewidth = 0.1) +\n  ggthemes::theme_map(\n    base_family = \"body_font\"\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Tehsils of Haryana State (India)\",\n    subtitle = \"The raw map, showing each tehsil /\\nsubdivision of Haryana.\"\n  )  +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5,\n      lineheight = 0.35\n    )\n  )\n\ng2 &lt;- haryana |&gt; \n  group_by(district) |&gt; \n  summarise() |&gt; \n  ggplot() +\n  geom_sf(\n    linewidth = 0.1\n  ) +\n  ggthemes::theme_map(\n    base_family = \"body_font\"\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Districts of Haryana State (India)\",\n    subtitle = \"Aggregating tehsils with group_by(..) |&gt; summarise()\\nwhich uses st_union() at the backend.\"\n  ) +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5,\n      lineheight = 0.35\n    )\n  )\n\ng3 &lt;- haryana |&gt; \n  group_by(district) |&gt; \n  summarise() |&gt; \n  st_cast(\"LINESTRING\") |&gt; \n  ggplot() +\n  geom_sf(\n    linewidth = 0.1\n  ) +\n  ggthemes::theme_map(\n    base_family = \"body_font\"\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Casting geometry into LINESTRING\",\n    subtitle = \"group_by(district) |&gt; summarise() |&gt; st_cast(\\\"LINESTRING\\\").\\nLoss of some geometries, but internal slivers are removed.\"\n  ) +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5,\n      lineheight = 0.35\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-7_1.png\"),\n  plot = (g1 + g2 + g3),\n  height = 500,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen using the st_union() function in spatial analysis, “inside small lines” or “slivers” appearing in the resulting combined geometry often indicates slight discrepancies in the input geometries, particularly at boundary points, causing the union operation to create small, extra line segments where the geometries nearly overlap but don’t perfectly align, as shown in Figure 7\n\n\n\n\n\n\n\n\nFigure 7: A sub-district / Tehsil map of Haryana, when converted into a district map with summarise() [which basically uses st_union() only] produces an imperfect result with internal slivers, as the boundary nodes are not overlapping amongst the sub-districts / tehsils. This depicts an inherent (limitation? / caution?) of sf::st_union().\n\n\n\n\n\n5.2.8 Type Transformations\n\nGeometry Casting: Transform geometry types using st_cast() from the sf package.\nWorks on simple feature geometry (sfg), simple feature column (sfc), and simple feature objects (sf).\nReversible Casting:\n\nExample: st_cast(linestring, \"MULTIPOINT\") reverts to multipoint geometry.\nRetains original geometry for compatible transformations.\n\nFeature Splitting:\n\nConverts multi-objects to non-multi-objects by splitting (e.g., MULTIPOINT to multiple POINTs).\nExpands rows with duplicate attribute values during splitting.\n\nUse cases:\n\nMultipoint to Linestring: For path length calculations from ordered points.\nLinestring to Polygon: To compute area, e.g., lake boundary.\nAdded attributes (e.g., road names, lengths) in case of feature splitting.\nMeasurements like st_length() for each LINESTRING.\n\nGeometry Type Transformations for Simple Features is shown in Table 1 (Credits: Geomputation with R, Book Table 5.1)\n\n\n\nCode\n# Load necessary libraries\nlibrary(tibble)\nlibrary(gt)\n\n# Create the tibble\ngeometry_table &lt;- tibble::tibble(\n  `Input Geometry Type` = c(\n    \"POINT (1 point)\",\n    \"MULTIPOINT (4 points)\",\n    \"LINESTRING (1 linestring with 5 points)\",\n    \"MULTILINESTRING (2 linestrings: one with 5 points, one with 2 points)\",\n    \"POLYGON (1 polygon with 5 points)\",\n    \"MULTIPOLYGON (2 polygons: each with 5 points)\",\n    \"GEOMETRYCOLLECTION (2 geometries: a MULTIPOINT with 4 points and a LINESTRING with 5 points)\"\n  ),\n  `POINT` = c(1, 4, 5, 7, 5, 10, 9),\n  `MULTIPOINT` = c(1, 1, 1, 2, 1, 1, 1),\n  `LINESTRING` = c(1, 1, 1, 2, 1, NA, NA),\n  `MULTI-LINESTRING` = c(NA, 1, 1, 1, 1, 1, NA),\n  `POLYGON` = c(NA, NA, NA, NA, 1, 2, NA),\n  `MULTI-POLYGON` = c(NA, NA, NA, NA, NA, 1, NA),\n  `GEOMETRY-COLLECTION` = c(NA, NA, NA, NA, NA, 1, 1)\n)\n\n# Render the table using gt\ngeometry_table |&gt; \n  gt::gt() |&gt; \n  gt::fmt_missing(columns = gt::everything(), missing_text = \"\") |&gt; \n  gtExtras::gt_theme_538() |&gt; \n  tab_style(\n    style = cell_text(size = px(10)), \n    locations = cells_body(\n      columns = `Input Geometry Type`, \n      rows = everything()             \n    )\n  ) |&gt; \n  tab_style(\n    style = cell_text(size = px(10),\n                      align = \"center\"),\n    locations = list(\n      cells_column_labels(columns = everything()), \n      cells_stub(rows = everything())             \n    )\n  ) |&gt; \n  tab_style(\n    style = cell_text(align = \"center\"), \n    locations = cells_body(\n      columns = -`Input Geometry Type`, \n      rows = everything()             \n    )\n  )\n\n\n\n\nTable 1: All possible combinations of Geometry type transformations for Simple Features\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput Geometry Type\nPOINT\nMULTIPOINT\nLINESTRING\nMULTI-LINESTRING\nPOLYGON\nMULTI-POLYGON\nGEOMETRY-COLLECTION\n\n\n\n\nPOINT (1 point)\n1\n1\n1\n\n\n\n\n\n\n\n\n\n\nMULTIPOINT (4 points)\n4\n1\n1\n1\n\n\n\n\n\n\n\n\nLINESTRING (1 linestring with 5 points)\n5\n1\n1\n1\n\n\n\n\n\n\n\n\nMULTILINESTRING (2 linestrings: one with 5 points, one with 2 points)\n7\n2\n2\n1\n\n\n\n\n\n\n\n\nPOLYGON (1 polygon with 5 points)\n5\n1\n1\n1\n1\n\n\n\n\n\n\nMULTIPOLYGON (2 polygons: each with 5 points)\n10\n1\n\n\n1\n2\n1\n1\n\n\nGEOMETRYCOLLECTION (2 geometries: a MULTIPOINT with 4 points and a LINESTRING with 5 points)\n9\n1\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\nAn attempt to recreate this table graphically with {ggplot2} and {sf}. Unfortunately, it didn’t work out.\n\n\nCode\n# Define the bounding box limits\nxmin &lt;- -2; xmax &lt;- 2; ymin &lt;- -2; ymax &lt;- 2\n\n# Create POINT\ntbl_poi &lt;- data.frame(x = 0, y = 0)\npoi &lt;- st_sfc(st_point(c(tbl_poi$x, tbl_poi$y)), crs = 4326)\n\n# Create MULTIPOINT\ntbl_mpoi &lt;- data.frame(x = c(-1, 1, -1, 1), y = c(-1, -1, 1, 1))\nmpoi &lt;- st_sfc(st_multipoint(as.matrix(tbl_mpoi)), crs = 4326)\n\n# Create LINESTRING\ntbl_lin &lt;- data.frame(x = seq(xmin, xmax, length.out = 5), y = seq(ymin, ymax, length.out = 5))\nlin &lt;- st_sfc(st_linestring(as.matrix(tbl_lin)), crs = 4326)\n\n# Create MULTILINESTRING\ntbl_mlin1 &lt;- data.frame(x = seq(xmin, xmax, length.out = 5), y = seq(ymin, ymax, length.out = 5))\ntbl_mlin2 &lt;- data.frame(x = c(xmin, xmax), y = c(ymax, ymin))\nmlin &lt;- st_sfc(st_multilinestring(list(as.matrix(tbl_mlin1), as.matrix(tbl_mlin2))), crs = 4326)\n\n# Create POLYGON\ntbl_pol &lt;- data.frame(x = c(xmin, xmax, xmax, xmin, xmin),\n                      y = c(ymin, ymin, ymax, ymax, ymin))\npol &lt;- st_sfc(st_polygon(list(as.matrix(tbl_pol))), crs = 4326)\n\n# Create MULTIPOLYGON\ntbl_mpol1 &lt;- data.frame(x = c(-1, 0, 0, -1, -1),\n                       y = c(-1, -1, 0, 0, -1))\ntbl_mpol2 &lt;- data.frame(x = c(0, 1, 1, 0, 0),\n                       y = c(0, 0, 1, 1, 0))\nmpol &lt;- st_sfc(st_multipolygon(list(list(as.matrix(tbl_mpol1)), list(as.matrix(tbl_mpol2)))), crs = 4326)\n\n# Create GEOMETRYCOLLECTION\ngc &lt;- st_sfc(st_geometrycollection(\n  list(\n    st_multipoint(as.matrix(tbl_mpoi)),\n    st_linestring(as.matrix(tbl_lin))\n  )\n), crs = 4326)\n\nnames_geometries &lt;- c(\n  \"POINT\", \"MULTIPOINT\",\n  \"LINESTRING\", \"MULTILINESTRING\",\n  \"POLYGON\", \"MULTIPOLYGON\",\n  \"GEOMETRYCOLLECTION\"\n  )\n# Clean workspace\nrm(list = ls(pattern = \"^tbl_\"))\nrm(list = ls(pattern = \"min|max\"))\n\n# Combine all objects into an sf object for viewing\nsf_objects &lt;- st_sf(\n  geometry = c(poi, mpoi, lin, mlin, pol, mpol, gc), \n  type = names_geometries\n  )\n\n\ntheme_custom &lt;- function(...){\n  theme_minimal() +\n    theme(\n      axis.ticks = element_blank(),\n      axis.text = element_blank(),\n      ...\n      )\n}\n\n# basic geometries made\nsf_objects |&gt; \n  ggplot() +\n  geom_sf() +\n  facet_wrap(~type)\n\nblank_numbers &lt;- c(\n  4, 5, 6, 7,\n  12, 13, 14,\n  19, 20, 21, 26, 27, 28,\n  33, 34, 35, 38,\n  41, 42, \n  45, 46, 47, 48\n)\n\nfor (i in 1:7){\n  original_geometry = names_geometries[i]\n\n  for (j in 1:7){\n    plot_number &lt;- ((7 * (i-1)) + j)\n  \n    if (plot_number %in% blank_numbers) {\n      assign(\n        paste0(\"g\", ((7 * (i-1)) + j)),\n        ggplot() + theme_custom()\n      )\n    } else {\n      temp &lt;- sf_objects |&gt; \n        filter(type == original_geometry) |&gt; \n        st_cast(names_geometries[j])\n      assign(\n        paste0(\"g\", ((7 * (i-1)) + j)),\n        ggplot(temp) +\n          geom_sf() +\n          scale_x_continuous(position = \"top\") +\n          theme_custom()\n        )\n      }\n    }\n}\n\ng &lt;- patchwork::wrap_plots(\n  mget(paste0(\"g\", 1:49))\n) +\n  patchwork::plot_layout(\n    ncol = 7, nrow = 7\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-2-8_1.png\"),\n  plot = g,\n  height = 7800,\n  width = 7800,\n  units = \"px\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "book_solutions/chapter5.html#geometric-operations-on-raster-data",
    "href": "book_solutions/chapter5.html#geometric-operations-on-raster-data",
    "title": "Chapter 5: Geometry operations",
    "section": "5.3 Geometric operations on raster data",
    "text": "5.3 Geometric operations on raster data\n\nGeometric raster operations include shifting, flipping, mirroring, scaling, rotation, and warping of images. Purpose:\n\nEnable georeferencing for overlaying images on accurate maps with a known CRS (Coordinate Reference System).\nApplications include georectification, orthorectification, and image registration.\n\nTechniques:\n\nGeorectification: Uses known ground control points for alignment (Liu and Mason 2009) (Loecher and Ropkins 2015).\nOrthorectification: Accounts for local topography.\nImage Registration: Aligns images from different sensors by matching their coordinate systems and resolutions.\n\nSuitability of R:\n\nManual operations like georectification and orthorectification are better handled in GIS software like QGIS.\nR is suitable for aligning multiple images by modifying extent, resolution, and origin.\n\n\n\n5.3.1 Geometric Intersections\n\nPurpose:\n\nExtract raster values: Use spatial objects overlaid on a raster to extract values with subsetting syntax.\nKeep spatial output: To retain a spatial output (e.g., raster structure), set drop = FALSE during subsetting.\nRaster midpoints: Returns a raster object containing cells whose midpoints overlap with the clip area.\n\nComparison of Base R [] vs. terra::crop() shown in Figure 8\n\n\n\n\n\n\n\n\n\nFeature\nBase R [] Subsetting\nterra::crop()\n\n\n\n\nPurpose\nGeneral selection of raster values\nSpatial clipping of rasters\n\n\nSpatial Metadata\nRequires manual handling\nAutomatically preserved\n\n\nSyntax\nraster[condition, drop = FALSE]\nterra::crop(raster, extent)\n\n\nKey Functionality\nSelects raster cells by condition\nClips raster to the provided extent\n\n\nRecommended For\nBasic operations, custom workflows\nEfficient raster clipping in geospatial analyses\n\n\n\nterra::crop() is often more efficient and user-friendly for spatial raster workflows with pipe operator (|&gt;) compared to base R’s [] subsetting.\n\n\nCode\nelev &lt;- rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nclip &lt;- rast(xmin = -0.5, xmax = 0.5, ymin = -1, ymax = 1,\n            resolution = 0.5, vals = rep(1, 8))\n\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = elev) +\n  scale_fill_grass_c(limits = c(1, 36)) +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5)) +\n  ggtitle(\"elev raster\") +\n  theme(legend.position = \"none\")\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = clip) +\n  scale_fill_grass_c(limits = c(1, 36)) +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5)) +\n  ggtitle(\"clip raster\") +\n  theme(legend.position = \"none\")\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = elev[clip, drop = FALSE]) +\n  scale_fill_grass_c(limits = c(1, 36)) +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5)) +\n  ggtitle(\"elev[clip, drop = FALSE]\") +\n  theme(legend.position = \"none\")\n\ng4 &lt;- ggplot() +\n  geom_spatraster(data = elev |&gt; terra::crop(clip)) +\n  scale_fill_grass_c(limits = c(1, 36)) +\n  scale_x_continuous(limits = c(-1.5, 1.5)) +\n  scale_y_continuous(limits = c(-1.5, 1.5)) +\n  ggtitle(\"elev |&gt; terra::crop(clip)\") +\n  theme(\n    legend.key.height = unit(10, \"pt\"),\n    legend.key.width = unit(4, \"pt\")\n  )\n\ng &lt;- g1 + g2 + g3 + g4 +\n  plot_layout(\n    nrow = 1\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-3-1_1.png\"),\n  plot = g,\n  height = 700,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 8: Comparing base R [] and terra::crop() for subsetting rasters\n\n\n\n\n\n5.3.2 Extent and Origin\n\nRaster alignment necessity: Mismatches in resolution, projection, origin, or extent must be addressed for map algebra or merging. For example, Adding a raster with a 0.2-degree resolution to one with a 1-degree resolution is impossible without alignment.\nExtent mismatch: Extending a raster adds rows/columns filled with NA values. Use extend() from the terra package for this.\nExtent alignment: Performing operations on rasters with differing extents throws an error. Solution: Use another raster as a reference to align extents via terra::extend().\n\nThe terra::extend() function in R enlarges the spatial extent of a SpatRaster or SpatExtent. It can add rows and columns, with values filled using the fill argument (default NA). The y argument specifies how much to extend, either as an extent object or numeric values indicating rows/columns to add. The snap argument controls alignment (“near”, “in”, “out”). Outputs can be saved using filename and overwrite.\n\nOrigin:\n\nThe origin is the raster cell corner closest to coordinates (0, 0). Use terra::origin() to retrieve or modify the raster origin.\nMisaligned origins cause raster cells not to overlap, making map algebra impossible. Adjust the origin with origin() to ensure proper alignment.\nIf two rasters are marginally apart, change tolerance argument for terra::terraOptions().\n\nVisualization: Figure 9 illustrates raster extension and Figure 10 shows the effect of origin changes.\n\n\n\nCode\nsysfonts::font_add_google(\"Fira Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 18\n  )\n)\nelev &lt;-  rast(system.file(\"raster/elev.tif\", \n                          package = \"spData\"))\nelev2 &lt;- elev |&gt; extend(c(1,2), fill = 36)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = elev) +\n  scale_fill_grass_c() +\n  labs(\n    title = \"Base Raster elev\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = elev |&gt; extend(c(1,2), fill = 36)) +\n  scale_fill_grass_c() +\n  labs(\n    title = \"elev |&gt; extend(c(1,2), fill = 36) \"\n  )\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = elev |&gt; extend(elev2, fill = 1)) +\n  scale_fill_grass_c() +\n  labs(\n    title = \"elev |&gt; extend(elev2)\"\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    guides = \"collect\"\n  ) + \n  plot_annotation(\n    title = \"Extending rasters with terra::extend()\",\n    theme = theme(\n      legend.title = element_blank(),\n      plot.title = element_text(\n        size = 42\n      ),\n      plot.subtitle = element_text(\n        size = 24\n      )\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-3-2_2.png\"),\n  plot = g,\n  height = 800,\n  width = 2000,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 9: Use of terra::extend() to increase or decrease size of rasters\n\n\n\n\n\nCode\nsysfonts::font_add_google(\"Fira Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 18\n  )\n)\n\nelev &lt;-  rast(system.file(\"raster/elev.tif\", \n                          package = \"spData\"))\n\ng1 &lt;- ggplot() +\n  geom_spatraster(\n    data = elev,\n    alpha = 0.9\n  ) +\n  scale_fill_grass_c() +\n  ggtitle(\"Original Raster\")\n\nelev2 &lt;- elev\norigin(elev2) &lt;- c(0.2 , 0.2)\ng2 &lt;- g1 + \n  geom_spatraster(\n    data = elev2,\n    alpha = 0.9\n  ) +\n  labs(\n    title = \"Origin shifted by c(0.2, 0.2)\",\n    subtitle = \"Shifting along x and y axes.\")\n\nelev3 &lt;- elev\norigin(elev3) &lt;- c(0.6 , 0.1)\ng3 &lt;- g1 +\n  geom_spatraster(\n    data = elev3,\n    alpha = 0.9\n  ) +\n  labs(\n    title = \"Origin shifted by c(0.6, 0.1)\",\n    subtitle = \"Shifting by remainder beyond division by resolution.\")\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    guides = \"collect\"\n  ) + \n  plot_annotation(\n    title = \"Effects of changing terra::origin() of a SpatRaster\",\n    subtitle = \"Changing by more than half of resolution results in shifting by +/- amount of remainder of division of origin shift by resolution\",\n    theme = theme(\n      legend.title = element_blank(),\n      plot.title = element_text(\n        size = 42\n      ),\n      plot.subtitle = element_text(\n        size = 24\n      )\n    )\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-3-2_1.png\"),\n  plot = g,\n  height = 800,\n  width = 2000,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 10: Using terra::origin() to change origin of a raster in relation to c(0,0)\n\n\n\n\n\n5.3.3 Aggregation and Disaggregation\n\nRaster Resolution Adjustments:\n\nAggregation: Decreases raster resolution using the aggregate() function.\nDisaggregation: Increases raster resolution using the disagg() function.\n\nAggregation Details: The output cell values represent the mean of input cells. Other functions like median(), sum(), etc., can also be applied.\n\nEffect on Resolution: Aggregation increases resolution by reducing rows and columns.\n\nDisaggregation Details: 2 Methods are shown in Figure 11\n\nDefault (method = \"near\"): Duplicates input cell values, creating a ‘blocky’ output.\nBilinear (method = \"bilinear\"): Computes output values using a weighted average of the four nearest input pixel centers.\nAccuracy: Results in finer resolution, but values are interpolations of the lower-resolution source.\n\nComparison of Rasters:\n\nAggregated and disaggregated rasters differ from the original raster.\nUse functions like compareGeom() or all.equal() to identify differences.\n\nKey Considerations:\n\nAggregation simplifies data, while disaggregation interpolates it, often leading to approximate values based on the source resolution.\nResolution changes impact raster extent, dimensions, and data accuracy.\n\n\n\n\nCode\noriginal_raster &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = original_raster) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Original Raster\",\n    subtitle = paste0(\n      \"Resolution: \", \n      terra::res(original_raster) |&gt; \n        round(1) |&gt; \n        paste0(collapse = \", \"),\n      \"\\nDimensions: \",\n      dim(original_raster)[1:2] |&gt; \n        paste0(collapse = \", \")\n    )\n  )\n\nagg_raster &lt;- terra::aggregate(\n  x = original_raster, \n  fact = 5, \n  fun = mean\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = agg_raster) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Aggregation by factor of 5\",\n    subtitle = paste0(\n      \"Resolution: \", \n      terra::res(agg_raster) |&gt; \n        round(1) |&gt; \n        paste0(collapse = \", \"),\n      \"\\nDimensions: \",\n      dim(agg_raster)[1:2] |&gt; \n        paste0(collapse = \", \")\n    )\n  )\n\n\ndisagg_raster1 &lt;- terra::disagg(\n  x = agg_raster,\n  fact = 5,\n  method = \"near\"\n)\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = disagg_raster1) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Dis-Aggregation (method = near)\",\n    subtitle = paste0(\n      \"Resolution: \", \n      terra::res(disagg_raster1) |&gt; \n        round(1) |&gt; \n        paste0(collapse = \", \"),\n      \"\\nDimensions: \",\n      dim(disagg_raster1)[1:2] |&gt; \n        paste0(collapse = \", \")\n    )\n  )\n\ndisagg_raster2 &lt;- terra::disagg(\n  x = agg_raster,\n  fact = 5,\n  method = \"bilinear\"\n)\n\ng4 &lt;- ggplot() +\n  geom_spatraster(data = disagg_raster2) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Dis-Aggregation (method = bilinear)\",\n    subtitle = paste0(\n      \"Resolution: \", \n      terra::res(disagg_raster2) |&gt; \n        round(1) |&gt; \n        paste0(collapse = \", \"),\n      \"\\nDimensions: \",\n      dim(disagg_raster2)[1:2] |&gt; \n        paste0(collapse = \", \")\n    )\n  )\n\ng &lt;- g1 + g2 + g3 + g4 +\n  plot_layout(\n    guides = \"collect\",\n    nrow = 1\n  ) + \n  plot_annotation(\n    title = \"Aggregating and Disaggregating rasters\",\n    subtitle = \"Disaggregating a raster will not revert to original details as some data is lost.\",\n    theme = theme(\n      legend.title = element_blank(),\n      plot.title = element_text(\n        size = 42\n      ),\n      plot.subtitle = element_text(\n        size = 18\n      )\n    )\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-3-3_1.png\"),\n  plot = g,\n  height = 1800,\n  width = 5400,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 11: Aggregating and Disaggregating a raster by a factor of 5. Note the superiority of blinear method of disaggregatiion.\n\n\n\n\n\n5.3.4 Resampling\n\nPurpose: Adjusts pixel values for a target raster with different resolution and origin than the original raster (terra). Useful for combining rasters with varying resolutions/origins.\nMethods: A comparison table on resampling methods available in the {terra} package’s resample() function with examples in Figure 12\n\n\n\n\n\n\n\n\n\n\n\n\nNo.\nMethod\nDescription\nSuitable For\nComplexity\nUse Case\n\n\n\n\n1\nNearest Neighbor\nAssigns the value of the nearest cell of the original raster to the target cell.\nCategorical rasters\nSimple\nDiscrete data like land-use classifications\n\n\n2\nBilinear Interpolation\nComputes a weighted average of the four nearest cells from the original raster for the target cell.\nContinuous rasters\nModerate\nContinuous data; smoother transitions, elevation models or temperature data.\n\n\n3\nCubic Interpolation\nUses the values of the 16 nearest cells, applying third-order polynomial functions for smooth output.\nContinuous rasters\nHigher\nContinuous data requiring smoother surfaces; resampling satellite imagery.\n\n\n4\nCubic Spline Interpolation\nUses the 16 nearest cells, applying cubic splines (piece-wise third-order polynomial functions).\nContinuous rasters\nHigher\nContinuous data where smoothness is crucial; terrain modeling.\n\n\n5\nLanczos Resampling\nUses the 36 nearest cells with a Lanczos windowed sinc function for smoother outputs.\nContinuous rasters\nHigh\nBest for high-quality image scaling; maintains sharpness and reduces aliasing in photographic images.\n\n\n6\nSum\nCalculates the weighted sum of all non-NA contributing grid cells.\nSpatially extensive variables\nVariable\nAggregating data like population counts; ensures the total sum remains consistent.\n\n\n7\nMin\nFinds the minimum value among all non-NA contributing grid cells.\nContinuous rasters\nVariable\nWhere the minimum value is of interest, such as finding the lowest temperature in a region.\n\n\n8\nQ1 (First Quartile)\nComputes the first quartile value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nTo understand the lower distribution of data values.\n\n\n9\nMedian (Med)\nComputes the median value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nReducing the impact of outliers; in skewed data distributions.\n\n\n10\nQ3 (Third Quartile)\nComputes the third quartile value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nFocussing on the upper distribution of data values.\n\n\n11\nMax\nFinds the maximum value among all non-NA contributing grid cells.\nContinuous rasters\nVariable\nIdentifying peak values, such as maximum elevation or highest temperature.\n\n\n12\nAverage\nCalculates the mean value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nFor smoothing data; provides an overall average.\n\n\n13\nMode\nIdentifies the most frequent value among all non-NA contributing grid cells.\nContinuous rasters\nVariable\nFor categorical data; to determine the most common land cover type.\n\n\n14\nRMS (Root Mean Square)\nComputes the root mean square of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nIn error analysis; For assessing the variability in data values.\n\n\n\n\nNotes:\n\nNearest Neighbor is the preferred method for categorical data to prevent the creation of non-existent categories.\nBilinear, Cubic, Cubic Spline, and Lanczos methods are more appropriate for continuous data, offering varying degrees of smoothness and detail preservation.\n\nCategorical vs. Continuous:\n\nOnly nearest neighbor is suitable for categorical rasters.\nOther methods can be used for continuous rasters but vary in outcomes, complexity, and processing time.\n\nAdditional Options:\n\nStatistical Resampling:\n\nMethods like sum, min, med, mode, and rms compute statistics over contributing cells.\nExample: sum ensures the total remains unchanged for spatially extensive variables (e.g., population).\n\n\nImplementation in terra:\n\nUse the resample() function (documentation).\nRequires:\n\nInput Raster (x): Original raster.\nTarget Raster (y): Raster with desired resolution/origin.\nMethod: Resampling method (e.g., “bilinear”).\n\n\nNote: Raster Re-projection is a special case of raster re-sampling. A specific type of re-sampling used for target rasters with different Coordinate Reference Systems (CRS).\n\n\n\nCode\nsysfonts::font_add_google(\"Encode Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\noriginal_raster &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\nresampling_methods_tbl &lt;- tibble(\n  name = c(\n    \"near\",\n    \"bilinear\",\n    \"cubic\",\n    \"cubicspline\",\n    \"lanczos\",\n    \"sum\",\n    \"min\",\n    \"q1\",\n    \"median\",\n    \"q3\",\n    \"max\",\n    \"average\",\n    \"mode\",\n    \"rms\"\n  ),\n  description = c(\n    \"Nearest Neighbor\",\n    \"Bilinear Interpolation\",\n    \"Cubic Interpolation\",\n    \"Cubic Spline Interpolation\",\n    \"Lanczos Resampling\",\n    \"Sum\",\n    \"Minimum\",\n    \"First Quartile\",\n    \"Median\",\n    \"Third Quartile\",\n    \"Maximum\",\n    \"Average (Mean)\",\n    \"Mode\",\n    \"Root Mean Square\"\n  )\n)\n\n# A Target Raster for re-sampling\ntarget_rast &lt;- rast(xmin = 794650, xmax = 798250, \n                   ymin = 8931750, ymax = 8935350,\n                   resolution = 100, crs = \"EPSG:32717\")\n\ntheme_custom &lt;- function(...){\n  ggthemes::theme_map(\n    base_family = \"body_font\",\n    base_size = 45\n  ) +\n    theme(\n      plot.title = element_text(\n        size = 45, \n        margin = margin(0,0,2,0, \"mm\")\n      ),\n      legend.position = \"bottom\",\n      legend.text = element_text(\n        margin = margin(1,0,0,0, \"mm\")\n      ),\n      plot.margin = margin(0,0,0,0, \"mm\"),\n      ...\n    )\n}\n\n\n\n\nCode\ng1 &lt;- ggplot() +\n  geom_spatraster(data = original_raster) +\n  scale_fill_wiki_c() +\n  coord_sf(expand = F) +\n  labs(\n    title = \"Original Raster\"\n  ) +\n  guides(fill = \"none\") +\n  theme_custom()\n\nfor (i in c(2:7, 11, 12, 13, 14)) {\n  assign(\n    paste0(\"g\", i),\n    ggplot() +\n      geom_spatraster(\n        data = terra::resample(\n          x = original_raster,\n          y = target_rast,\n          method = resampling_methods_tbl$name[i]\n        )\n      ) +\n      scale_fill_wiki_c() +\n      coord_sf(expand = F) +\n      labs(\n        title = paste0(resampling_methods_tbl$description[i]),\n        fill = NULL\n      ) +\n      theme_custom(\n        legend.key.height = unit(2, \"mm\"),\n        legend.key.width = unit(20, \"mm\")\n      )\n  )\n}\n\ng &lt;- g1 + g2 + g3 + g4 + g5 + g7 + g12 + g13 + g14 + \n  plot_layout(\n    guides = \"collect\",\n  ) + \n  plot_annotation(\n    title = \"Methods for Re-sampling rasters with {terra}\",\n    theme = theme(\n      legend.title = element_blank(),\n      plot.title = element_text(\n        size = 75,\n        margin = margin(5,0,5,0, \"mm\"),\n        hjust = 0.5\n      ),\n      legend.position = \"bottom\"\n    )\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-3-4_1.png\"),\n  plot = g,\n  height = 2400 * 5/4,\n  width = 2400,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 12: Various methods for re-sampling a raster with terra::resample()\n\n\n\n\n\nCode\n# Load required libraries\nlibrary(tibble)\nlibrary(gt)\n\n# Create the resampling methods table as a tibble\nresampling_methods &lt;- tibble::tibble(\n  `Resampling Method` = c(\n    \"Nearest Neighbor\", \"Bilinear Interpolation\", \"Cubic Interpolation\", \n    \"Cubic Spline Interpolation\", \"Lanczos Resampling\", \"Sum\", \"Min\", \n    \"Q1 (First Quartile)\", \"Median (Med)\", \"Q3 (Third Quartile)\", \n    \"Max\", \"Average\", \"Mode\", \"RMS (Root Mean Square)\"\n  ),\n  Description = c(\n    \"Assigns the value of the nearest cell of the original raster to the target cell.\",\n    \"Computes a weighted average of the four nearest cells from the original raster for the target cell.\",\n    \"Uses the values of the 16 nearest cells, applying third-order polynomial functions for smooth output.\",\n    \"Uses the 16 nearest cells, applying cubic splines (piece-wise third-order polynomial functions).\",\n    \"Uses the 36 nearest cells with a Lanczos windowed sinc function for smoother outputs.\",\n    \"Calculates the weighted sum of all non-NA contributing grid cells.\",\n    \"Finds the minimum value among all non-NA contributing grid cells.\",\n    \"Computes the first quartile value of all non-NA contributing grid cells.\",\n    \"Computes the median value of all non-NA contributing grid cells.\",\n    \"Computes the third quartile value of all non-NA contributing grid cells.\",\n    \"Finds the maximum value among all non-NA contributing grid cells.\",\n    \"Calculates the mean value of all non-NA contributing grid cells.\",\n    \"Identifies the most frequent value among all non-NA contributing grid cells.\",\n    \"Computes the root mean square of all non-NA contributing grid cells.\"\n  ),\n  `Suitable For` = c(\n    \"Categorical rasters\", \"Continuous rasters\", \"Continuous rasters\", \n    \"Continuous rasters\", \"Continuous rasters\", \"Spatially extensive variables\", \n    \"Continuous rasters\", \"Continuous rasters\", \"Continuous rasters\", \n    \"Continuous rasters\", \"Continuous rasters\", \"Continuous rasters\", \n    \"Continuous rasters\", \"Continuous rasters\"\n  ),\n  Complexity = c(\n    \"Simple\", \"Moderate\", \"Higher\", \"Higher\", \"High\", \"Variable\", \n    \"Variable\", \"Variable\", \"Variable\", \"Variable\", \"Variable\", \n    \"Variable\", \"Variable\", \"Variable\"\n  ),\n  `Processing Time` = c(\n    \"Fast\", \"Fast\", \"Moderate\", \"Moderate\", \"High\", \"Variable\", \n    \"Variable\", \"Variable\", \"Variable\", \"Variable\", \"Variable\", \n    \"Variable\", \"Variable\", \"Variable\"\n  ),\n  `Use Case` = c(\n    \"Ideal for discrete data like land-use classifications; preserves original values without alteration.\",\n    \"Suitable for continuous data; provides smoother transitions, useful for elevation models or temperature data.\",\n    \"Appropriate for continuous data requiring smoother surfaces; beneficial for resampling satellite imagery.\",\n    \"Effective for continuous data where smoothness is crucial; often used in terrain modeling.\",\n    \"Best for high-quality image scaling; maintains sharpness and reduces aliasing in photographic images.\",\n    \"Useful for aggregating data like population counts; ensures the total sum remains consistent after resampling.\",\n    \"Applied in scenarios where the minimum value is of interest, such as finding the lowest temperature in a region.\",\n    \"Useful in statistical analyses to understand the lower distribution of data values.\",\n    \"Ideal for reducing the impact of outliers; provides a central tendency measure in skewed data distributions.\",\n    \"Beneficial for statistical analyses focusing on the upper distribution of data values.\",\n    \"Suitable for identifying peak values, such as maximum elevation or highest temperature in a dataset.\",\n    \"Commonly used for smoothing data; provides an overall average, useful in environmental data analyses.\",\n    \"Effective for categorical data to determine the most common category, such as predominant land cover type.\",\n    \"Applied in error analysis; useful for assessing the magnitude of variability in data values.\"\n  )\n)\n\n# Display the table using gt\nresampling_methods |&gt; \n  gt::gt() |&gt; \n  gt::tab_header(\n    title = \"Resampling Methods for rasters in {terra}\"\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 2: Comparison of Resampling Methods for rasters in\n\n\n\n\n\n\n\n\n\nResampling Methods for rasters in {terra}\n\n\nResampling Method\nDescription\nSuitable For\nComplexity\nProcessing Time\nUse Case\n\n\n\n\nNearest Neighbor\nAssigns the value of the nearest cell of the original raster to the target cell.\nCategorical rasters\nSimple\nFast\nIdeal for discrete data like land-use classifications; preserves original values without alteration.\n\n\nBilinear Interpolation\nComputes a weighted average of the four nearest cells from the original raster for the target cell.\nContinuous rasters\nModerate\nFast\nSuitable for continuous data; provides smoother transitions, useful for elevation models or temperature data.\n\n\nCubic Interpolation\nUses the values of the 16 nearest cells, applying third-order polynomial functions for smooth output.\nContinuous rasters\nHigher\nModerate\nAppropriate for continuous data requiring smoother surfaces; beneficial for resampling satellite imagery.\n\n\nCubic Spline Interpolation\nUses the 16 nearest cells, applying cubic splines (piece-wise third-order polynomial functions).\nContinuous rasters\nHigher\nModerate\nEffective for continuous data where smoothness is crucial; often used in terrain modeling.\n\n\nLanczos Resampling\nUses the 36 nearest cells with a Lanczos windowed sinc function for smoother outputs.\nContinuous rasters\nHigh\nHigh\nBest for high-quality image scaling; maintains sharpness and reduces aliasing in photographic images.\n\n\nSum\nCalculates the weighted sum of all non-NA contributing grid cells.\nSpatially extensive variables\nVariable\nVariable\nUseful for aggregating data like population counts; ensures the total sum remains consistent after resampling.\n\n\nMin\nFinds the minimum value among all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nApplied in scenarios where the minimum value is of interest, such as finding the lowest temperature in a region.\n\n\nQ1 (First Quartile)\nComputes the first quartile value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nUseful in statistical analyses to understand the lower distribution of data values.\n\n\nMedian (Med)\nComputes the median value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nIdeal for reducing the impact of outliers; provides a central tendency measure in skewed data distributions.\n\n\nQ3 (Third Quartile)\nComputes the third quartile value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nBeneficial for statistical analyses focusing on the upper distribution of data values.\n\n\nMax\nFinds the maximum value among all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nSuitable for identifying peak values, such as maximum elevation or highest temperature in a dataset.\n\n\nAverage\nCalculates the mean value of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nCommonly used for smoothing data; provides an overall average, useful in environmental data analyses.\n\n\nMode\nIdentifies the most frequent value among all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nEffective for categorical data to determine the most common category, such as predominant land cover type.\n\n\nRMS (Root Mean Square)\nComputes the root mean square of all non-NA contributing grid cells.\nContinuous rasters\nVariable\nVariable\nApplied in error analysis; useful for assessing the magnitude of variability in data values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlternatives to {terra} Functions\n\n\n\n\nWhy Alternatives? While {terra} is user-friendly and performs well for large rasters, it may not be the most efficient for extensive rasters or numerous raster files.\nKey Alternatives via C++ Library GDAL (accessed via {gdalUtilities} or sf::gdal_utils() function):\n\ngdalinfo:\n\nProvides detailed information about a raster file (e.g., resolution, CRS, bounding box).\nUseful for metadata exploration.\n\ngdal_translate:\n\nConverts raster files between formats.\nCan also modify properties like compression or CRS (e.g., t_srs = \"EPSG:4326\").\n\ngdal_rasterize:\n\nConverts vector data into raster format.\nIdeal for creating rasterized maps from vector datasets.\n\ngdalwarp:\n\nPerforms raster mosaicing, cropping, resampling, and reprojection.\nEssential for combining rasters, altering extents, or changing resolutions.\n\n\nIntegration with R:\n\nGDAL functions are written in C++ but can be accessed in R using:\n\nsf::gdal_utils(): Wrapper for calling GDAL functions.\ngdalUtilities package: Dedicated functions for common GDAL tasks.\nSystem Commands: Directly call GDAL commands from the terminal within R.\n\nInput/output handling:\n\nGDAL functions work with file paths. Output is often saved as a file rather than in-memory objects like {terra}’s SpatRaster.\n\n\nWhen to Use GDAL:\n\nFor handling very large datasets or batch processing of raster files.\nWhen advanced raster operations (e.g., raster mosaics) are required.\nFor compatibility with diverse raster file formats and global standards."
  },
  {
    "objectID": "book_solutions/chapter5.html#exercises",
    "href": "book_solutions/chapter5.html#exercises",
    "title": "Chapter 5: Geometry operations",
    "section": "5.4 Exercises",
    "text": "5.4 Exercises\n\nE1.\nGenerate and plot simplified versions of the nz dataset. Experiment with different values of keep (ranging from 0.5 to 0.00005) for ms_simplify() and dTolerance (from 100 to 100,000) st_simplify().\nThe plots for different levels of keep in ms_simplify() are shown in Figure 13.\n\nCode\ndata(\"nz\")\n\nfor (i in c(0.5, 0.05, 0.005, 0.0005, 0.00005)) {\n  g &lt;- ggplot(\n    data = nz |&gt; rmapshaper::ms_simplify(keep = i)\n  ) +\n    geom_sf() +\n    theme_minimal() +\n    theme(\n      panel.grid = element_line(\n        linewidth = 0.3, \n        linetype = 3\n      )\n    ) +\n    labs(\n      title = paste0(\"st_simplify(keep = \", i, \")\")\n    )\n  print(g)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n(a) keep = 0.5\n\n\n\n\n\n\n\n\n\n\n\n(b) keep = 0.05\n\n\n\n\n\n\n\n\n\n\n\n(c) keep = 0.005\n\n\n\n\n\n\n\n\n\n\n\n(d) keep = 0.0005\n\n\n\n\n\n\n\n\n\n\n\n(e) keep = 0.00005\n\n\n\n\n\n\n\nFigure 13: Different keep levels in rmapshaper::ms_simplify()\n\n\n\nThe plots for different levels of dTolerance within st_simplify() are in Figure 14.\n\nCode\ndata(\"nz\")\n\nfor (i in c(100, 1000, 10000, 100000)) {\n  g &lt;- ggplot(\n    data = nz |&gt; st_simplify(dTolerance = i)\n  ) +\n    geom_sf() +\n    theme_minimal() +\n    theme(\n      panel.grid = element_line(\n        linewidth = 0.3, \n        linetype = 3\n      )\n    ) +\n    labs(\n      title = paste0(\"st_simplify(dTolerance = \", i, \")\")\n    )\n  print(g)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n(a) dTolerance = 100\n\n\n\n\n\n\n\n\n\n\n\n(b) dTolerance = 1000\n\n\n\n\n\n\n\n\n\n\n\n(c) dTolerance = 10000\n\n\n\n\n\n\n\n\n\n\n\n(d) dTolerance = 100000\n\n\n\n\n\n\n\nFigure 14: Different dTolerance levels in st_simplify()\n\n\n\n\nAt what value does the form of the result start to break down for each method, making New Zealand unrecognizable?\nFor the rmapshaper::ms_simplify() method, the result starts to break down at keep = 0.005 . For the sf::st_simplify() method, the result starts to break down around dTolerance = 10000 .\nAdvanced: What is different about the geometry type of the results from st_simplify() compared with the geometry type of ms_simplify()? What problems does this create and how can this be resolved?\nThe results from st_simplify() can be of multiple geometry types: MULTIPOLYGON or POLYGON, where as the results from ms_simplify() are always of a single geometry type: POLYGON.\nProblems Created by st_simplify()\n\nThe invalid geometries produced by st_simplify() can lead to errors in subsequent spatial operations, such as overlays, spatial joins, or intersections.\nFor example, functions like st_intersection() or st_union() may fail or produce incorrect results when operating on invalid geometries.\n\nResolution: Using st_cast() to convert all geometries into a single type.\n\n\n# Number of features in New Zealand Dataset\nnrow(nz)\n\n[1] 16\n\n# New Zealand data after st_simplify(): some features are MULTIPLOYGON, and some are POLYGON\nnz |&gt; \n  st_simplify(dTolerance = 1000) |&gt; \n  st_as_sfc()\n\nGeometry set for 16 features \nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 1090144 ymin: 4748537 xmax: 2089533 ymax: 6191874\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 5 geometries:\n\n# Resolution: cast them into any one type using st_cast()\nnz |&gt; \n  st_simplify(dTolerance = 1000) |&gt; \n  st_as_sfc() |&gt; \n  st_cast(\"POLYGON\")\n\nGeometry set for 16 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 1090144 ymin: 4823273 xmax: 2089533 ymax: 6191874\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 5 geometries:\n\nnz |&gt; \n  st_simplify(dTolerance = 1000) |&gt; \n  st_as_sfc() |&gt; \n  st_cast(\"MULTIPOLYGON\")\n\nGeometry set for 16 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 1090144 ymin: 4748537 xmax: 2089533 ymax: 6191874\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 5 geometries:\n\nnz |&gt; \n  rmapshaper::ms_simplify(keep = 0.005) |&gt; \n  st_as_sfc()\n\nGeometry set for 14 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 1091224 ymin: 4830067 xmax: 2049387 ymax: 6001802\nProjected CRS: NZGD2000 / New Zealand Transverse Mercator 2000\nFirst 5 geometries:\n\n\n\n\nE2.\nIn the first exercise in Chapter Spatial Data Operations it was established that Canterbury region had 70 of the 101 highest points in New Zealand. Using st_buffer(), how many points in nz_height are within 100 km of Canterbury?\nOut of the 101 heights, 95 of them fall within 100 km of the Canterbury region, as explained in the code below, and as shown in Figure 15\n\ndata(\"nz_height\")\n\nnz_height |&gt; nrow()\n\n[1] 101\n\ncanterbury_bf &lt;- nz |&gt; \n  filter(Name == \"Canterbury\") |&gt; \n  st_buffer(dist = 100000)\n\nnz_height |&gt; \n  st_filter(canterbury_bf) |&gt; \n  nrow()\n\n[1] 95\n\n\n\n\nCode\nselected &lt;- nz_height |&gt; \n  st_filter(canterbury_bf) |&gt; \n  pull(t50_fid)\n\nnz_height &lt;- nz_height |&gt; \n  mutate(colour_var = t50_fid %in% selected)\n\nggplot() +\n  geom_sf(data = nz) +\n  geom_sf(\n    data = canterbury_bf,\n    fill = alpha(\"red\", 0.1)\n  ) +\n  geom_sf(\n    data = nz_height,\n    mapping = aes(colour = colour_var),\n    alpha = 0.7,\n    pch = 17\n  ) +\n  scale_colour_manual(\n    values = c(\"blue\", \"red\")\n  ) +\n  labs(\n    colour = \"Within 100 km\\nof Canterbury?\"\n  )\n\n\n\n\n\n\n\n\nFigure 15\n\n\n\n\n\n\n\nE3.\nFind the geographic centroid of New Zealand. How far is it from the geographic centroid of Canterbury?\n\ndata(nz)\n\nnz_centre &lt;- nz |&gt; \n  # Combining entire New Zealand into a geometry\n  st_union() |&gt; \n  st_centroid()\n\n# Geographic Centroid of New Zealand\nnz_centre |&gt; \n  st_transform(crs = 4326) |&gt; \n  as_vector() |&gt; \n  round(digits = 3) |&gt; \n  paste0(c(\" Longitude;  \", \" Latitude\"), collapse = \"\")\n\n[1] \"172.842 Longitude;  -41.684 Latitude\"\n\ncanterbury_centre &lt;- nz |&gt; \n  filter(Name == \"Canterbury\") |&gt; \n  st_centroid() |&gt; \n  st_as_sfc()\n\n# Geographic Centroid of Canterbury\ncanterbury_centre |&gt; \n  st_transform(crs = 4326) |&gt; \n  as_vector() |&gt; \n  round(digits = 3) |&gt; \n  paste0(c(\" Longitude;  \", \" Latitude\"), collapse = \"\")  \n\n[1] \"171.572 Longitude;  -43.573 Latitude\"\n\n# Distance between the two centroid\nst_distance(nz_centre, canterbury_centre) |&gt; \n  as.vector() |&gt; \n  multiply_by(0.001) |&gt; \n  round(digits = 2) |&gt; \n  paste0(\" km\")\n\n[1] \"234.19 km\"\n\nline_centres &lt;- st_union(\n  nz_centre,\n  canterbury_centre\n) |&gt; \n  st_cast(\"LINESTRING\")\n\nggplot() +\n  geom_sf(\n    data = nz, \n    mapping = aes(fill = Name == \"Canterbury\"),\n    colour = \"white\"\n  ) +\n  scale_fill_manual(values = c(alpha(\"blue\", 0.2), \n                               alpha(\"red\", 0.2))) +\n  geom_sf(data = nz_centre, colour = \"blue\") +\n  geom_sf(data = canterbury_centre, colour = \"red\") +\n  geom_sf(data = line_centres, linetype = 3) +\n  labs(\n    title = paste0(\"Distance = \",\n                   st_distance(nz_centre, canterbury_centre) |&gt; \n                      as.vector() |&gt; \n                      multiply_by(0.001) |&gt; \n                      round(digits = 2) |&gt; \n                      paste0(\" km\")\n                  )\n  ) +\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\nE4.\nMost world maps have a north-up orientation. A world map with a south-up orientation could be created by a reflection (one of the affine transformations not mentioned in this chapter) of the world object’s geometry. Write code to do so. Hint: you can to use the rotation() function from this chapter for this transformation. Bonus: create an upside-down map of your country.\nThe multiplication of an sfc object with custom function rotation(180) can be used to create a world map with south-up orientation, as shown in Figure 16 (b)\n\n\nCode\n# Use the rotation function from the textbook\nrotation &lt;- function(a){\n  r = a * pi / 180 #degrees to radians\n  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)\n} \ndata(\"world\")\nworld_up &lt;- world |&gt; \n  st_geometry()\n\nworld_rotate &lt;- (world_up * rotation(180)) |&gt; \n  st_set_crs(st_crs(world_up))\n\nggplot() +\n  geom_sf(data = world_up) +\n  coord_sf(crs = \"ESRI:54009\") +\n  theme_minimal()\n\nggplot() +\n  geom_sf(data = world_rotate) +\n  coord_sf(crs = \"ESRI:54009\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n(a) World map upright\n\n\n\n\n\n\n\n\n\n\n\n(b) World map upside-down\n\n\n\n\n\n\nFigure 16: Using a custom rotation() and multiplying the sfc object with rotation(180)\n\n\n\n\n\n\nE5.\nRun the code in Section 5.2.6. With reference to the objects created in that section, subset the point in p that is contained within xandy.\n\n# Create the two points\nb &lt;- st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) \n# Create circles around those points\nb &lt;- st_buffer(b, dist = 1)\n# Name x and y -- the two circles\nx = b[1]\ny = b[2]\nx_and_y = st_intersection(x, y)\n\n# Bounding box of x and y\nbb = st_bbox(st_union(x, y))\n# Covert bounding box into a polygon\nbox = st_as_sfc(bb)\nset.seed(2024)\np = st_sample(x = box, size = 10)\n\n\nUsing base subsetting operators. Answer is shown in Figure 17\n\np_xy1 = p[x_and_y]\n\nggplot() +\n  geom_sf(data = b, fill = \"transparent\") +\n  geom_sf(data = p, size = 2, alpha = 0.75) +\n  geom_sf(data = p_xy1, \n          colour = \"red\",\n          fill = \"transparent\",\n          pch = 1,\n          size = 6,\n          stroke = 2)\n\n\n\n\n\n\n\nFigure 17: Using base r [] operator\n\n\n\n\n\nUsing an intermediary object created with st_intersection(). Answer is shown in Figure 18\n\np1 &lt;- p |&gt; \n  st_as_sf() |&gt; \n  mutate(highlight = st_intersects(x, x_and_y, sparse = F))\n\nggplot() +\n  geom_sf(data = b, fill = \"transparent\") +\n  geom_sf(\n    data = p1,\n    mapping = aes(\n      colour = highlight\n    ),\n    size = 3\n  ) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nFigure 18: Using sf::st_intersection()\n\n\n\n\n\n\n\n\nE6.\nCalculate the length of the boundary lines of US states in meters. Which state has the longest border and which has the shortest? Hint: The st_length function computes the length of a LINESTRING or MULTILINESTRING geometry.\nThe longest border is of Texas (4,959.8 km) and the shortest border is of District of Columbia (60.2 km). The complete list is at Table 3 .\n\n\nCode\ndata(\"us_states\")\n\nus_states |&gt; \n  janitor::clean_names() |&gt; \n  st_cast(\"MULTILINESTRING\") |&gt; \n  mutate(border = as.numeric(st_length(geometry))/1000) |&gt; \n  st_drop_geometry() |&gt; \n  select(name, region, border) |&gt; \n  arrange(desc(border)) |&gt; \n  gt::gt() |&gt; \n  gt::cols_label(\n    name = \"State Name\",\n    region = \"Region\",\n    border = \"Length of Border (km)\"\n  ) |&gt; \n  gt::fmt_number(\n    columns = border\n  ) |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 3: The border length of the different states in USA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE7.\nRead the srtm.tif file into R (srtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))). This raster has a resolution of 0.00083 * 0.00083 degrees. Change its resolution to 0.01 * 0.01 degrees using all of the methods available in the terra package. Visualize the results. Can you notice any differences between the results of these re-sampling methods?\nThe different methods of resampling rasters and their demonstration is in Figure 19\n\n\nCode\nsysfonts::font_add_google(\"Encode Sans Condensed\", \"body_font\")\nshowtext::showtext_auto()\nsrtm &lt;- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\n\n# Create a target raster on which to re-sample\ntarget_rast &lt;- rast(\n  xmin = xmin(ext(srtm)), \n  xmax = xmax(ext(srtm)), \n  ymin = ymin(ext(srtm)), \n  ymax = ymax(ext(srtm)),\n  # resolution = res(srtm), \n  resolution = c(0.01, 0.01),\n  crs = crs(srtm)\n  )\n\noriginal_raster &lt;- srtm\n\nresampling_methods_tbl &lt;- tibble(\n  name = c(\n    \"bilinear\",\n    \"cubic\",\n    \"lanczos\",\n    \"min\",\n    \"average\",\n    \"mode\"\n  ),\n  description = c(\n    \"Bilinear Interpolation\",\n    \"Cubic Interpolation\",\n    \"Lanczos Resampling\",\n    \"Minimum\",\n    \"Average (Mean)\",\n    \"Mode\"\n  )\n)\n\ntheme_custom &lt;- function(...){\n  ggthemes::theme_map(\n    base_family = \"body_font\",\n    base_size = 36\n  ) +\n    theme(\n      plot.title = element_text(\n        size = 45, \n        margin = margin(0,0,2,0, \"mm\")\n      ),\n      legend.position = \"bottom\",\n      legend.text = element_text(\n        margin = margin(1,0,0,0, \"mm\")\n      ),\n      plot.margin = margin(0,0,0,0, \"mm\"),\n      ...\n    )\n}\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = original_raster) +\n  scale_fill_wiki_c() +\n  coord_sf(expand = F) +\n  labs(\n    title = \"Original Raster\"\n  ) +\n  guides(fill = \"none\") +\n  theme_custom()\n\nfor (i in 1:6) {\n  assign(\n    paste0(\"g\", i+1),\n    ggplot() +\n      geom_spatraster(\n        data = terra::resample(\n          x = original_raster,\n          y = target_rast,\n          method = resampling_methods_tbl$name[i]\n        )\n      ) +\n      scale_fill_wiki_c() +\n      coord_sf(expand = F) +\n      labs(\n        title = paste0(resampling_methods_tbl$description[i]),\n        fill = NULL\n      ) +\n      theme_custom(\n        legend.key.height = unit(2, \"mm\"),\n        legend.key.width = unit(20, \"mm\")\n      )\n  )\n}\n\ng &lt;- g1 + g2 + g3 + g4 + g5 + g6 + \n  plot_layout(\n    guides = \"collect\",\n  ) + \n  plot_annotation(\n    title = \"Methods for Re-sampling rasters with {terra}\",\n    theme = theme(\n      legend.title = element_blank(),\n      plot.title = element_text(\n        size = 60,\n        margin = margin(5,0,5,0, \"mm\"),\n        hjust = 0.5\n      ),\n      legend.position = \"bottom\"\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter5-e7.png\"),\n  plot = g,\n  height = 2400,\n  width = 2400,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 19: The various methods of resampling in the {terra} for rasters.\n\n\n\nAnother method for converting into the resolution of (0.01, 0.01) is to use terra::aggregate() with fact = 0.01 / 0.00083.\n\n\nCode\nsrtm &lt;- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\n\ntemp &lt;- srtm |&gt; \n  terra::aggregate(fact = 0.01 / 0.0008333333)\n\nggplot() +\n  geom_spatraster(data = temp) +\n  scale_fill_wiki_c() + \n  coord_sf(expand = FALSE) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nFigure 20: Using terra::aggregate() to make resolution of 0.01"
  },
  {
    "objectID": "book_solutions/chapter6.html",
    "href": "book_solutions/chapter6.html",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "",
    "text": "Focuses on interactions between raster and vector data models, first introduced in Chapter 2.\nCovers three main techniques:\n\nRaster cropping and masking using vector objects (Section 6.2).\nExtracting raster values based on vector data (Section 6.3).\nRaster-vector conversions, explained in Sections 6.4 and 6.5.\n\n\n\n\nCode\nlibrary(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(magrittr)  # Using pipes with raster objects\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\nlibrary(patchwork) # Composing plots"
  },
  {
    "objectID": "book_solutions/chapter6.html#introduction",
    "href": "book_solutions/chapter6.html#introduction",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "",
    "text": "Focuses on interactions between raster and vector data models, first introduced in Chapter 2.\nCovers three main techniques:\n\nRaster cropping and masking using vector objects (Section 6.2).\nExtracting raster values based on vector data (Section 6.3).\nRaster-vector conversions, explained in Sections 6.4 and 6.5.\n\n\n\n\nCode\nlibrary(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(magrittr)  # Using pipes with raster objects\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\nlibrary(patchwork) # Composing plots"
  },
  {
    "objectID": "book_solutions/chapter6.html#raster-cropping",
    "href": "book_solutions/chapter6.html#raster-cropping",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "6.2 Raster Cropping",
    "text": "6.2 Raster Cropping\n\nRaster cropping and masking unify spatial extents of data, reduce memory use, and optimize computational resources, especially for remote sensing rasters and vector boundaries integration.\nApplications:\n\nCrop rasters to fit an area of interest.\nMask values outside specified bounds.\nEssential preprocessing for creating maps and analyses.\n\nProjection Alignment:\n\nRasters and vectors must share the same projection.\nUse st_transform() from sf for re-projection.\n\nTypical Workflow: shown in Figure 1\n\nCrop raster to the area of interest: terra::crop().\nMask values outside the area: terra::mask().\nCombined operation ensures raster extent fits the area and external values are replaced with NA.\n\nterra::crop()\n\nPurpose: Reduces the extent of a raster object to match a defined area of interest.\nKey Arguments:\n\nx: The raster object to be cropped (e.g., a SpatRaster).\ny: The spatial object (e.g., SpatRaster, sf, or extent) defining the cropping area.\nsnap: Adjusts alignment of the cropped raster to match the target (options: \"near\", \"out\", \"in\").\n\nOutput: A cropped raster limited to the extent defined by y.\n\nterra::mask()\n\nPurpose: Sets raster cell values outside the defined spatial object to NA or a specified value.\nKey Arguments:\n\nx: The raster object to be masked.\nmask: The spatial object (e.g., SpatRaster, sf, or extent) defining the masking bounds.\ninverse: If TRUE, masks values inside the bounds instead of outside.\nupdatevalue: Sets a custom value (e.g., 0) for masked areas instead of NA.\n\nOutput: A raster with specified cells masked based on the spatial bounds of the second argument.\n\n\n\n\n\n\n\n\n\n\nAspect\ncrop() |&gt; mask()\nmask()\n\n\n\n\nExtent Modification\nReduces raster extent to vector’s bounding box\nRetains original raster extent\n\n\nOutput Size\nSmaller raster (optimized for memory)\nLarger raster (original extent retained)\n\n\nUse Case\nWhen reducing raster size is desired\nWhen full raster extent is needed but irrelevant cells must be excluded\n\n\n\n\n\nCode\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 20\n  )\n)\n\ntheme_custom &lt;- function(...){\n  theme(\n    panel.grid = element_line(\n      linewidth = 0.3,\n      linetype = 2\n    ),\n    plot.margin = margin(0,1,0,1, \"mm\"),\n    axis.text = element_text(\n      size = 8\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"mm\"),\n    legend.title = element_blank(),\n    legend.key.width = unit(2, \"mm\"),\n    legend.text = element_text(\n      margin = margin(0,0,0,0.5, \"mm\")\n    ),\n    legend.margin = margin(0,0,0,0, \"mm\"),\n    legend.box.margin = margin(0,0,0,0,\"mm\")\n  )\n}\n\nsrtm &lt;- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nzion &lt;- read_sf(system.file(\"vector/zion.gpkg\", \n                            package = \"spDataLarge\")) |&gt; \n  st_transform(st_crs(srtm))\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = srtm) +\n  geom_sf(data = zion, fill = NA) +\n  labs(title = \"Base Map: Raster and Vector\") +\n  scale_fill_whitebox_c() +\n  coord_sf(\n    xlim = c(-113.25, -112.85),\n    ylim = c(37.14, 37.51),\n    default_crs = 4326\n  ) +\n  theme_custom()\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; crop(zion)) +\n  geom_sf(data = zion, fill = NA) +\n  labs(title = \"terra::crop()\") +\n  scale_fill_whitebox_c() +\n  coord_sf(\n    xlim = c(-113.25, -112.85),\n    ylim = c(37.14, 37.51),\n    default_crs = 4326\n  ) +\n  theme_custom()\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; crop(zion) |&gt; mask(zion)) +\n  geom_sf(data = zion, fill = NA) +\n  labs(title = \"crop() |&gt; mask()\") +\n  scale_fill_whitebox_c() +\n  coord_sf(\n    xlim = c(-113.25, -112.85),\n    ylim = c(37.14, 37.51),\n    default_crs = 4326\n  ) +\n  theme_custom()\n\ng4 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(data = zion, fill = NA) +\n  labs(title = \"mask()\") +\n  scale_fill_whitebox_c() +\n  coord_sf(\n    xlim = c(-113.25, -112.85),\n    ylim = c(37.14, 37.51),\n    default_crs = 4326\n  ) +\n  theme_custom()\n\ng5 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion, inverse = TRUE)) +\n  geom_sf(data = zion, fill = NA) +\n  labs(title = \"mask(inverse = TRUE)\") +\n  scale_fill_whitebox_c() +\n  coord_sf(\n    xlim = c(-113.25, -112.85),\n    ylim = c(37.14, 37.51),\n    default_crs = 4326\n  ) +\n  theme_custom()\n\ng &lt;- g1 + g2 + g3 + g4 + g5 + \n  patchwork::plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  ) +\n  patchwork::plot_annotation(\n    title = \"Cropping and masking rasters with vectors\",\n    theme = theme(\n      plot.title = element_text(\n        family = \"body_font\",\n        size = 36, \n        lineheight = 0.3,\n        hjust = 0.5,\n        face = \"bold\"\n      )\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_2_1.png\"),\n  plot = g,\n  height = 800,\n  width = 2200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: The workflows and outputs when cropping and masking rasters with vectors."
  },
  {
    "objectID": "book_solutions/chapter6.html#raster-extraction",
    "href": "book_solutions/chapter6.html#raster-extraction",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "6.3 Raster Extraction",
    "text": "6.3 Raster Extraction\n\nRaster extraction retrieves raster values at specified locations using a geographic selector (typically vector objects like points, lines, or polygons). Uses the terra::extract() function (terra package).\nPoint Selector: Extracts raster cell values for specified points. Example: Extracting elevation values for 20 sample points in Zion National Park using st_sample() as shown in Figure 2\n\n\n\nCode\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\"\n  )\n)\n# Elevation Raster for Zion National Park and nearby areas\nsrtm &lt;- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\n\n# Zion National Park Boundaries, converted into CRS of `srtm`\nzion &lt;- read_sf(\n  system.file(\n    \"vector/zion.gpkg\", \n    package = \"spDataLarge\"\n    )\n  ) |&gt; \n  st_transform(st_crs(srtm))\n# ----------------------------------------------------------------\n# Basic data display\ng1 &lt;- ggplot() +\n  geom_spatraster(data = srtm) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Raw Data\",\n    subtitle = \"Elevation Raster and Zion National Park boundaries\"\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,1,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,1,0, \"mm\"),\n      hjust = 0.5,\n      size = 14\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\n# ----------------------------------------------------------------\n# Mask to display only Zion National Park, and\n# Display the elevations of randomly selected 20 points\n\n# Get 20 random points inside Zion National Park\nset.seed(21)\nrandom_points &lt;- st_sample(zion, size = 20) |&gt; \n  st_sf()\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = random_points,\n    size = 1,\n    alpha = 0.5,\n    pch = 19\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Sampling 20 Random Points\",\n    subtitle = \"Getting rndom poitns from sf::st_sample()\"\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,1,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,1,0, \"mm\"),\n      hjust = 0.5,\n      size = 14\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\n# --------------------------------------------------------------\n# Extract heights for these 20 points\nrandom_points &lt;- random_points |&gt; \n  mutate(\n    elevation = terra::extract(srtm, random_points) |&gt; pull(srtm)\n  )\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = random_points,\n    mapping = aes(colour = elevation),\n    stroke = 0.5,\n    size = 1,\n    alpha = 1,\n    pch = 1\n  ) +\n  geom_sf_text(\n    data = random_points,\n    mapping = aes(label = elevation),\n    size = 4,\n    alpha = 1,\n    family = \"body_font\",\n    hjust = 0,\n    vjust = 1,\n    nudge_y = -0.002\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  paletteer::scale_colour_paletteer_c(\"ggthemes::Red\") +\n  coord_sf(expand = FALSE) +\n  guides(colour = \"none\") +\n  labs(\n    title = \"Extracting elevation on points from rasters\",\n    subtitle = \"Using terra::extract() to get elevations on 20 points\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,1,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,1,0, \"mm\"),\n      hjust = 0.5,\n      size = 14\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_3_1.png\"),\n  plot = g,\n  height = 600,\n  width = 1500,\n  units = \"px\",\n  bg = \"white\"\n)\n\nrm(g, g1, g2, g3)\n\n\n\n\n\n\n\n\nFigure 2: Using {sf} and {terra} to get 20 random points in Zion National Park, and displaying their elevation (above sea level, in metres).\n\n\n\n\nLine Selector: Extracts raster values for each cell touched by a line. Recommendation: Split lines into points (using st_segmentize() and st_cast() from sf package) for accurate extraction along transects, such as creating elevation profiles for hiking routes, as shown in Figure 3\n\n\n\nCode\n# Get Latitude and Longitude of these random points\ndf1 &lt;- random_points |&gt;\n  st_as_sfc() |&gt; \n  st_as_sf() |&gt;\n  rename(geometry = x) |&gt; \n  cbind(st_coordinates(random_points))\n\n# Tibble of northern, sourthern, eastern and western-most points\ndf2 &lt;- bind_rows(\n  df1[which.min(df1$X), ] |&gt; mutate(dir = \"west\"),\n  df1[which.max(df1$X), ] |&gt; mutate(dir = \"east\"),\n  df1[which.min(df1$Y), ] |&gt; mutate(dir = \"south\"),\n  df1[which.max(df1$Y), ] |&gt; mutate(dir = \"north\"),\n)\n\n# Get two paths: east to west, north to south\npaths &lt;- bind_rows(\n  df2 |&gt; \n    filter(dir %in% c(\"west\", \"east\")) |&gt; \n    st_union() |&gt; \n    st_cast(\"LINESTRING\") |&gt; \n    st_as_sf() |&gt; \n    mutate(path = \"West to East\"),\n\n  df2 |&gt; \n    filter(dir %in% c(\"south\", \"north\")) |&gt; \n    st_union() |&gt; \n    st_cast(\"LINESTRING\") |&gt; \n    st_as_sf() |&gt; \n    mutate(path = \"South to North\")\n)\nrm(df1, df2)\n\n# Mid-point Check: Whether the CRS'es match\nst_crs(srtm) == st_crs(paths)\n\n# Plot of the paths\ng1 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = paths,\n    mapping = aes(colour = path),\n    linewidth = 0.5,\n    arrow = arrow(length = unit(2, \"mm\"))\n  ) +\n  geom_sf(\n    data = random_points,\n    size = 0.5\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  paletteer::scale_colour_paletteer_d(\n    \"nbapalettes::cavaliers_retro\"\n  ) +\n  coord_sf(expand = FALSE) +\n  guides(colour = \"none\") +\n  labs(\n    title = \"Selecting 2 Paths\",\n    subtitle = \"sing st_cast() and st_coordinates()\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# A {sf} object of various waypoints along the paths\n# to be able to extract elevation\npath_points &lt;- paths |&gt; \n  # Break into line segments of 100 metres each\n  st_segmentize(dfMaxLength = 100) |&gt; \n  \n  # Convert each line segment into a central point\n  # to be able to extract its elevation\n  st_cast(\"POINT\") |&gt; \n  \n  # Group by path to be able to calculate distance\n  # along the path\n  group_by(path) |&gt; \n  \n  # Extract only the first column (i.e. the distance from\n  # first point alone). Otherwise, st_distance() \n  # returns a distance matrix As expected, distance grows \n  # by approx. less than dfMaxLength amount per points\n  mutate(dist = st_distance(x)[, 1]) |&gt; \n  ungroup()\n\n# Extract the actual elevation using terra::extract\npath_points &lt;- path_points |&gt; \n  mutate(\n    elevation = terra::extract(srtm, path_points) |&gt; \n      pull(srtm),\n    dist = as.numeric(dist)\n  )\n\ng2 &lt;- path_points |&gt; \n  ggplot(\n    mapping = aes(\n      x = dist,\n      y = elevation,\n      colour = path\n    )\n  ) +\n  geom_point(\n    size = 0.1\n  ) +\n  geom_line(\n    linewidth = 0.2\n  ) +\n  facet_wrap(~path, nrow = 1) +\n  scale_x_continuous(\n    labels = scales::label_number(\n      scale = 0.001\n    )\n  ) +\n  scale_y_continuous(\n    labels = scales::label_number(\n      big.mark = \",\"\n    )\n  ) +\n  paletteer::scale_colour_paletteer_d(\n    \"nbapalettes::cavaliers_retro\"\n  ) +\n  labs(\n    x = \"Distance along the path (km)\",\n    y = \"Elevation (m)\",\n    title = \"Elevation Profile along two paths\",\n    subtitle = \"Using st_segmentize() & terra::extract()\"\n  ) +\n  guides(colour = \"none\") +\n  theme(\n    axis.text = element_text(\n      size = 12,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,0,0,0, \"mm\"),\n    axis.title.y = element_text(\n      margin = margin(0,0,0,5, \"mm\")\n    )\n  )\n\nmy_design = \"ABB\"\n\ng &lt;- wrap_plots(g1, g2) +\n  plot_layout(design = my_design, guides = \"collect\") \n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_3_2.png\"),\n  plot = g,\n  height = 600,\n  width = 1500,\n  units = \"px\",\n  bg = \"white\"\n)\n\nrm(g, g1, g2, paths, path_points)\n\n\n\n\n\n\n\n\nFigure 3: Creating elevation profiles along routes using st_segmentize() and terra::extract() from Northern most to Southernmost point; and from Westernmost to Easternmost point (amongst the 20 random points generated).\n\n\n\n\nPolygon Selector: Extracts multiple raster values per polygon. Example: Summarizing elevation statistics (min, mean, max) for Zion National Park polygons using group_by() and summarize() from dplyr as shown in Figure 4\n\n\n\nCode\n# Creating circles around the 20 random points\n# Each circle of 1.5 km radius\ncircles &lt;- random_points |&gt; \n  st_buffer(dist = 1500) |&gt; \n  mutate(ID = row_number())\n\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = circles, \n    fill = alpha(\"white\", 0.2)\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  coord_sf(expand = FALSE) +\n  guides(colour = \"none\") +\n  labs(\n    title = \"Circles of 3 km diameter\",\n    subtitle = \"Around 20 random points with st_buffer()\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\n# A custom function for rounded off mean\nmean_r &lt;- function(x){round(mean(x), 0)}\n\n# Getting minimum, mean and maximum height for each area\ncircles &lt;- circles |&gt; \n  \n  # Add minimum maximum and mean heights for each circle\n  left_join(\n    terra::extract(srtm, circles) |&gt; \n      as_tibble() |&gt; \n      # Grouping by each polygon / circle\n      group_by(ID) |&gt; \n      summarise(across(srtm, list(min = min, \n                                  mean = mean_r, \n                                  max = max)))\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = circles, \n    fill = alpha(\"white\", 0.5)\n  ) +\n  geom_sf_text(\n    data = circles,\n    mapping = aes(\n      label = paste0(\n        srtm_max, \"\\n\", srtm_min\n      )\n    ),\n    lineheight = 0.3,\n    family = \"body_font\",\n    size = 1.5,\n    check_overlap = TRUE\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  coord_sf(expand = FALSE) +\n  guides(colour = \"none\") +\n  labs(\n    title = \"Maximum and Minimum elevations for each circle\",\n    subtitle = \"Using st_buffer(), terra::extract() and dplyr::summarize()\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = circles, \n    fill = alpha(\"white\", 0.5)\n  ) +\n  geom_sf_text(\n    data = circles,\n    mapping = aes(\n      label = paste0(scales::number(srtm_mean, big.mark = \",\"), \" m\")\n    ),\n    lineheight = 0.3,\n    family = \"body_font\",\n    size = 3,\n    check_overlap = TRUE\n  ) +\n  scale_fill_wiki_c(\n    name = \"Elevation (m)\",\n    labels = scales::label_number(big.mark = \",\")\n  ) +\n  coord_sf(expand = FALSE) +\n  guides(colour = \"none\") +\n  labs(\n    title = \"Average elevation for each circle\",\n    subtitle = \"Using summarise()\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.key.width = unit(2, \"mm\"),\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    guides = \"collect\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_3_3.png\"),\n  plot = g,\n  height = 600,\n  width = 1500,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: Computing average elevation, minimum and maximum elevations within specified areas, like polygons, or in this case circles of diameter 3 km each around the 20 random points.\n\n\n\n\nCategorical Raster Extraction: Counts occurrences of raster categories (e.g., land cover) within polygons. Example: Analyzing land cover types in Zion National Park using terra::extract() as shown in Figure 5\n\n\n\nCode\nnlcd &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\n# Get Zion Park Boundary transformed into CRS of NLCD Raster\nzion &lt;- zion |&gt; st_transform(crs = st_crs(nlcd))\n\n# Get polygons (circles) transformed into CRS of NLCD Raster\ncircles1 &lt;- circles |&gt; \n  select(ID) |&gt; \n  st_transform(crs = st_crs(nlcd))\n\ncat_circles &lt;- terra::extract(nlcd, circles1) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  count(levels) |&gt; \n  mutate(perc = n / sum(n))\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = nlcd |&gt; mask(zion)) +\n  geom_sf(\n    data = zion, \n    linewidth = 0.4, \n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = circles, \n    fill = alpha(\"white\", 0.2)\n  ) +\n  geom_sf_text(\n    data = circles, \n    mapping = aes(label = ID),\n    size = 5,\n    family = \"body_font\"\n  ) +\n  paletteer::scale_fill_paletteer_d(\"MoMAColors::VanGogh\") +\n  coord_sf(expand = FALSE) +\n  guides(colour = \"none\", fill = \"none\") +\n  labs(\n    title = \"Circles of 3 km diameter\",\n    subtitle = \"Around 20 random points with st_buffer()\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    axis.text = element_text(\n      size = 8,\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\")\n  )\n\ng4 &lt;- cat_circles |&gt; \n  ggplot(aes(x = 0, y = n, fill = levels)) +\n  geom_col(\n    position = position_stack(),\n    colour = \"white\",\n    linewidth = 0.05\n  ) +\n  facet_wrap(~ ID) +\n  coord_polar(theta = \"y\") +\n  theme_void(\n    base_family = \"body_font\"\n  ) +\n  labs(\n    fill = NULL,\n    title = \"Land Cover Pie charts for 20 zones\",\n    subtitle = \"Each zone of diameter 3 km, identified by an ID\"\n  ) +\n  paletteer::scale_fill_paletteer_d(\"MoMAColors::VanGogh\") +\n  theme(\n    plot.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      hjust = 0.5,\n      size = 18\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      size = 14\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    plot.margin = margin(0,2,0,2, \"mm\"),\n    legend.text = element_text(\n      margin = margin(0,0,0,1, \"mm\"),\n      size = 14\n    ),\n    legend.margin = margin(0,0,0,0, \"mm\"),\n    legend.box.margin = margin(0,0,0,0, \"mm\"),\n    strip.text = element_text(\n      size = 18,\n      margin = margin(0,0,0,0, \"mm\")\n    )\n  )\n\ng &lt;- g1 + g4 +\n  plot_layout(\n    design = \"ABB\"\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_3_4.png\"),\n  plot = g,\n  height = 600,\n  width = 1500,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 5: Computing pie charts of different land use types in circles of diameter 3 km around the 20 random points, and using st_transform() for rasters and vectors while performing raster extraction.\n\n\n\nCombining the work done in this section to produce a composite graphic shown in Figure 6 for publishing a code demonstration\n\n\nCode\nlibrary(magick)\n\ni1 &lt;- image_read(here::here(\"book_solutions\", \"images\",\n                            \"chapter6_3_1.png\"))\ni2 &lt;- image_read(here::here(\"book_solutions\", \"images\",\n                            \"chapter6_3_2.png\"))\ni3 &lt;- image_read(here::here(\"book_solutions\", \"images\",\n                            \"chapter6_3_3.png\"))\ni4 &lt;- image_read(here::here(\"book_solutions\", \"images\",\n                            \"chapter6_3_4.png\"))\n\n\nc_imgs &lt;- c(i1, i2, i3, i4)\n\nimage_append(\n  image_scale(c_imgs, \"1500x\"),\n  stack = TRUE\n) |&gt; \n  image_write(\n    path = here::here(\"book_solutions\", \"images\",\n                            \"chapter6_3_5.png\")\n  )\n\n\n\n\n\n\n\n\nFigure 6: A composite image of all the work done: extracting raster values from vector points with {terra} and {sf} for points (locations), linestrings (along journey paths) and within polygons (areas) and compiling results with {magick}\n\n\n\n\nFurther details: —\n\nexactextractr::exact_extract() (exactextractr package):\n\nFaster than terra::extract() for large datasets.\nComputes precise polygon overlap fractions for weighted statistics.\n\nterra::extract(exact = TRUE) adds a fraction column for detailed overlap calculations. Useful for weighted means or precise coverage estimates but computationally intensive."
  },
  {
    "objectID": "geocomputation/crop_mask_rasters.html",
    "href": "geocomputation/crop_mask_rasters.html",
    "title": "Cropping and Masking rasters with vectors using {sf} and {terra}",
    "section": "",
    "text": "Getting required libraries\n\n\nCode\nlibrary(sf)            # Simple Features and Vectors in R\nlibrary(terra)         # Handling rasters\nlibrary(tidyterra)     # Tidyverse workflows with rasters\nlibrary(tidyverse)     # Wrangling and plotting\nlibrary(spData)        # London Boroughs data\n\n\nGet data on London Boroughs as vector data, results shown in Figure 1\n\n\nCode\nlondon &lt;- spData::lnd |&gt; \n  janitor::clean_names() |&gt; \n  select(name, hectares, geometry)\n\ng &lt;- london |&gt; \n  ggplot(\n    mapping = aes(\n      fill = name,\n      label = name\n    )\n  ) +\n  geom_sf(\n    alpha = 0.8,\n    linewidth = 0.1\n  ) +\n  geom_sf_text(\n    size = 1,\n    check_overlap = TRUE\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Vector data, plotted with {sf}\",\n    subtitle = \"Boroughs of London\"\n  ) +\n  theme_minimal(\n    base_size = 6\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"crop_mask_rasters_1.png\"),\n  height = 800,\n  width = 1000,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Vector data on London Boroughs’ boundaries, plotted using {sf}\n\n\n\nGetting bbox and other parameters for getting rasters\n\n\nCode\n# A bounding box in the format c(lowerleftlon, lowerleftlat, upperrightlon, upperrightlat)\nlondon_bbox &lt;- st_bbox(london)\nnames(london_bbox) &lt;- c(\"left\", \"bottom\", \"right\", \"top\")\nlondon_bbox\n\n\nGet raster map data for entire London Area\n\n\nCode\n# Getting the map tiles\nlondon_base1 &lt;- get_stadiamap(\n  bbox = london_bbox,\n  zoom = 10,\n  maptype = \"stamen_toner_lines\"\n)\n\n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nlondon_base2 &lt;- ggmap_bbox(london_base1)\n\n\nCropping and Masking\nCompiling layout"
  },
  {
    "objectID": "book_solutions/chapter6.html#rasterization",
    "href": "book_solutions/chapter6.html#rasterization",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "6.4 Rasterization",
    "text": "6.4 Rasterization\n\nRasterization converts vector objects into raster format, often for analysis (e.g., terrain) or modeling. It simplifies data by standardizing spatial resolution, serving as geographic data aggregation.\nKey Function: rasterize() in the {terra} package handles rasterization.\n\n\n\n\n\n\n\nNote\n\n\n\nterra::rasterize(): Converts vector data into raster format by transferring values from vector geometries to raster cells.\nKey Arguments:\n\nx: Input vector data: A SpatVector or a two-column matrix (coordinates for points). Defines the geometries to be rasterized.\ny: Template raster: A SpatRaster that determines the extent, resolution, and CRS of the output raster.\nfield: Specifies the values to transfer to raster:\n\nAs a character: Variable name from x (e.g., a column in the vector dataset).\nAs a numeric: Direct values or indices recycled to match nrow(x).\n\nvalues (for matrix input x): Numeric values used for rasterization, recycled if fewer than nrow(x). Can also be a matrix or data frame.\nfun: Summarizing function for overlapping geometries in a cell:\n\nFor lines and polygons: “min”, “max”, “mean”, “count”, “sum”.\nFor points: Any function returning a single value (e.g., mean, length, min). The fun = \"length\" means a count of the number of points in that cell.\n\nbackground: Default cell value for areas not covered by any features in x. Default: NA.\ntouches: Logical: If TRUE, includes all cells touched by a feature (lines/polygons), not just those where centroids fall.\nupdate: Logical: If TRUE, updates existing values in the template raster.\ncover: Logical: For polygons, returns the fraction of a cell covered by a feature. Uses sub-cell presence/absence checks.\nby: Groups vector data into layers:\n\nFor SpatVector: Column name or index.\nFor matrices: Vector defining group membership.\n\n\n\n\nDefault Behaviour of rasterize():\n\nIf no fun is specified, the last value is used in case of overlaps (fun = \"last\").\nWhen field is empty, raster cells reflect presence/absence of geometries.\n\n\nCommon Use Cases:\n\nPresence/absence rasters: Determine where features exist.\nSummary statistics: Aggregate multiple values in a single cell (e.g., sum, mean).\nFractional coverage: Estimate the proportion of a raster cell covered by polygons.\n\n\n\n\nResolution Considerations:\n\nLow resolution (large cells): Misses geographic variability.\nHigh resolution (small cells): Increases computation time.\nResolution choice depends on intended use or alignment with other rasters.\n\nFlexibility: Rasterization varies by:\n\nTemplate raster properties (extent, resolution, CRS).\nInput vector type (points, polygons).\nFunction arguments (e.g., fun, field).\n\nPoints Rasterization: can be done in three further methods depicted in Figure 7: —\n\nPresence/Absence Raster:\n\nRaster indicates whether cells contain cycle hire points.\n\nCount Raster:\n\nUses fun = \"length\" to count cycle hire points per grid cell.\n\nSummary Statistic Raster:\n\nCalculates sum of a variable (e.g., capacity) using field and fun = sum.\n\n\n\n\n\nCode\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 12\n  )\n)\n\ntheme_custom &lt;- function(...){\n  theme(\n    legend.key.height = unit(1, \"mm\"),\n    legend.key.width = unit(6, \"mm\"),\n    plot.title = element_text(\n      size = 24,\n      margin = margin(0,0,2,0, \"mm\")\n    ),\n    plot.subtitle = element_text(\n      size = 18,\n      margin = margin(0,0,1,0, \"mm\")\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    axis.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    panel.grid = element_line(linewidth = 0.2),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    legend.text = element_text(margin = margin(1,0,0,0, \"mm\")),\n    legend.title = element_text(margin = margin(2,0,1,0, \"mm\")),\n    legend.margin = margin(0,0,0,0, \"mm\"),\n    legend.box.margin = margin(0,0,0,0, \"mm\")\n  )\n}\n\n# Get cycle hiring points data for London\ncycles &lt;- spData::cycle_hire_osm |&gt; \n  # Transform into CRS of EPSG:27700 - British National Grid\n  st_transform(\"EPSG:27700\")\n\n# Create a template raster for using in rasterization\ntemplate_raster &lt;- rast(\n  # Spat Extent of the Vector data\n  terra::ext(cycles),\n  # Required resolution of the raster\n  resolution = 500,\n  # CRS for the raster\n  crs = crs(cycles)\n)\n\ng1 &lt;- ggplot() +\n  geom_sf(\n    data = cycles,\n    mapping = aes(\n      fill = capacity\n    ),\n    pch = 21,\n    size = 0.5,\n    linewidth = 0.001\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Red\",\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Cycle Hire Points (London)\",\n    subtitle = \"OSM Vector data, plotted with {sf}\"\n  ) +\n  theme_custom()\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = cycles |&gt; terra::rasterize(template_raster)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Red\",\n    na.value = \"transparent\",\n    name = \"Hiring points present?\"\n  ) +\n  labs(\n    title = \"Presence / Absence Raster\",\n    subtitle = \"Default rasterize(); i.e. (fun = \\\"last\\\")\"\n  ) +\n  theme_custom()\n\ng3 &lt;- ggplot() +\n  geom_spatraster(\n    data = cycles |&gt; terra::rasterize(template_raster,\n                                      fun = \"length\")\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Red\",\n    na.value = \"transparent\",\n    breaks = seq(0, 10, 2),\n    name = \"Number of hiring points\"\n  ) +\n  labs(\n    title = \"Count raster (vector points per cell)\",\n    subtitle = \"rasterize(fun = \\\"length\\\")\"\n  ) +\n  theme_custom()\n\ng4 &lt;- ggplot() +\n  geom_spatraster(\n    data = cycles |&gt; terra::rasterize(\n      template_raster,\n      field = \"capacity\",\n      fun = \"sum\")\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Red\",\n    na.value = \"transparent\",\n    name = \"Cycles Capacity\"\n  ) +\n  labs(\n    title = \"Summary Statistic raster\",\n    subtitle = \"rasterize(field = \\\"capacity\\\", fun = \\\"length\\\")\"\n  ) +\n  theme_custom()\n\ng &lt;- g1 + g2 + g3 + g4 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    title = \"Vectorizing rasters into points - 3 types\",\n    theme = theme(\n      plot.title = element_text(\n      size = 48,\n      margin = margin(2,0,2,0, \"mm\"),\n      hjust = 0.5\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 24,\n      margin = margin(0,0,-5,0, \"mm\"),\n      face = \"bold\"\n    )\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_4_1.png\"),\n  plot = g,\n  height = 700,\n  width = 2200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 7: Rasterizing points geometry of {sf} with terra::rasterize() with three methods. (a) Base vector object, (b) Presence-Absence Raster, (c) Count Raster - number of objects per cell, and, (d) Summary Statistic Raster - a summary statistic calculated for each cell, using a field (of sf object) and function.\n\n\n\n\nLine and Polygon Rasterization is shown in Figure 8. The polygon rasterization can proceed in two ways, depending on the argument touches = TRUE / FALSE as shown in Figure 8 .\n\ntouches = TRUE: Includes all cells touched by lines/polygons.\nDefault (touches = FALSE): Selects cells where centroids fall inside polygons.\n\n\n\n\nCode\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 12\n  )\n)\n\ntheme_custom &lt;- function(...){\n  theme(\n    legend.key.height = unit(1, \"mm\"),\n    legend.key.width = unit(6, \"mm\"),\n    plot.title = element_text(\n      size = 24,\n      margin = margin(0,0,2,0, \"mm\"),\n      lineheight = 0.3\n    ),\n    plot.subtitle = element_text(\n      size = 18,\n      margin = margin(0,0,1,0, \"mm\"),\n      lineheight = 0.3\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    axis.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    panel.grid = element_line(linewidth = 0.2),\n    legend.position = \"none\"\n  )\n}\n\n#----------------------------------------------------------------\n# Get vector data on State of California from `us_states` data\ncalifornia &lt;- us_states |&gt; \n  filter(NAME == \"California\")\n\ncalifornia_border &lt;- california |&gt; \n  st_cast(\"MULTILINESTRING\")\n\ntemplate_raster &lt;- rast(\n  ext(california),\n  crs = st_crs(california)$wkt, # Use crs(california) or st_crs(california)$wkt\n  resolution = 0.25  # Give resolution in degrees\n)\n\ncrs(california)\nst_crs(california)$wkt\n\ng1 &lt;- ggplot() +\n  geom_sf(data = california) +\n  labs(title = \"California Map (vector)\\nplotted with {sf}\") +\n  theme_custom()\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = california_border |&gt; rasterize(template_raster)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Classic Red\",\n    na.value = \"transparent\"\n  ) +\n  labs(title = \"Multi-Linestring\\nwith terra::rasterize()\",\n       subtitle = \"Cells touched by Linestring are coloured\") +\n  theme_custom()\n\ng3 &lt;- ggplot() +\n  geom_spatraster(\n    data = california |&gt; rasterize(template_raster,\n                                   touches = FALSE)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Classic Red\",\n    na.value = \"transparent\"\n  ) +\n  labs(title = \"Multipolygon\\nterra::rasterize(touches = FALSE)\",\n       subtitle = \"Only colours raster cells whose\\ncentroids are inside multi-polygon\") +\n  theme_custom()\n\ng4 &lt;- ggplot() +\n  geom_spatraster(\n    data = california |&gt; rasterize(template_raster,\n                                   touches = FALSE)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Classic Red\",\n    na.value = \"transparent\"\n  ) +\n  labs(title = \"Multipolygon\\nterra::rasterize(touches = TRUE)\",\n       subtitle = \"Colours all raster cells which\\nare touched by the multi-polygon\") +\n  theme_custom()\n\nrast1 &lt;- california |&gt; rasterize(\n  template_raster,\n  touches = FALSE\n  )\n\nrast2 &lt;- california_border |&gt; \n  rasterize(\n    (rast1 * 0.5),\n    update = TRUE\n  )\n\ng5 &lt;- ggplot() +\n  geom_spatraster(\n    data = rast2\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Classic Red\",\n    na.value = \"transparent\"\n  ) +\n  labs(title = \"Polygon & Linestring\\nterra::rasterize(update = TRUE)\",\n       subtitle = \"Rasterized polygon updated with a rasterized linestring\") +\n  theme_custom()\n\n\ng &lt;- g1 + g2 + g3 + g4 + g5 +\n  plot_layout(nrow = 1, guides = \"collect\") +\n  plot_annotation(\n    tag_levels = \"a\",\n    title = \"Techniques for Rasterizing lines and polygons with {terra}\",\n    theme = theme(\n      plot.title = element_text(\n      size = 48,\n      margin = margin(2,0,2,0, \"mm\"),\n      hjust = 0.5\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 24,\n      margin = margin(0,0,-5,4, \"mm\"),\n      face = \"bold\"\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_4_2.png\"),\n  plot = g,\n  height = 700,\n  width = 2200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 8: Rasterizing Multi-Linestrings and Multi-Polygons from {sf} using terra::rasterize(). The figure show: (a) The base vector map of California, (b) Rasterization of California’s borders (LINESTRING) generated from map using sf::st_cast(), (c) A multi-polygon (map of California) rasterized using terra::rasterize(touches = FALSE) colours only the cells whose centroids fall within the multi-polygon, (d) Using terra::rasterize(touches = TRUE) colours all cells which are touched by the multi-polygon, and, (e) Using terra::rasterize(update = TRUE) to compile and update a previous raster of multi-polygon (values halved to maintain colour levels) with a border multi-linestring."
  },
  {
    "objectID": "book_solutions/chapter6.html#spatial-vectorization",
    "href": "book_solutions/chapter6.html#spatial-vectorization",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "6.5 Spatial Vectorization",
    "text": "6.5 Spatial Vectorization\n\nConverts raster data (spatially continuous) into vector data (spatially discrete: points, lines, polygons). Opposite process of rasterization. It can be of three types – (1) points, (2) lines, and (3) polygons.\n(1) Points from Raster Centroids:\n\nUse terra::as.points() (Hijmans 2024) for converting raster cells (non-NA) to points. It produces a SpatVector class of object, which can then be converted into an {sf} (Pebesma and Bivand 2023) object using sf::st_as_sf() .\nExample: Elevation raster visualized as points in Figure 9.\n\n\n\n\nCode\ntheme_custom &lt;- function(...){\n  theme(\n    legend.key.height = unit(1, \"mm\"),\n    legend.key.width = unit(5, \"mm\"),\n    plot.title = element_text(\n      size = 24,\n      margin = margin(0,0,2,0, \"mm\")\n    ),\n    plot.subtitle = element_text(\n      size = 18,\n      margin = margin(0,0,1,0, \"mm\")\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    axis.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    panel.grid = element_line(linewidth = 0.2),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    legend.text = element_text(margin = margin(1,0,0,0, \"mm\")),\n    legend.title = element_text(margin = margin(2,0,1,0, \"mm\")),\n    legend.margin = margin(0,0,0,0, \"mm\"),\n    legend.box.margin = margin(0,0,0,0, \"mm\"),\n    ...\n  )\n}\n\nelev &lt;- rast(system.file(\"raster/elev.tif\", package = \"spData\"))\n\ng10 &lt;- ggplot() +\n  geom_spatraster(data = elev) +\n  scale_fill_princess_c() +\n  labs(\n    title = \"Base raster\",\n    subtitle = \"Class SpatRaster (elev)\",\n    fill = NULL\n  ) +\n  theme_custom()\n\ng11 &lt;- ggplot() +\n  geom_sf(\n    data = elev |&gt; as.points(values = F) |&gt; st_as_sf(),\n    size = 3\n  ) +\n  scale_colour_princess_c() +\n  labs(\n    title = \"Vectorization without raster values\",\n    subtitle = \"Using terra::as.points(values = FALSE)\",\n    colour = NULL\n  ) +\n  theme_custom()\n\ng12 &lt;- ggplot() +\n  geom_sf(\n    data = elev |&gt; as.points() |&gt; st_as_sf(),\n    mapping = aes(colour = elev),\n    size = 3\n  ) +\n  scale_colour_princess_c() +\n  labs(\n    title = \"Vectorization, retaining values as attributes\",\n    subtitle = \"Using terra::as.points() [default behaviour]\",\n    colour = NULL\n  ) +\n  theme_custom()\n\n\ng &lt;- g10 + g11 + g12 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    title = \"Vectorizing rasters into points, with or without values\",\n    theme = theme(\n      plot.title = element_text(\n      size = 48,\n      margin = margin(1,0,1,0, \"mm\"),\n      hjust = 0.5\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 24,\n      margin = margin(0,0,-5,4, \"mm\"),\n      face = \"bold\"\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_1.png\"),\n  plot = g,\n  height = 700,\n  width = 2200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 9: Vectorization of raster into points using terra::as_points() with or without retention of raster values.\n\n\n\n\n(2) Contour Lines (Isolines):\n\nRepresent lines of constant values (e.g., elevation, temperature).\nUse terra::as.contour() which creates a SpatVector, which then is converted into an {sf} object using sf::st_as_sf() which shows contour lines as LINESTRING or MULTILINESTRING geometry featuers, with an additional column on level (every 100 metres)\nOr, rasterVis::contourplot() for creating and overlaying contours. For example, visualize DEMs with hillshading and contours in Figure 10\n\n\n\n\nCode\n# Digital elevation showing the southern flank of Mt. Mongón.\ndem &lt;- rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\n\ng13 &lt;- ggplot() +\n  geom_spatraster(data = dem) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Base raster\",\n    subtitle = \"Class SpatRaster (dem)\",\n    fill = NULL\n  ) +\n  theme_custom()\n\n\ndem_contour &lt;- terra::as.contour(dem, nlevels = 10) |&gt; \n  st_as_sf()\n\ng14 &lt;- ggplot() +\n  geom_sf(\n    data = dem_contour,\n    mapping = aes(colour = level),\n    linewidth = 1\n  ) +\n  geom_sf_label(\n    data = dem_contour,\n    mapping = aes(\n      colour = level,\n      label = level\n    ),\n    fill = alpha(\"white\", 0.7),\n    fontface = \"bold\",\n    family = \"body_font\",\n    size = 7,\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  scale_colour_wiki_c(\n    breaks = unique(dem_contour$level)\n  ) +\n  labs(\n    title = \"Contour Lines with {sf}\",\n    subtitle = \"Using terra::as.contour(nlevels = 10)\",\n    colour = NULL, x = NULL, y = NULL\n  ) +\n  theme_custom() +\n  theme(\n    legend.key.width = unit(7, \"mm\")\n  )\n\ndem_contour &lt;- terra::as.contour(dem, nlevels = 30) |&gt; \n  st_as_sf()\n\ng15 &lt;- ggplot() +\n  geom_sf(\n    data = dem_contour,\n    mapping = aes(colour = level),\n    linewidth = 0.5\n  ) +\n  scale_colour_wiki_c(\n    breaks = unique(dem_contour$level)\n  ) +\n  labs(\n    title = \"Contour Lines with {sf}\",\n    subtitle = \"Using terra::as.contour(nlevels = 30)\",\n    fill = NULL, colour = NULL\n  ) +\n  theme_custom() +\n  theme(\n    legend.key.width = unit(7, \"mm\")\n  )\n\ng &lt;- g13 + g14 + g15 +\n  plot_layout(\n    nrow = 1\n  ) +\n  plot_annotation(\n    tag_levels = \"a\",\n    title = \"Vectorizing rasters into lines - Contour Lines\",\n    theme = theme(\n      plot.title = element_text(\n      size = 48,\n      margin = margin(2,0,2,0, \"mm\"),\n      hjust = 0.9\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 24,\n      margin = margin(0,0,-5,4, \"mm\"),\n      face = \"bold\"\n    ),\n    plot.margin = margin(2,0,2,0, \"mm\")\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_2_1.png\"),\n  plot = g,\n  height = 800,\n  width = 1600,\n  units = \"px\",\n  bg = \"white\"\n)\n\n# File name to save the PNG\noutput_file &lt;- here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_2_2.png\")\n\npng(filename = output_file, \n    width = 600, \n    height = 800,\n    units = \"px\")\n\n# Generate the contour plot\nrasterVis::contourplot(dem, main = \"rasterVis::contourplot()\")\n\n# Close the graphics device\ndev.off()\nlibrary(magick)\n# Read the two images\nimg1 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_2_1.png\"))\nimg2 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_2_2.png\"))\n\nc(img1, img2) |&gt; \n  image_append() |&gt; \n  image_write(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_2.png\"))\n\nunlink(here::here(\"book_solutions\", \n                  \"images\", \n                  \"chapter6_5_2_1.png\"))\n\nunlink(here::here(\"book_solutions\", \n                  \"images\", \n                  \"chapter6_5_2_2.png\"))\n\n\n\n\n\n\n\n\nFigure 10\n\n\n\n\n(3) Polygons from Rasters:\n\nUse terra::as.polygons() to convert raster cells to polygons with five coordinates per cell.\nAggregation: Dissolve boundaries with the same attribute values (aggregate argument). Example: Grain raster converted to polygons in Figure 11.\n\nFurther enhacement: Polygon Smoothing: Use smoothr::smooth() (Strimas-Mackey 2023) (with method = \"chaikin\", \"ksmooth\" or \"spline\") to remove sharp edges. But remember, Smoothing alters spatial coverage; analyse cautiously.\n\n\n\nCode\ngrain &lt;- rast(system.file(\"raster/grain.tif\", package = \"spData\"))\n\ng16 &lt;- ggplot() +\n  geom_spatraster(dat = grain) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Base raster; Qualitative\",\n    subtitle = \"With three discrete values\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE) +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng17 &lt;- ggplot() +\n  geom_sf(\n    data = grain |&gt; as.polygons(aggregate = T) |&gt; st_as_sf(),\n    mapping = aes(fill = grain),\n    colour = \"white\",\n    linewidth = 1\n  ) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Vectorized as aggregated polygons\",\n    subtitle = \"Using terra::as.polygons(aggregate = TRUE)\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE) +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng18 &lt;- ggplot() +\n  geom_sf(\n    data = grain |&gt; as.polygons(aggregate = F) |&gt; st_as_sf(),\n    mapping = aes(fill = grain),\n    colour = \"white\",\n    linewidth = 0.5\n  ) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Vectorized as polygons\",\n    subtitle = \"Using terra::as.polygons(aggregate = FALSE)\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE) +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng19 &lt;- ggplot() +\n  geom_sf(\n    data = grain |&gt; \n            as.polygons(aggregate = T) |&gt; \n            st_as_sf() |&gt; \n            smoothr::smooth(),\n    mapping = aes(fill = grain),\n    colour = \"white\",\n    linewidth = 0.5\n  ) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Vectorized as smoothed polygons\",\n    subtitle = \"terra::as.polygons() & smoothr::smooth()\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE) +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng20 &lt;- ggplot() +\n  geom_sf(\n    data = grain |&gt; \n            as.polygons(aggregate = T) |&gt; \n            st_as_sf() |&gt; \n            smoothr::smooth(method = \"spline\"),\n    mapping = aes(fill = grain),\n    colour = \"white\",\n    linewidth = 0.5\n  ) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Vectorized as smoothed polygons\",\n    subtitle = \"smoothr::smooth(method = \\\"spline\\\")\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE, clip = \"off\") +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng &lt;- g16 + g17 + g18 + g19 + g20 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    title = \"Vectorizing rasters into polygons (aggregation)\",\n    tag_levels = \"a\",\n    theme = theme(\n      plot.title = element_text(\n      size = 48,\n      margin = margin(2,0,2,0, \"mm\"),\n      hjust = 0.5\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 24,\n      margin = margin(0,-1,-5,4, \"mm\"),\n      face = \"bold\"\n    ),\n    plot.margin = margin(2,0,2,0, \"mm\")\n  )\n\n\nggsave(\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_3.png\"),\n  plot = g,\n  height = 700,\n  width = 2200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 11\n\n\n\n\n\nCode\nlibrary(magick)\n\n# Read the two images\nimg1 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_4_1.png\"))\nimg2 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_4_2.png\"))\nimg3 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_1.png\"))\nimg4 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_2.png\"))\nimg5 &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter6_5_3.png\"))\n\nc(img1, img2, img3, img4, img5) |&gt; \n  image_append(stack = TRUE) |&gt; \n  image_write(\n    here::here(\"book_solutions\",\n               \"images\",\n               \"chapter6_5.png\")\n  )\n\n\n\nCompilation Plot with {magick}\nA compilation plot of the techniques in the last two sections is shown in Figure 12\n\n\n\n\n\n\nFigure 12: A compiled image for all the techniques of raster-vector interaction: Rasterization and Vectorization."
  },
  {
    "objectID": "book_solutions/chapter6.html#exercise-solutions",
    "href": "book_solutions/chapter6.html#exercise-solutions",
    "title": "Chapter 6: Raster-vector interactions",
    "section": "Exercise Solutions",
    "text": "Exercise Solutions\n\n\nCode\nlibrary(sf)             # Simple Features in R\nlibrary(terra)          # Rasters in R (with tidy workflow)\nlibrary(tidyterra)      # Tidy workflow and ggplot2 with rasters\nlibrary(spData)         # Getting data\nlibrary(tidyverse)      # Data Wrangling and {ggplot2}\nlibrary(patchwork)      # Compiling Plots\n\nzion_points_path &lt;- system.file(\n  \"vector/zion_points.gpkg\", \n  package = \"spDataLarge\"\n  )\n\nzion_points &lt;- read_sf(zion_points_path)\n\nsrtm &lt;- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\n\nch &lt;- st_combine(zion_points) |&gt;\n  st_convex_hull() |&gt; \n  st_as_sf()\n\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\n\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 12\n  )\n)\n\ntheme_custom &lt;- function(...){\n  theme(\n    legend.key.height = unit(1, \"mm\"),\n    legend.key.width = unit(6, \"mm\"),\n    plot.title = element_text(\n      size = 24,\n      margin = margin(0,0,2,0, \"mm\"),\n      lineheight = 0.3\n    ),\n    plot.subtitle = element_text(\n      size = 18,\n      margin = margin(0,0,1,0, \"mm\"),\n      lineheight = 0.3\n    ),\n    axis.ticks.length = unit(0, \"mm\"),\n    axis.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    panel.grid = element_line(linewidth = 0.2),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    legend.text = element_text(margin = margin(1,0,0,0, \"mm\")),\n    legend.title = element_text(margin = margin(2,0,1,0, \"mm\")),\n    legend.margin = margin(0,0,0,0, \"mm\"),\n    legend.box.margin = margin(0,0,0,0, \"mm\")\n  )\n}\n\n\n\nE1.\nCrop the srtm raster using (1) the zion_points dataset and (2) the ch dataset. Are there any differences in the output maps? Next, mask srtm using these two datasets. Can you see any difference now? How can you explain that?\nThe Figure 13 (b) shows the srtm raster cropped using zion_points dataset. The Figure 13 (c) shows the raster srtm cropped using ch dataset. There seem to be no differences between the two output cropped maps.\n\n\nCode\ng1 &lt;- ggplot() +\n  geom_spatraster(data = srtm) +\n  geom_sf(data = ch, alpha = 0.5, fill = \"white\") +\n  geom_sf(data = zion_points, colour = \"blue\") +\n  scale_fill_wiki_c() +\n  coord_sf(\n    expand = FALSE,\n    xlim = c(-113.25, -112.83),\n    ylim = c(37.11, 37.53)\n  ) +\n  labs(\n    title = \"Base datasets\",\n    subtitle = \"srtm: Elevation Raster; ch: convex hull;\\nzion_points: blue points\"\n  ) +\n  theme_custom()\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; crop(zion_points)) +\n  # geom_sf(data = ch, alpha = 0.5, fill = \"white\") +\n  geom_sf(data = zion_points, colour = \"blue\", alpha = 0.5) +\n  scale_fill_wiki_c() +\n  coord_sf(\n    expand = FALSE,\n    xlim = c(-113.25, -112.83),\n    ylim = c(37.11, 37.53)\n  ) +\n  labs(\n    title = \"Cropping by points\",\n    subtitle = \"srtm |&gt; crop(zion_points)\"\n  ) +\n  theme_custom()\n\ng3 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; crop(zion_points)) +\n  geom_sf(data = ch, alpha = 0.5, fill = \"white\", colour = \"white\") +\n  # geom_sf(data = zion_points, colour = \"blue\", alpha = 0.5) +\n  scale_fill_wiki_c() +\n  coord_sf(\n    expand = FALSE,\n    xlim = c(-113.25, -112.83),\n    ylim = c(37.11, 37.53)\n  ) +\n  labs(\n    title = \"Cropping by Convex hull\",\n    subtitle = \"srtm |&gt; crop(ch)\"\n  ) +\n  theme_custom()\n\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(nrow = 1) +\n  plot_annotation(tag_levels = \"a\")\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"chapter6-e1-1.png\"),\n  height = 1000,\n  width = 2000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 13\n\n\n\nHowever, the Figure 14 (a) shows masking of the raster with points - showing that masking by points results in selected points on the raster, thus resulting in no visible result. The Figure 14 (b) shows masking of a raster by a polygon, a more expected result.\n\n\nCode\ng1 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(zion_points)) +\n  # geom_sf(data = ch, alpha = 0.5, fill = \"white\") +\n  geom_sf(data = zion_points, colour = \"blue\", \n          alpha = 0.5, size = 0.5) +\n  scale_fill_wiki_c() +\n  coord_sf(\n    expand = FALSE,\n    xlim = c(-113.25, -112.83),\n    ylim = c(37.11, 37.53)\n  ) +\n  labs(\n    title = \"Masking a raster by points\",\n    subtitle = \"srtm |&gt; mask(zion_points)\"\n  ) +\n  theme_custom()\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = srtm |&gt; mask(ch)) +\n  # geom_sf(data = ch, alpha = 0.5, fill = \"white\") +\n  geom_sf(data = zion_points, \n          colour = \"blue\", alpha = 0.5,\n          size = 0.5) +\n  scale_fill_wiki_c() +\n  coord_sf(\n    expand = FALSE,\n    xlim = c(-113.25, -112.83),\n    ylim = c(37.11, 37.53)\n  ) +\n  labs(\n    title = \"Masking a raster by a polygon\",\n    subtitle = \"srtm |&gt; mask(ch)\"\n  ) +\n  theme_custom()\n\n\ng &lt;- g1 + g2 +\n  plot_layout(nrow = 1) +\n  plot_annotation(tag_levels = \"a\")\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"chapter6-e1-2.png\"),\n  height = 800,\n  width = 1600,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 14\n\n\n\nThe distinction between masking and cropping can be better understood by examining how they interact with polygons and points:\n\nMasking: When masking with a polygon, the output includes all the raster cells that fall within the interior or lie on the boundaries of the polygon. In contrast, masking with points produces an output that includes only the specific raster cells that align directly with those points, without considering the area around them.\nCropping: Cropping, whether by points or polygons, yields the same result. This is because cropping considers the bounding box, which is the smallest rectangle that can enclose the given geometry. For a set of points and their convex hull (a polygon that encloses the points), the bounding box remains identical. Consequently, the raster output produced by cropping is consistent regardless of whether the input geometry is a polygon or a set of points.\n\n\n\nE2.\nFirstly, extract values from srtm at the points represented in zion_points. Next, extract average values of srtm using a 90 buffer around each point from zion_points and compare these two sets of values. When would extracting values by buffers be more suitable than by points alone?\nBonus: Implement extraction using the exactextractr package and compare the results.\nThe Table 1 compares the two values from rasters - extracted from the points and extracted from the buffer zone (90 metres) around the points. It would be better to use the buffer around the points, since it removes the chance error or randomness.\nFurther, the use of exactextractr package helps us calculate even better weighted mean of the buffer zone, by calculating how much of a raster cell’s proportion fall within the buffer zone.\n\n\nCode\ndf1 &lt;- srtm |&gt; \n  terra::extract(zion_points) |&gt; \n  as_tibble() |&gt; \n  rename(height_on_points = srtm)\n\ndf2 &lt;- srtm |&gt; \n  terra::extract(st_buffer(zion_points, dist = 90)) |&gt; \n  group_by(ID) |&gt; \n  summarise(\n    mean_height_in_buffer_zone = mean(srtm, na.rm = T)\n  )\n\ndf3 &lt;- srtm |&gt; \n  exactextractr::exact_extract(st_buffer(zion_points, dist = 90)) |&gt; \n  purrr::imap_dfr(~ .x %&gt;% mutate(ID = .y)) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(\n    mean_with_exact_fractions = weighted.mean(value, w = coverage_fraction)\n  ) |&gt; \n  mutate(ID = parse_number(as.character(ID)))\n\n\n\n\nCode\ndf_all &lt;- structure(list(ID = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, \n13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, \n29, 30), height_on_points = c(1802L, 2433L, 1886L, 1370L, 1452L, \n1635L, 1380L, 2032L, 1830L, 1860L, 1440L, 2145L, 1942L, 1691L, \n1776L, 2198L, 1820L, 1349L, 1758L, 1424L, 2159L, 1809L, 1826L, \n1550L, 1799L, 2102L, 2118L, 1372L, 1905L, 1574L), mean_height_in_buffer_zone = c(1803.5, \n2418.75, 1875, 1385.66666666667, 1411.33333333333, 1629, 1378.25, \n2040.25, 1812.5, 1863, 1485, 2163.25, 1930, 1689.25, 1770.6, \n2197.75, 1820.25, 1342.25, 1755.5, 1432.25, 2163, 1799.25, 1815.5, \n1557.25, 1818.75, 2084, 2112.75, 1381, 1906.5, 1568.75), mean_with_exact_fractions = c(1802.00133958487, \n2424.45674770282, 1876.08426481862, 1392.71469762041, 1418.32776902309, \n1634.65560885957, 1382.29661439712, 2036.58308765316, 1820.0303014567, \n1862.25146840549, 1474.00216389597, 2156.26597640816, 1928.10327037732, \n1690.96565049072, 1772.48742394502, 2199.49153660086, 1814.37498800353, \n1346.31074580787, 1750.9561283278, 1432.07177081194, 2162.75811241747, \n1799.24374331498, 1818.16628377294, 1555.46331837623, 1815.26746442256, \n2084.60258183394, 2114.31006688883, 1382.04095054598, 1907.24485439106, \n1568.26154119403), difference = c(1.5, -14.25, -11, 15.6666666666667, \n-40.6666666666667, -6, -1.75, 8.25, -17.5, 3, 45, 18.25, -12, \n-1.75, -5.40000000000009, -0.25, 0.25, -6.75, -2.5, 8.25, 4, \n-9.75, -10.5, 7.25, 19.75, -18, -5.25, 9, 1.5, -5.25)), row.names = c(NA, \n-30L), class = c(\"tbl_df\", \"tbl\", \"data.frame\"))\n\ndf_all |&gt; \n  gt::gt() |&gt; \n  gt::fmt_number(\n    columns = -ID,\n    decimals = 0\n  ) |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 1: A table on the height of points, mean height inside the buffer zone and difference between the two\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE3.\nSubset points higher than 3100 meters in New Zealand (the nz_height object) and create a template raster with a resolution of 3 km for the extent of the new point dataset. Using these two new objects:\n\nCount numbers of the highest points in each grid cell.\nFind the maximum elevation in each grid cell.\n\nThe object above_3100 contains the 19 peaks which are above 3100 metres. Further, the template_raster is a template raster with a resolution of 3 km and the extent of the new point dataset. The results for count and maximum height in each cell os new raster are shown in Figure 15.\n\n\nCode\ndata(\"nz_height\")\n\nabove_3100 &lt;- nz_height |&gt; \n  filter(elevation &gt; 3100)\n\n# Create a template raster for using in rasterization\ntemplate_raster &lt;- rast(\n  # Spat Extent of the Vector data\n  terra::ext(above_3100),\n  # Required resolution of the raster\n  resolution = 3000,\n  # CRS for the raster\n  crs = crs(above_3100)\n)\n\nelevation_raster &lt;- above_3100 |&gt; rasterize(template_raster)\nelevation_raster_1 &lt;- above_3100 |&gt; rasterize(template_raster, \n                                            fun = \"length\")\nelevation_raster_2 &lt;- above_3100 |&gt; \n  rasterize(\n    template_raster,\n    field = \"elevation\",\n    fun = \"max\")\n\ndf1 &lt;- elevation_raster_1 |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  mutate(cell_id = row_number()) |&gt; \n  drop_na() |&gt; \n  rename(\n    numer_of_peaks = V1_length,\n    cell_ID = cell_id\n  )\n\ndf2 &lt;- elevation_raster_2 |&gt; \n  values() |&gt; \n  as_tibble() |&gt; \n  mutate(cell_id = row_number()) |&gt; \n  drop_na() |&gt; \n  rename(\n    maximum_height_of_peaks = max,\n    cell_ID = cell_id\n  )\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = elevation_raster_1) +\n  scale_fill_viridis_c(\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Number of peaks per cell\",\n    subtitle = \"Raster created using rasterize(fun = `length`)\"\n  ) +\n  theme_custom() +\n  theme(\n    legend.position = \"bottom\"\n  ) \n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = elevation_raster_2) +\n  scale_fill_princess_c(\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Maximum height per cell\",\n    subtitle = \"Using rasterize(field = `elevation`, fun = `max`)\"\n  ) +\n  theme_custom() +\n  theme(\n    legend.position = \"bottom\"\n  )\n\ng &lt;- g1 + g2 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\"\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 36,\n      face = \"bold\"\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"chapter6-e3.png\"),\n  height = 800,\n  width = 1600,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 15: Figure showing the two rasters (a) Raster with each cell of resolution of 3 km, and colour (fill) depicting the count of peaks, i.e., the number of peaks above 3100 metres within that cell. (b) Raster with each cell of same resolution, where each cell’s colour (fill) depicts the maximum elevation (height) within that each cell.\n\n\n\nThe count of the number of highest points in each grid cell, and the maximum height in each grid cell is shown in Table 2\n\n\nCode\n# dput(full_join(df1, df2))\n\ndf12 &lt;- structure(list(numer_of_peaks = c(7, 2, 1, 6, 1, 1), cell_ID = c(24L, \n25L, 28L, 31L, 38L, 50L), maximum_height_of_peaks = c(3497, 3194, \n3199, 3724, 3593, 3151)), class = c(\"tbl_df\", \"tbl\", \"data.frame\"\n), row.names = c(NA, -6L))\n\ndf12 |&gt; \n  relocate(cell_ID) |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case)\n\n\n\n\nTable 2: Number of highest points in each grid cell.\n\n\n\n\n\n\n\n\n\nCell Id\nNumer of Peaks\nMaximum Height of Peaks\n\n\n\n\n24\n7\n3497\n\n\n25\n2\n3194\n\n\n28\n1\n3199\n\n\n31\n6\n3724\n\n\n38\n1\n3593\n\n\n50\n1\n3151\n\n\n\n\n\n\n\n\n\n\n\n\nE4.\nAggregate the raster counting high points in New Zealand (created in the previous exercise), reduce its geographic resolution by half (so cells are 6 x 6 km) and plot the result.\n\nResample the lower resolution raster back to the original resolution of 3 km. How have the results changed?\nName two advantages and disadvantages of reducing raster resolution.\n\nThe code below aggregates the raster showing the count of high points into a resolution of 6 km, using terra::resample() with a template_raster_2 of resolution 6 km. The results are shown in Figure 16.\nAdvantages of Reducing Raster Resolution\n\nImproved Computation Efficiency: Fewer cells reduce the data size, speeding up processing and analysis.\nSimplification: Provides a coarser overview for large-scale analysis, which may be sufficient for specific applications like regional studies.\n\nDisadvantages of Reducing Raster Resolution\n\nLoss of Detail: Fine spatial variations and features are lost, potentially affecting precision in applications requiring high detail.\nAccuracy Trade-Off: Aggregated data may misrepresent localized phenomena, leading to potential inaccuracies in spatial analyses.\n\n\n\nCode\n# Create a template raster for using in rasterization\ntemplate_raster_2 &lt;- rast(\n  # Spat Extent of the Vector data\n  terra::ext(above_3100),\n  # Required resolution of the raster\n  resolution = 6000,\n  # CRS for the raster\n  crs = crs(above_3100)\n)\n\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = elevation_raster_1) +\n  scale_fill_viridis_c(\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Number of peaks per cell\",\n    subtitle = \"Raster created using rasterize(fun = `length`)\"\n  ) +\n  theme_custom() +\n  theme(\n    legend.position = \"bottom\"\n  ) \n\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = elevation_raster_1 |&gt; \n      # terra::aggregate(fact = 2, fun = mean)\n      resample(template_raster_2, method = \"bilinear\")\n  ) +\n  scale_fill_viridis_c(\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Aggregated raster (res = 6 km)\",\n    subtitle = \"Using resample(method = `bilinear`)\"\n  ) +\n  theme_custom() +\n  theme(\n    legend.position = \"bottom\"\n  )\n\ng3 &lt;- ggplot() +\n  geom_spatraster(\n    data = elevation_raster_1 |&gt; \n      resample(template_raster_2, method = \"bilinear\") |&gt; \n      resample(template_raster, method = \"bilinear\")\n  ) +\n  scale_fill_viridis_c(\n    direction = -1,\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"Disaggregated raster (res = 3 km)\",\n    subtitle = \"Reverting back to high res. leads to loss of data\"\n  ) +\n  theme_custom() +\n  theme(\n    legend.position = \"bottom\"\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\"\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 36,\n      face = \"bold\"\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"chapter6-e4.png\"),\n  height = 800,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 16: Figures showing the (a) Original raster of resolution 3 km, showing number of peaks above 3100 meters in each cell, (b) The raster aggregated to resolution of 6 km, (c) The same aggregted raster disaggregated back to resolution of 3 km, with considerable loss of information and data.\n\n\n\n\n\nE5.\nPolygonize the grain dataset and filter all squares representing clay.\n\nName two advantages and disadvantages of vector data over raster data.\nWhen would it be useful to convert rasters to vectors in your work?\n\nThe code chunks below show the polygonization, and filtered data of all squares representing clay (using as.polygon(aggregate = FALSE)). The Figure 17 shows the grain dataset and the polygonized grain_sf where each row represents a &lt;POLYGON&gt; (aggregated).\n\n\nCode\ngrain &lt;- rast(system.file(\"raster/grain.tif\", package = \"spData\"))\n\ngrain |&gt;\n  terra::as.polygons(aggregate = FALSE) |&gt;\n  st_as_sf() |&gt;\n  st_cast(\"POLYGON\") |&gt;\n  filter(grain == \"clay\")\n\n\nSimple feature collection with 10 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -1.5 ymin: -1.5 xmax: 1 ymax: 1.5\nGeodetic CRS:  WGS 84\n   grain                       geometry\n1   clay POLYGON ((-1 1, -1 1.5, -0....\n2   clay POLYGON ((-1.5 0.5, -1.5 1,...\n3   clay POLYGON ((-0.5 0.5, -0.5 1,...\n4   clay POLYGON ((0 0.5, 0 1, 0.5 1...\n5   clay POLYGON ((-1.5 0, -1.5 0.5,...\n6   clay POLYGON ((0 0, 0 0.5, 0.5 0...\n7   clay POLYGON ((0.5 0, 0.5 0.5, 1...\n8   clay POLYGON ((-1.5 -0.5, -1.5 0...\n9   clay POLYGON ((-1 -0.5, -1 0, -0...\n10  clay POLYGON ((0.5 -1.5, 0.5 -1,...\n\n\n\n\nCode\ngrain &lt;- rast(system.file(\"raster/grain.tif\", package = \"spData\"))\n\ngrain_sf &lt;- grain |&gt; \n  terra::as.polygons() |&gt; \n  st_as_sf() |&gt; \n  st_cast(\"POLYGON\")\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = grain) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Base raster; Qualitative\",\n    subtitle = \"With three discrete values\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE) +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng2 &lt;- ggplot() +\n  geom_sf(\n    data = grain_sf,\n    mapping = aes(fill = grain),\n    colour = \"white\",\n    linewidth = 1\n  ) +\n  scale_fill_princess_d() +\n  labs(\n    title = \"Vectorized as aggregated polygons\",\n    subtitle = \"terra::as.polygons() |&gt; st_as_sf() |&gt; st_cast(`POLYGON`)\",\n    fill = NULL\n  ) +\n  coord_sf(expand = FALSE) +\n  theme_custom() +\n  theme(legend.position = \"none\")\n\ng &lt;- g1 + g2 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\"\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 36,\n      face = \"bold\"\n    )\n  )\n\nggsave(\n  filename = here::here(\"book_solutions\", \"images\",\n                        \"chapter6-e5.png\"),\n  height = 800,\n  width = 1700,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 17: Figure showing the (a) raster data for `grain`, and (b) the polygonized data with as.polygons(aggregate = FALSE)\n\n\n\nAdvantages of Vector Data Over Raster Data\n\nPrecision in Representation: Vector data precisely represents geographic features such as points, lines, and polygons. It is ideal for applications requiring exact boundaries (e.g., property lines, administrative borders).\nEfficient Storage for Sparse Data: Vectors store only the coordinates of features, making them more efficient for sparse or irregularly distributed data compared to rasters, which store values for all cells, even those with no data.\n\nDisadvantages of Vector Data Over Raster Data\n\nComplex Analysis: Performing spatial operations (e.g., overlay, buffering) is computationally more complex with vectors, especially with large datasets.\nInefficient for Continuous Data: Vector data struggles to efficiently represent continuous phenomena (e.g., elevation, temperature) that vary over space, for which raster data is better suited.\n\nWhen to Convert Rasters to Vectors in Your Work\n\nFeature Extraction: If you need to delineate specific features (e.g., contours from a Digital Elevation Model (DEM) or boundaries of high-value areas), converting a raster to vector allows for precise representation and further analysis.\nIntegration with Vector Data: For projects requiring alignment or combination with existing vector datasets (e.g., administrative boundaries or transportation networks), converting rasters to vectors ensures compatibility.\nVisual Clarity in Maps: Vectors are preferred for creating clear and professional maps where discrete features need labeling or editing.\nCustom Analysis: If detailed geometric operations like buffering or intersection analysis are needed, converting rasters into vectors (e.g., polygons of land cover classes) enables such workflows."
  },
  {
    "objectID": "geocomputation/ggmaps_with_tidyterra.html",
    "href": "geocomputation/ggmaps_with_tidyterra.html",
    "title": "Combining {ggmaps}, {terra} and {tidyterra} to produce raster maps.",
    "section": "",
    "text": "Background\n……………………………….\n\n\nCode\n# Load spatial and environmental datasets.\nlibrary(ggmap)\n\n# Handle, analyze, and visualize raster and vector data.\nlibrary(terra)\n\n# Handling simple features in R\nlibrary(sf)\n\n# Tidy data workflows with 'terra' objects.\nlibrary(tidyterra)\n\n# Data manipulation, visualization, and wrangling.\nlibrary(tidyverse)\n\n# Compiling plots\nlibrary(patchwork)\n\n\nsysfonts::font_add_google(\"Fira Sans\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 14\n  ) +\n    theme(\n      plot.title = element_text(\n        size = 18\n      )\n    )\n)\n\n\n\n\nGetting a raster map from {ggmap}\n\n\nCode\n# Register your Stadia Maps key and enter it here\n# register_stadiamaps(\"you-key-here\")\n\n# Get basic data on Boroughs of London\nlondon_sf_map &lt;- spData::lnd |&gt; \n  janitor::clean_names() |&gt; \n  select(name, geometry)\n\ng1 &lt;- london_sf_map |&gt; \n  ggplot(aes(fill = name)) +\n  geom_sf(colour = \"white\") +\n  labs(\n    title = \"Basic Map of London Boroughs\",\n    subtitle = \"From {spData} object `lnd`\"\n  ) +\n  theme(\n    legend.position = \"none\"\n  )\n\nlondon_sf_boundary &lt;- london_sf_map |&gt; \n  st_union()\n\ng2 &lt;- london_sf_boundary |&gt; \n  ggplot() +\n  geom_sf() +\n  labs(\n    title = \"Outer boundary map of London\",\n    subtitle = \"Using sf::st_union()\"\n  )\n\ng &lt;- g1 + g2 +\n  plot_annotation(\n    tag_levels = \"a\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"ggmaps_with_tidyterra_1.png\"),\n  width = 1200,\n  height = 600,\n  units = \"px\"\n)\n\n\n\n\n\nDisplaying the basic data (a) Boroughs of London and (b) Outer boundary map of London\n\n\n\n\nGetting {ggmap} data on the boroughs of london\n\n\nCode\n# Bounding Box of London Boundary Map\nlondon_bbox &lt;- st_bbox(london_sf_boundary)\n\n# Convert bbox to a format the {ggmap} understands\nnames(london_bbox) &lt;- c(\"left\", \"bottom\", \"right\", \"top\")\n\nraw_raster_map &lt;- get_stadiamap(\n  bbox = london_bbox,\n  zoom = 10,\n  maptype = \"stamen_toner_lines\"\n)\n\nclass(raw_raster_map)\n\nbbox_raster &lt;- raw_raster_map |&gt; \n  terra::as.raster() |&gt; \n  rast()\n\ng1 &lt;- ggmap(raw_raster_map) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"{ggmap} raster: `Stamen Toner Lines` Maptype\",\n    subtitle = \"Using ggmap::ggmap()\"\n  )\n\ng1\n\nggplot() +\n  geom_spatraster_rgb(data = bbox_raster)\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"ggmaps_with_tidyterra_1.png\"),\n  width = 1200,\n  height = 600,\n  units = \"px\"\n)"
  },
  {
    "objectID": "book_solutions/chapter7.html",
    "href": "book_solutions/chapter7.html",
    "title": "Chapter 7: Reprojecting geographic data",
    "section": "",
    "text": "Code\nlibrary(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(magrittr)  # Using pipes with raster objects\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\nlibrary(patchwork) # Composing plots\n\ngreenland &lt;- rnaturalearth::ne_countries(\n  geounit = \"Greenland\",\n  scale = \"medium\",\n  returnclass = \"sf\"\n  ) |&gt; \n  select(admin, name, iso_a3, geometry)\n\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 14,\n    base_line_size = 0.2\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\"\n      ),\n      plot.title = element_text(\n        size = 24,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\")\n      ),\n      plot.subtitle = element_text(\n        size = 16,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\"),\n        lineheight = 0.3\n      )\n    )\n)\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor the first few sections, I will use the map of Greenland as an example, since it is an extreme case (far away from equator, so a good use for CRS projections examples), as shown in Figure 1.\n\n\n\n7.1 Introduction\n\nCoordinate Reference Systems (CRSs): Two main types:\n\nGeographic CRS: A reference system that defines locations on the Earth using a spherical or ellipsoidal model. It specifies positions in terms of latitude and longitude, with angular measurements relative to the Earth’s center. Uses longitude/latitude (units in degrees)\nProjected CRS: A reference system that transforms the Earth’s curved surface into a flat map. It uses linear units like meters and focuses on minimizing distortions in specific aspects such as distance, area, or shape, depending on the map’s purpose. Uses meters from a datum (projected system).\n\n\n\n\n\n\n\n\n\n\nAspect\nGeographic CRS\nProjected CRS\n\n\n\n\nDefinition\nRepresents locations on the Earth’s surface using a spherical or ellipsoidal model.\nRepresents locations on a flat, two-dimensional surface using a projected system.\n\n\nUnits of Measurement\nUses angular units (degrees of longitude and latitude).\nUses linear units (meters, feet, etc.).\n\n\nCoordinate Axes\nLongitude (x-axis) and Latitude (y-axis).\nX (east-west) and Y (north-south) in a flat plane.\n\n\nPurpose\nIdeal for global-scale mapping and geodetic calculations.\nIdeal for local or regional mapping, where accurate distances, angles, and areas are required.\n\n\nAccuracy\nRetains accurate angular relationships but distorts distances and areas.\nDistorts angular relationships but preserves distances, areas, or shapes (depending on projection).\n\n\nExamples\nWGS84 (used in GPS), NAD83.\nUTM (Universal Transverse Mercator), State Plane.\n\n\nKey Feature\nGeocentric, based on Earth’s shape as an ellipsoid.\nFlat, derived by projecting the Earth onto a 2D surface using a mathematical formula.\n\n\nApplications\nSatellite data, GPS, global navigation systems.\nEngineering projects, land use planning, local/regional maps.\n\n\n\n\nFocus of the Chapter:\n\nSetting and transforming CRSs in geographic data.\nHighlighting issues caused by ignoring CRSs, especially with lon/lat data.\n\nPractical Relevance:\n\nMany projects don’t require conversion between CRSs but knowing whether your data is in a projected or geographic CRS is critical.\nUnderstanding CRSs prevents errors and ensures smooth handling of geographic data.\n\n\n\n\nCode\ng1 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  labs(title = \"WGS84 / EPSG:4326\", subtitle = \"Default geographic projection\")\n\ng2 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  coord_sf(crs = \"EPSG:3857\") +\n  labs(title = \"EPSG:3857\", subtitle = \"Web Mercator projection\")\n\ng3 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  coord_sf(crs = \"ESRI:102004\") +\n  labs(title = \"ESRI:102004\", subtitle = \"Lambert Conformal Conic\")\n\ng4 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  coord_sf(crs = \"ESRI:54030\") +\n  labs(title = \"ESRI:54030\", subtitle = \"Robinson projection\")\n\ng5 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  coord_sf(crs = \"EPSG:3413\") +\n  labs(title = \"EPSG:3413\", subtitle = \"North Pole Stereographic\")\n\ng &lt;- g1 + g2 + g3 + g4 + g5 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\"\n    ) &\n  theme(\n    plot.tag = element_text(\n      size = 40,\n      face = \"bold\"\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-1_1.png\"),\n  height = 600,\n  width = 2400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Map of Greenland, with different projections from (a) to (e)\n\n\n\n\n\n7.2 Coordinate Reference Systems\n\nCRS: Used to transform coordinates between systems.\nPROJ: Core library for CRS transformations; integrated into R-spatial packages and QGIS.\nWays to Describe CRSs:\n\nSimple statements: E.g., “lon/lat coordinates” (ambiguous).\nProj4 strings: E.g., +proj=longlat +datum=WGS84 (outdated).\nAuthority:Code strings: E.g., EPSG:4326 (recommended).\n\nPreferred Method: Authority:Code, e.g., EPSG:4326:\n\nUnderstood by sf, terra, and other tools.\nEasy to remember and search online (e.g., epsg.io).\nMachine-readable and unambiguous.\n\nDetailed CRS Representation: WKT (Well-Known Text):\n\nComprehensive format for CRS description (based on ISO 19111:2019).\nUsed for precision and includes all CRS details (datum, ellipsoid, units, etc.).\nExample: st_crs(\"EPSG:4326\") outputs full WKT string.\n\nAuthority Identifiers:\n\nEPSG: Most common authority; standardized CRSs list.\nOther authorities: E.g., ESRI:54030 (Robinson projection).\nIdentifiers are linked to detailed WKT strings for unambiguous use.\n\nWKT vs Identifiers: WKT Precedence: In case of conflict, WKT values override identifiers.\n\n\n\n\n\n\n\nNote\n\n\n\nFrom the INBO blog tutorial “Goodbye PROJ.4! How to specify a coordinate reference system in R?”\n\nUnderstanding CRS:\n\nA CRS interprets numeric coordinates as actual point locations on Earth.\nTwo main types:\n\nGeodetic CRSs: Locate coordinates relative to a 3D model of Earth’s surface.\nProjected CRSs: Convert geodetic coordinates to a 2D map.\n\n\nComponents of a CRS:\n\nCoordinate system.\nDatum: Defines the position relative to Earth, including the ellipsoid.\nFor projected CRSs: Parameters for converting geodetic to projected coordinates.\n\nCRS Identification: CRSs are cataloged globally, notably in the EPSG dataset, with each assigned a unique EPSG code.\nBest Practices:\n\nAdopt WKT representations for CRS definitions to ensure compatibility and future-proofing.\nFamiliarize with the EPSG dataset for accurate CRS identification.\nUtilize R’s sf package for handling spatial data and CRS specifications.\n\n\n\n\n\n\nCode\nst_crs(\"EPSG:4326\")$WktPretty |&gt; str_view()\n\n\n[1] │ GEOGCS[\"WGS 84\",\n    │     DATUM[\"WGS_1984\",\n    │         SPHEROID[\"WGS 84\",6378137,298.257223563]],\n    │     PRIMEM[\"Greenwich\",0],\n    │     UNIT[\"degree\",0.0174532925199433,\n    │         AUTHORITY[\"EPSG\",\"9122\"]],\n    │     AXIS[\"Latitude\",NORTH],\n    │     AXIS[\"Longitude\",EAST],\n    │     AUTHORITY[\"EPSG\",\"4326\"]]\n\n\nCode\nst_crs(\"ESRI:102004\")$WktPretty |&gt; str_view()\n\n\n[1] │ PROJCS[\"USA_Contiguous_Lambert_Conformal_Conic\",\n    │     GEOGCS[\"NAD83\",\n    │         DATUM[\"North_American_Datum_1983\",\n    │             SPHEROID[\"GRS 1980\",6378137,298.257222101]],\n    │         PRIMEM[\"Greenwich\",0],\n    │         UNIT[\"degree\",0.0174532925199433,\n    │             AUTHORITY[\"EPSG\",\"9122\"]],\n    │         AUTHORITY[\"EPSG\",\"4269\"]],\n    │     PROJECTION[\"Lambert_Conformal_Conic_2SP\"],\n    │     PARAMETER[\"latitude_of_origin\",39],\n    │     PARAMETER[\"central_meridian\",-96],\n    │     PARAMETER[\"standard_parallel_1\",33],\n    │     PARAMETER[\"standard_parallel_2\",45],\n    │     PARAMETER[\"false_easting\",0],\n    │     PARAMETER[\"false_northing\",0],\n    │     UNIT[\"metre\",1],\n    │     AXIS[\"Easting\",EAST],\n    │     AXIS[\"Northing\",NORTH],\n    │     AUTHORITY[\"ESRI\",\"102004\"]]\n\n\n\n\n7.3 Querying and Setting Coordinate Systems\n\nCRS in R spatial objects: Coordinate Reference Systems (CRS) are queried and set in vector and raster geographic data using functions from the sf (Pebesma and Bivand 2023a) and terra (Hijmans 2024a) packages.\nVector data CRS handling:\n\nUse st_crs() to query CRS in vector objects (e.g., EPSG:4326 for WGS 84).\nCRS metadata includes User input (e.g., EPSG code, proj-string) and wkt (WKT string with complete CRS details).\n\nAdditional CRS details can be retrieved: The st_crs() function from the sf package in R provides detailed information about the Coordinate Reference System (CRS) of spatial objects.\n\n\n\n\n\n\n\n\n\nAttribute\nDescription\nExample Usage\n\n\n\n\nIsGeographic\nIndicates if the CRS is geographic (TRUE) or projected (FALSE).\nst_crs(new_vector)$IsGeographic\n\n\nunits_gdal\nSpecifies the units of measurement used in the CRS, as recognized by GDAL.\nst_crs(new_vector)$units_gdal\n\n\nsrid\nProvides the Spatial Reference System Identifier (SRID) associated with the CRS, if available.\nst_crs(new_vector)$srid\n\n\nproj4string\nReturns the PROJ.4 string representation of the CRS, offering a concise textual description.\nst_crs(new_vector)$proj4string\n\n\nWktPretty\nProvides a formatted Well-Known Text (WKT) representation of the CRS for easier readability.\nst_crs(new_vector)$WktPretty\n\n\nInvFlattening\nProvides the inverse flattening value of the ellipsoid, indicating its compression.\nst_crs(new_vector)$InvFlattening\n\n\nName\nRetrieves the official name of the CRS.\nst_crs(new_vector)$Name\n\n\nepsg\nReturns the EPSG code associated with the CRS, if available.\nst_crs(new_vector)$epsg\n\n\nyx\nIndicates whether the axis order is latitude-longitude (TRUE) or longitude-latitude (FALSE).\nst_crs(new_vector)$yx\n\n\nud_unit\nReturns the units object associated with the CRS, or NULL if units are missing.\nst_crs(new_vector)$ud_unit\n\n\naxes\nProvides information about the axes of the CRS, including their names and units.\nst_crs(new_vector)$axes\n\n\n\n\n\nCode\n# The WGS 84 / EPSG 4326 projection (default projection in {rnaturalearth})\nst_crs(\"EPSG:4326\")$units_gdal\n## [1] \"degree\"\nst_crs(\"EPSG:4326\")$IsGeographic\n## [1] TRUE\nst_crs(\"EPSG:4326\")$proj4string\n## [1] \"+proj=longlat +datum=WGS84 +no_defs\"\nst_crs(\"EPSG:4326\")$axes\n##                 name orientation\n## 1  Geodetic latitude           1\n## 2 Geodetic longitude           3\n\n# The EPSG:3857 Web Mercator Projection (used for maps and distances)\nst_crs(\"EPSG:3857\")$units_gdal\n## [1] \"metre\"\nst_crs(\"EPSG:3857\")$IsGeographic\n## [1] FALSE\nst_crs(\"EPSG:3857\")$proj4string\n## [1] \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"\nst_crs(\"EPSG:3857\")$axes\n##       name orientation\n## 1  Easting           3\n## 2 Northing           1\n\n# Robinson Projection ESRI:54030 \nst_crs(\"ESRI:54030\")$units_gdal\n## [1] \"metre\"\nst_crs(\"ESRI:54030\")$IsGeographic\n## [1] FALSE\nst_crs(\"ESRI:54030\")$proj4string\n## [1] \"+proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs\"\nst_crs(\"ESRI:54030\")$axes\n##       name orientation\n## 1  Easting           3\n## 2 Northing           1\n\n\n\nUse st_set_crs() to manually set or correct a CRS. Both st_set_crs() and the assignment method st_crs(object) &lt;- value are used to define or modify the Coordinate Reference System (CRS) of spatial objects.\n\nst_set_crs() is a function call, which can be advantageous when using pipes (|&gt;) in a workflow.\nBoth methods assign CRS metadata to the spatial object without altering the actual coordinate values or geometries.\nTo transform the coordinates to a different CRS, the st_transform() function should be used.\nAssigning a CRS is akin to labeling data with its existing coordinate system, whereas transforming reprojects the data into a new coordinate system.\n\n\n\n\nCode\ng1 &lt;- greenland |&gt; \n  st_set_crs(\"EPSG:4326\") |&gt; \n  ggplot() +\n  geom_sf() +\n  labs(\n    title = \"EPSG:4326\",\n    subtitle = \"The default CRS: a geographic CRS\"\n  )\n\ng2 &lt;- greenland |&gt; \n  st_transform(\"EPSG:3857\") |&gt; \n  ggplot() +\n  geom_sf() +\n  labs(\n    title = \"st_transform(`EPSG:3857`)\",\n    subtitle = \"Correct usage; EPSG:3857 CRS: a projected CRS\"\n  )\n\ng3 &lt;- greenland |&gt; \n  st_set_crs(\"EPSG:3857\") |&gt; \n  ggplot() +\n  geom_sf() +\n  labs(\n    title = \"st_set_crs(`EPSG:3857`)\",\n    subtitle = \"Wrong usage; distorts and assigns CRS values\"\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(nrow = 1) +\n  plot_annotation(\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\"\n    ) &\n  theme(\n    plot.tag = element_text(\n      size = 40,\n      face = \"bold\"\n    ),\n    plot.margin = margin(0,7,0,7, \"mm\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-3_1.png\"),\n  height = 600,\n  width = 2400,\n  unit = \"px\"\n)\n\n\n\n\n\nExplaining the difference between the st_set_crs() and st_transform(). The figures show (a) The default map of Greenland as obtained from {rnaturalearth} with the CRS WGS84 (i.e. EPSG:4326). (b) The transformation using st_transform() which produces correct transformation. (c) The incorrect method using st_set_crs() which simply retains all data, but assumes them to be in the new assigned CRS. This leads to wrong latitude and longitude numbers. Thus, the only use of st_set_crs() is for assigning a CRS to a raw data, which we know for sure from outside sources.\n\n\n\nValidate CRS with st_is_longlat().\n\nThe function st_is_longlat() in the sf package is used to check whether the Coordinate Reference System (CRS) of a spatial object is based on a geographic coordinate system (latitude and longitude). It’s Return Value can be: —\n\nTRUE: The object has a geographic CRS (e.g., EPSG:4326).\nFALSE: The object has a projected CRS.\nNA: The CRS is undefined (e.g., no metadata about the coordinate system is set).\n\n\nRaster data CRS handling:\n\nUse crs() from the {terra} package to query and set CRS for raster objects.\nOutputs CRS as a WKT string.\nSet CRS with EPSG codes, WKT strings, or CRSs from other objects (e.g., crs(my_raster) = \"EPSG:26912\").\n\nImportant considerations:\n\nst_crs() and crs() only set metadata; they do not modify coordinate values or geometries.\nMissing CRS in datasets (e.g., NA output in st_is_longlat()) indicates that CRS must be explicitly defined (e.g., using st_set_crs()).\n\nCRS assumptions: R avoids assumptions about CRS (e.g., unlike GeoJSON which defaults to EPSG:4326).\n\n\n\n7.4 Geometry Operations on Projected and Unprojected Data\n\nThe sf package integrates with:\n\nThe S2 spherical geometry engine for geographic CRS data with longitude/latitude (lon/lat) CRSs.\nGEOS is used for projected CRS or CRS-absent data.\nDefault Behavior: S2 is enabled by default for geographic data but can be disabled using sf::sf_use_s2(FALSE).\n\nCRS Importance in Buffers: Buffers created on unprojected data (e.g., lon/lat) can result in distorted outputs (for example A.1 in Figure 2) unless spherical geometry (S2) is used. Better still, always use a projected CRS for accurate distance / buffers calculation (as C.1 in Figure 2).\nKey Learnings:\n\nIncorrect buffer creation: Buffers on geographic data (Long / Lat data) without a specified CRS (thus, using GEOS) result in outputs in degrees (as A.1 & A.3 in Figure 2). Note: Lon/lat buffers without S2 or projection may appear elongated (e.g., along the north-south axis).\nCorrect buffer creation: S2 buffers (with Geographic CRS, i.e. Long / Lat data) calculate accurate distances (as B.1 in Figure 2) but may create jagged boundaries (as B.3 in Figure 2) (this can be tuned with max_cells or nQuadSegs).\nIdeal buffer creation: Use projected CRSs (as in C.1, C.2 & C.3 in Figure 2)) like British National Grid (EPSG:27700) for consistent distance-based operations, for example, in metres (m).\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote: S2 buffers improve results but remain less precise than using projected CRSs and GEOS.\n\n\n\nVisual Outcomes:\n\nBuffers based on S2 and projected CRSs produce more accurate, equidistant boundaries compared to lon/lat inputs without S2.\nS2-derived buffers differ from projected GEOS buffers, and resolution depends on max_cells (default: 1000). (as B.3 in Figure 2)\n\nBest Practices:\n\nUse sf::st_crs() to check the CRS and verify units (e.g., degrees vs. meters) of the CRS. Reproject data to a projected CRS using suitable EPSG codes for precise geometric operations.\nFor distance-based operations like buffering, reproject data to a projected CRS.\nAdjust max_cells in S2 for performance versus resolution trade-offs. (as B.1 in Figure 2)\n\n\n\nFigure 2 shows an example (buffer zone around London)\n\n\nCode\noverall_title &lt;- \"When and How to Use S2 and GEOS Engines for Spatial Operations\"\noverall_subtitle &lt;- \"GEOS handles projected or CRS-absent data; S2 defaults for geographic data but is optional.\"\n\n\nbts &lt;- 16     # Base Text Size\n\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = bts,\n    base_line_size = 0.2\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\"\n      ),\n      plot.title = element_text(\n        size = 1.9 * bts,\n        margin = margin(0.2, 0.1, 0.1, 0.1, \"lines\")\n      ),\n      plot.subtitle = element_text(\n        size = 1.3 * bts,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\")\n      ),\n      plot.margin = margin(0,0,0,0, \"mm\"),\n      axis.text = element_text(\n        size = bts * 0.5\n      ),\n      axis.ticks.length = unit(0, \"mm\"),\n      panel.background = element_rect(\n        fill = \"#caf0f8\",\n        colour = \"#caf0f8\"\n      ),\n      panel.grid = element_line(\n        linewidth = 0.2,\n        colour = \"white\",\n        linetype = 3\n      )\n    )\n)\n\n# Create a London data point - the coordiantes in Latitude\n# and Longitude of London, UK\nlondon_sans_crs &lt;- data.frame(lon = -0.1, lat = 51.5) |&gt; \n  st_as_sf(coords = c(\"lon\", \"lat\"))\n\n# Adding the CRS to London data point: values stay same\nlondon_with_crs &lt;- london_sans_crs |&gt; \n  st_set_crs(\"EPSG:4326\")\n\n# British National Grid\n# st_crs(\"EPSG:27700\")\n\n# Using the British National Grid CRS: values get changed\nlondon_british_crs &lt;- london_sans_crs |&gt; \n  st_set_crs(\"EPSG:4326\") |&gt; \n  st_transform(\"EPSG:27700\")\n\n\n# Create an approximate bounding box around 200 km around London\nbbox_near_london &lt;- london_sans_crs |&gt; \n  st_set_crs(\"EPSG:4326\") |&gt; \n  st_buffer(dist = 200000) |&gt; \n  st_bbox()\n\n# Crop and keep coastline map around London\noutline_map &lt;- rnaturalearth::ne_countries(\n  continent = \"Europe\",\n  returnclass = \"sf\",\n  scale = \"large\"\n  ) |&gt; \n  st_union() |&gt; \n  st_as_sf() |&gt; \n  st_crop(bbox_near_london)\n\n\nbase_plot &lt;- ggplot() +\n  geom_sf(\n    data = outline_map,\n    linewidth = 0.1,\n    fill = alpha(\"white\", 1)\n  ) +\n  geom_sf(\n    data = london_with_crs,\n    size = 3,\n    colour = \"#fb8500\"\n  ) +\n  coord_sf(expand = FALSE)\n\n# Without any CRS -------------------------------------------------\n\nrow_1_title &lt;- \"London Data, without any CRS\"\nrow_1_subtitle &lt;- \"Data in Long / Lat, but without a specified CRS, leads {sf} to use GEOS engine, as in (a) and (c)\"\n\ng1 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_sans_crs, \n                     dist = 1) |&gt; \n            st_set_crs(\"EPSG:4326\"),\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Incorrect: Using GEOS on Long/Lat data\",\n    subtitle = \"st_buffer(london_sans_crs, dist = 1)\"\n  )\n\ng2 &lt;- base_plot +\n  geom_sf(\n    data = london_sans_crs |&gt; \n            st_set_crs(\"EPSG:4326\") |&gt; \n            st_buffer(dist = 1),\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Incorrect: Using S2 but wrong Buffer units\",\n    subtitle = \"london_sans_crs |&gt; st_set_crs(`EPSG:4326`) |&gt; st_buffer(dist = 1)\"\n  )\n\ng3 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_sans_crs, \n                     dist = 1,\n                     nQuadSegs = 2) |&gt; \n            st_set_crs(\"EPSG:4326\"),\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Incorrect: Using GEOS with nQuadSegs\",\n    subtitle = \"st_buffer(london_sans_crs, dist = 1, nQuadSegs = 3)\"\n  )\n\n\nrow_2_title &lt;- \"London with a Geographic CRS `EPSG:4326`\"\nrow_2_subtitle &lt;- \"Data in Long/Lat, but with CRS speficied, leads {sf}to use S2 (spherical geometry). Distance is in metres, now.\"\n\nsf_use_s2(TRUE)\ng4 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_with_crs, \n                     dist = 1e5,\n                     max_cells = 300),\n    linewidth = 1,\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Correct: Buffer of 100 km using S2\",\n    subtitle = \"Using S2 engine (spherical geometry); Notice jagged buffer line.\"\n  )\n\nsf_use_s2(FALSE)\ng5 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_with_crs, \n                     dist = 1,\n                     max_cells = 500),\n    linewidth = 1,\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Incorrect: Buffer of 1 degree with GEOS\",\n    subtitle = \"sf_use_s2(FALSE):  Using GEOS engine on geographic CRS.\"\n  )\n\nsf_use_s2(TRUE)\ng6 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_with_crs, \n                     dist = 1e5,\n                     max_cells = 100),\n    linewidth = 1,\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Correct: Buffer of 100 km using S2\",\n    subtitle = \"Reducing max_cells = 100 to save computation time.\"\n  )\n\nrow_3_title &lt;- \"With a Projected CRS: British Grid (EPSG:27700)\"\nrow_3_subtitle &lt;- \"Using London data in Projected CRS results in ideal outputs. Accurate results with GEOS engine.\"\n\ng7 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_british_crs, \n                     dist = 1e5),\n    linewidth = 1,\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Ideal: 100 km Buffer on projected CRS\",\n    subtitle = \"london_british_crs |&gt; st_buffer(dist = 1e5)\"\n  )\n\ng8 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_british_crs, \n                     dist = 1e5,\n                     nQuadSegs = 1),\n    linewidth = 1,\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Distance in 4 directions only\",\n    subtitle = \"nQuadSegs = 1  (Number of segments per quadrant).\"\n  )\n\ng9 &lt;- base_plot +\n  geom_sf(\n    data = st_buffer(london_british_crs, \n                     dist = 1e5,\n                     nQuadSegs = 2),\n    linewidth = 1,\n    fill = alpha(\"#ffb703\", 0.5),\n    colour = \"#ffb703\"\n  ) +\n  labs(\n    title = \"Save Computation Time: 100 km Buffer\",\n    subtitle = \"nQuadSegs = 2  (Number of segments per quadrant).\"\n  )\n\n# A custom theme for each Row headings\ntheme_row &lt;- function(...){\n  theme(\n    plot.title = element_text(\n        margin = margin(5,0,1,0, \"mm\"),\n        size = bts * 3.5,\n        hjust = 0.5,\n        face = \"bold\"\n      ),\n      plot.subtitle = element_text(\n        margin = margin(0,0,1,0, \"mm\"),\n        size = bts * 2.5,\n        hjust = 0.5,\n        face = \"bold\"\n      ),\n    ...\n  )\n}\n\ntheme_tag &lt;- function(...){\n  theme(\n    plot.tag = element_text(\n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 1.5\n    ),\n    plot.tag.position = \"top\"\n  )\n}\n\n# Compiling Plots for London data without CRS\nga &lt;- g1 + g2 + g3 +\n  plot_annotation(\n    title = row_1_title,\n    subtitle = row_1_subtitle,\n    theme = theme_row(),\n    tag_levels = \"1\",\n    tag_prefix = \"A.\"\n  ) &\n  theme_tag()\n\n# Save the 3 plots for 1st Row\nggsave(\n  plot = ga,\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"temp_chapter7-4-1.png\"),\n  height = 1050,\n  width = 2400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n# Compiling Plots for London data with a Geographic CRS\ngb &lt;-  g4 + g5 + g6 +\n  plot_annotation(\n    title = row_2_title,\n    subtitle = row_2_subtitle,\n    theme = theme_row(),\n    tag_levels = \"1\",\n    tag_prefix = \"B.\"\n  ) &\n  theme_tag()\n\n\n# Save the 3 plots for 2nd Row\nggsave(\n  plot = gb,\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"temp_chapter7-4-2.png\"),\n  height = 1050,\n  width = 2400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n# Compiling Plots for Projected (British Grid) CRS\n\ngc &lt;-  g7 + g8 + g9 +\n  plot_layout(\n    tag_level = \"new\"\n  ) +\n  plot_annotation(\n    title = row_3_title,\n    subtitle = row_3_subtitle,\n    theme = theme_row(),\n    tag_levels = \"1\",\n    tag_prefix = \"C.\"\n  ) &\n  theme_tag()\n\n\n# Save the 3 plots for 3rd Row\nggsave(\n  plot = gc,\n  filename = here::here(\"book_solutions\", \n                        \"images\", \n                        \"temp_chapter7-4-3.png\"),\n  height = 1050,\n  width = 2400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n# Compile the images\nlibrary(magick)\nga &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"temp_chapter7-4-1.png\"))\ngb &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"temp_chapter7-4-2.png\"))\ngc &lt;- image_read(here::here(\"book_solutions\", \n                        \"images\", \n                        \"temp_chapter7-4-3.png\"))\n\nimage_append(c(ga, gb, gc), stack = TRUE) |&gt; \n  image_write(path = here::here(\"book_solutions\", \n                        \"images\", \n                        \"chapter7-4.png\"))\n\n# Clean up the temporary files\nunlink(here::here(\"book_solutions\",\"images\",\n                  \"temp_chapter7-4-1.png\"))\nunlink(here::here(\"book_solutions\",\"images\",\n                  \"temp_chapter7-4-2.png\"))\nunlink(here::here(\"book_solutions\",\"images\",\n                  \"temp_chapter7-4-3.png\"))\n\n\n\n\n\n\n\n\nFigure 2: The different kinds of buffering - incorrect, correct and ideal using {sf} in R relying on two engines - Google’s S2 spherical geometry, or GEOS engine.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis code below calculates the distances between lines of longitude (meridians) and latitude at different geographic points to demonstrate the distortion inherent in geographic coordinate systems (lon/lat CRSs).\n\n# Load the required package\nlibrary(geosphere)\n\n# 1. Distance between two meridians (longitude lines) at the equator (0° latitude)\n# From (0°E, 0°N) to (1°E, 0°N)\ndistance_meridian_equator &lt;- distGeo(c(0, 0), c(1, 0)) \ncat(\"Distance between meridians at the equator:\", round(distance_meridian_equator/1000, 2), \"km\\n\")\n## Distance between meridians at the equator: 111.32 km\n\n\n# 2. Distance between two meridians at the latitude of London (51.5°N)\n# From (0°E, 51.5°N) to (1°E, 51.5°N)\ndistance_meridian_london &lt;- distGeo(c(0, 51.5), c(1, 51.5)) \ncat(\"Distance between meridians at London's latitude:\", round(distance_meridian_london/1e3, 2), \"km\\n\")\n## Distance between meridians at London's latitude: 69.44 km\n\n\n# 3. Distance between two parallels (latitude lines) at any latitude\n# From (0°E, 0°N) to (0°E, 1°N)\ndistance_latitude &lt;- distGeo(c(0, 0), c(0, 1)) \ncat(\"Distance between latitudes:\", round(distance_latitude/1e3, 2), \"meters\\n\")\n## Distance between latitudes: 110.57 meters\n\nThus, the distance between meridians varies with latitude, shrinking from approximately 111 km at the equator to zero at the poles, while lines of latitude remain equidistant.\n\n\n\n\n\n7.5 When to Reproject?\n\nCRS Assignment: In practical daily work, CRSs are typically set automatically when data is read; hoever, if required, manual setting can be done using st_set_crs().\nThe main task, in daily work, involves transforming objects between CRSs to enable specific tasks. Transformation Necessity:\n\nTranformation into a Geographic CRS\n\nEssential when publishing online with packages like leaflet. (Cheng et al. 2024)\nFor projects with web mapping, we need to use EPSG:4326 (a geographic CRS).\nFor projects needing Spherical Geometry operations, use Geographic CRS.\n\nTranformation into another Projected CRS\n\nProjects needing planar geometry operations, like creating buffer zones with smooth edges.\nRequired when comparing or combining objects with different CRSs (e.g., using st_distance()).\n\n\nCRS Selection: Geographic CRS is best for global and spherical geometry operations. Projected CRS is ideal for local/regional planar geometry operations and analyses requiring precise distance and area calculations. Table 1 summarizes when to use geographic versus projected CRSs:\n\n\n\nCode\nlibrary(tibble)\nlibrary(gt)\n\n# Create the table as a tibble\ndata &lt;- tibble(\n  ID = 1:9,\n  Scenario = c(\n    \"Global Mapping\",\n    \"Great Circle Distances\",\n    \"Angular Bearings\",\n    \"Radius-based Proximity Queries (Spherical)\",\n    \"Local Area Analysis\",\n    \"Buffer Creation\",\n    \"Overlay and Intersection Operations\",\n    \"Planar Geometry Operations\",\n    \"Area and Length Calculation\"\n  ),\n  `Geographic CRS` = c(\n    \"Required for displaying data on web maps (e.g., with leaflet).\",\n    \"Use for accurate calculation of shortest paths on the Earth's surface.\",\n    \"Essential for computing directions or angles between points.\",\n    \"Use for radius-based queries or geofencing on a global scale.\",\n    \"Not typically recommended unless working with global-scale spherical models.\",\n    \"Not recommended for smooth edges.\",\n    \"Limited to angular-based operations (e.g., great circle intersections).\",\n    \"Not ideal for creating planar geometries like buffers or centroids.\",\n    \"Use for global-scale spherical areas (with corrections).\"\n  ),\n  `Projected CRS` = c(\n    \"Not recommended due to distortions at global scales.\",\n    \"Distances may be inaccurate due to planar projections.\",\n    \"Distortions in angles make it unsuitable for such tasks.\",\n    \"Results can be distorted for large distances.\",\n    \"Ideal for small-to-medium-scale analyses with minimal distortions.\",\n    \"Best for creating accurate and smooth planar buffers.\",\n    \"Preferred for planar intersections and overlays for precise alignment.\",\n    \"Essential for tasks like buffering and centroids in local projections.\",\n    \"Use for precise calculations in local or regional contexts.\"\n  )\n)\n\n# Create a beautiful table with gt\ndata |&gt; \n  gt() |&gt; \n  tab_header(\n    title = \"Geographic vs Projected CRS\",\n    subtitle = \"A comparison of scenarios for applying Geographic and Projected CRSs\"\n  ) |&gt; \n  gtExtras::gt_theme_pff() |&gt; \n  tab_style(\n    style = cell_text(weight = \"bold\"),\n    locations = cells_body(columns = Scenario)\n  ) |&gt; \n  tab_style(\n    style = cell_text(weight = \"bold\"),\n    locations = cells_body(\n      columns = `Geographic CRS`,        # Column 3\n      rows = 1:4                         # Rows 1-4\n    )\n  ) |&gt; \n  tab_style(\n    style = cell_text(weight = \"bold\"),\n    locations = cells_body(\n      columns = `Projected CRS`,        # Column 4\n      rows = 5:9                        # Rows 5-9\n    )\n  )\n\n\n\n\nTable 1: Guidelines for Choosing Between Geographic and Projected CRSs\n\n\n\n\n\n\n\n\n\nGeographic vs Projected CRS\n\n\nA comparison of scenarios for applying Geographic and Projected CRSs\n\n\nID\nScenario\nGeographic CRS\nProjected CRS\n\n\n\n\n1\nGlobal Mapping\nRequired for displaying data on web maps (e.g., with leaflet).\nNot recommended due to distortions at global scales.\n\n\n2\nGreat Circle Distances\nUse for accurate calculation of shortest paths on the Earth's surface.\nDistances may be inaccurate due to planar projections.\n\n\n3\nAngular Bearings\nEssential for computing directions or angles between points.\nDistortions in angles make it unsuitable for such tasks.\n\n\n4\nRadius-based Proximity Queries (Spherical)\nUse for radius-based queries or geofencing on a global scale.\nResults can be distorted for large distances.\n\n\n5\nLocal Area Analysis\nNot typically recommended unless working with global-scale spherical models.\nIdeal for small-to-medium-scale analyses with minimal distortions.\n\n\n6\nBuffer Creation\nNot recommended for smooth edges.\nBest for creating accurate and smooth planar buffers.\n\n\n7\nOverlay and Intersection Operations\nLimited to angular-based operations (e.g., great circle intersections).\nPreferred for planar intersections and overlays for precise alignment.\n\n\n8\nPlanar Geometry Operations\nNot ideal for creating planar geometries like buffers or centroids.\nEssential for tasks like buffering and centroids in local projections.\n\n\n9\nArea and Length Calculation\nUse for global-scale spherical areas (with corrections).\nUse for precise calculations in local or regional contexts.\n\n\n\n\n\n\n\n\n\n\n\n\n7.6 Which CRS to use?\n\nNo single ‘best’ CRS: All projections involve distortions; the choice depends on the task.\nSwitch CRSs for different tasks: Use a CRS that aligns with your analysis or visualization goals.\nGeographic CRS: most commonly, use WGS84 (EPSG:4326):\n\nCommon for web mapping, GPS datasets, and most vector - raster datasets.\nEPSG code: 4326 (useful for converting to a universal CRS).\n\nProjected CRS: Often dictated by local mapping agencies.\n\nTo ensure compatibility: Preferable to work in CRS (in which the data was provided)\nUTM (Universal Transverse Mercator): a set of Projected CRSs\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe Universal Transverse Mercator (UTM) set of projections\n\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\nProjection Name\nUniversal Transverse Mercator (UTM)\n\n\nStructure\nDivides the Earth into 60 longitudinal zones (6° wide each) and 20 latitudinal segments.\n\n\nCRS Type\nProjected CRS. Uses the Transverse Mercator projection for each zone.\n\n\nEPSG Codes\nNorthern Hemisphere: 32601 to 32660.\nSouthern Hemisphere: 32701 to 32760.\n\n\nZone Numbering\nZones numbered 1 to 60 (longitude).\nLatitude segments labeled A to V (excluding I and O).\n\n\nExample Zones\nZone 60H: Northern New Zealand, EPSG: 32760.\nZone 30N: Covers London, EPSG: 32630.\n\n\nKey Features\nConformal projection: Preserves angles and shapes locally.\nSuitable for small areas.\n\n\nDistortion\nIncreases with distance from the zone’s central meridian.\n\n\nUse Cases\nSmall-scale mapping, local surveys, engineering, and construction projects.\n\n\nLimitations\nNot suitable for regions spanning multiple zones.\n\n\n\nA mpa of the World with UTM projection Zones: —\n\nlonlat2UTM = function(lonlat) {\n  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1\n  if (lonlat[2] &gt; 0) {\n    utm + 32600\n  } else{\n    utm + 32700\n  }\n}\n\n\n\n\n\nCode\n# A code to plot UTM zones over the World Map in R\n\nworld_map &lt;- rnaturalearth::ne_countries(\n  scale = \"small\",\n  returnclass = \"sf\"\n) |&gt; \n  select(name, geometry)\n\n# Create a tibble for the UTM Zone breaks\nutm_long_breaks &lt;- tibble(\n  Longitude_Start = seq(-180, 174, by = 6),\n  Longitude_End = seq(-174, 180, by = 6),\n  Zone_Number = seq(1, 60)\n) |&gt; \n  janitor::clean_names() |&gt;\n  mutate(\n    mid_point_long = (longitude_start + longitude_end)/2\n  )\n\nutm_lat_breaks &lt;- tibble(\n  Latitude_Start = c(seq(-80, 72, by = 8)),\n  Latitude_End = c(seq(-72, 72, by = 8), 84),\n  Zone_Letter = LETTERS[!(LETTERS %in% c(\"A\", \"B\", \"I\", \"O\", \"Y\", \"Z\"))]\n) |&gt; \n  janitor::clean_names() |&gt;\n  mutate(\n    mid_point_lat = (latitude_start + latitude_end)/2\n  )\n\nbts = 24 # Base Text Size\n\ng &lt;- ggplot() +\n  geom_hline(\n    data = utm_lat_breaks,\n    mapping = aes(\n      yintercept = latitude_start\n    ),\n    linewidth = 0.2,\n    linetype = 1,\n    colour = \"grey40\",\n    alpha = 0.3\n  ) +\n  geom_vline(\n    data = utm_long_breaks,\n    mapping = aes(\n      xintercept = longitude_start\n    ),\n    linewidth = 0.2,\n    linetype = 1,\n    colour = \"grey40\",\n    alpha = 0.3\n  ) +\n\n  # Longitude Labels\n  geom_text(\n    data = utm_long_breaks,\n    mapping = aes(\n      label = zone_number,\n      y = 90,\n      x = mid_point_long\n    ),\n    family = \"body_font\",\n    size = bts / 2,\n    colour = \"grey20\"\n  ) +\n  \n  # Latitude Labels\n  geom_text(\n    data = utm_lat_breaks,\n    mapping = aes(\n      label = zone_letter,\n      x = 184,\n      y = mid_point_lat\n    ),\n    family = \"body_font\",\n    size = bts,\n    colour = \"grey20\"\n  ) +\n  geom_sf(\n    data = world_map,\n    alpha = 0.5,\n    colour = alpha(\"#A8554EFF\", 0.8),\n    fill = alpha(\"#A8554EFF\", 0.4)\n  ) +\n  scale_x_continuous(\n    breaks = unique(utm_long_breaks$longitude_start,\n                    utm_long_breaks$longitude_end)\n  ) +\n  labs(\n    x = \"Longitudanal Zones\",\n    y = \"Latitudanal Segments\",\n    title = \"UTM Projection Zones\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = bts\n  ) +\n  theme(\n    plot.title = element_text(\n      size = bts * 8, \n      margin = margin(0,0,0,0, \"mm\"),\n      hjust = 0.5,\n      colour = \"grey30\"\n    ),\n    panel.background = element_rect(\n      fill = \"#FEF7C7FF\",\n      colour = \"transparent\"\n    ),\n    panel.grid = element_blank(),\n    \n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-6.png\"),\n  height = 240,\n  width = 400,\n  unit = \"mm\",\n  bg = \"white\"\n)\n\n\n\nSelecting CRSs with tools:\n\nUse crsuggest::suggest_crs() (Walker 2022) for recommended CRSs based on spatial objects.\nExplore CRS Explorer by Javier Jimenez Shaw for location-specific CRSs.\n\nProjection Recommendations Table\n\n\n\n\n\n\n\n\n\nName of Projection Type\nWhen to Use\nWhen Not to Use\n\n\n\n\nLambert Azimuthal Equal-Area (LAEA)\n- For custom local projections.\n- When preserving area is crucial, e.g., for statistical mapping.\n- When preserving shape or distance is critical.\n- For areas extending thousands of kilometers.\n\n\nAzimuthal Equidistant (AEQD)\n- For accurate straight-line distances from a central point.\n- Mapping distances for circular or radial features.\n- For large-scale mapping beyond the immediate region of the center.\n- When shape or area preservation matters.\n\n\nLambert Conformal Conic (LCC)\n- For regions spanning thousands of kilometers (e.g., continents or large countries).\n- When preserving shape is important.\n- For small-scale maps.\n- When precise area calculations are required.\n\n\nStereographic (STERE)\n- For polar regions.\n- When preserving shape for relatively small polar areas.\n- For large-scale maps extending thousands of kilometers.\n- For accurate area or distance calculations.\n\n\n\n\nCustom CRSs:\n\nSuitable for local datasets, using center points for AEQD.\nCaution: Not compatible with other datasets; may lose accuracy for large areas.\n\nAdvanced options: Use geodesic calculations for fallback if no CRS fits.\n\n\n\n7.7 Reprojecting Vector Geometries\n\nReprojection: Transforming the coordinates of vector geometries (points, lines, polygons). Example: Converting CRS of an object for accurate distance measurement.\nKey Functionality in sf Package: Use st_transform() to transform CRS.\nQuerying and Setting CRS:\n\nRetrieve CRS of sf objects using st_crs().\nOutput contains components like User input and wkt.\nCRS objects are lists containing elements like Name, proj4string, epsg, and $wkt, as shown in table in Section 7.3 above.\n$wkt serves as the ultimate source of CRS details, queried via PROJ.\n\n\n\n\n\n\n\n\nNote\n\n\n\nOGR Coordinate Reference Systems and Coordinate Transformation tutorial provides insights into handling coordinate reference systems (CRS) and performing transformations using GDAL’s OGR library. Here’s how key concepts from the tutorial translate to {sf} in R:\n\nDefining a Geographic CRS:\n\nIn {sf}, you can assign a CRS to an sf object using the st_set_crs() function.\n\nQuerying CRS Information:\n\nIn {sf}, you can retrieve CRS information using the st_crs() function:\n\nTransforming Coordinates Between CRSs:\n\nIn {sf}, the st_transform() function is used to transform geometries to a different CRS. For example, to transform to EPSG:27700:\n\nHandling Axis Order:\n\nIn {sf}, you can control axis order interpretation using the st_axis_order() function. To set it to traditional GIS order (longitude, latitude):\nst_axis_order(FALSE)\n\n\n\n\n\n\n7.8 Reprojecting Raster Geometries\n\nRaster Reprojection: Creates a new raster with potentially different dimensions. Involves two steps:\n\nExtent Transformation: Adjusts raster extent (like vector reprojection).\nPixel Resampling: Re-estimates pixel values.\n\n\nRecommendation: Prefer vector reprojection over raster reprojection when both data types are used.\n\nKey Difference from vector re-projection: Raster reprojection creates a new raster with modified attributes (e.g., columns, rows) rather than altering individual pixel coordinates like vectors.\nTwo Processes of raster reprojection:\n\nTransformation: Adjusts grid geometry without changing pixel values, performed with the stars package. Also called Extent Transformation: Similar to vector reprojection, adjusts raster extent. Can be done using {stars} package. (Pebesma and Bivand 2023b)\nWarping: Reprojects raster using methods like project() from the terra package. Also called Pixel Resampling: Computes new pixel values using methods like nearest neighbor or bilinear re-sampling. Can be done with terra::project() from {terra} (Hijmans 2024b)\n\nCategorical Raster: Method used is nearest neighbor which ensures categorical values remain unchanged during reprojection. Result: Changes in resolution, extent, and added NA values (not new categories). Example is shown in Figure 3 .\n\n\n\nCode\ncat_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\ncat_raster1 &lt;- cat_raster |&gt; project(\"EPSG:4326\", method = \"near\")\n# crs(cat_raster) |&gt; \n#   str_view()\n\n# PROJCRS[\"NAD83 / UTM zone 12N\",\n\ng1 &lt;- ggplot() +\n  geom_spatraster(\n    data = cat_raster\n  ) +\n  labs(\n    title = \"Original Categorical Raster\",\n    subtitle = \"CRS: NAD83 / UTM zone 12N\",\n    fill = \"Land Cover Type\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = cat_raster1\n  ) +\n  labs(\n    title = \"Transformed Raster\",\n    subtitle = \"CRS: WGS 84  (EPSG:4326)\",\n    fill = \"Land Cover Type\"\n  )\n\n\ng &lt;- g1 + g2 +\n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    caption = \"Land Cover for a small area in Utah, USA; National Land Cover Database 2011\",\n    theme = theme(\n      plot.caption = element_text(\n        hjust = 0\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-8.png\"),\n  height = 800,\n  width = 1200,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 3: Warping or Re-sampling categorical rasters (akin to reprojection) using terra::project() which uses near method - estimates re-sampled raster values using the value from the nearest original cell.\n\n\n\n\nContinuous Raster: Method used is bilinear, computes pixel values as weighted averages of neighboring cells. Result: Modifications to mean values, resolution, and extent. Example is shown in Figure 4 .\n\n\n\nCode\nsrtm &lt;- rast(system.file(\"raster/srtm.tif\", \n                              package = \"spDataLarge\"))\n\nsrtm1 &lt;- srtm |&gt; project(\"EPSG:32612\", method = \"bilinear\")\n\ng1 &lt;- ggplot() +\n  geom_spatraster(\n    data = srtm\n  ) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Original Elevation Raster\",\n    subtitle = \"Geographic CRS: WGS 84 (EPSG:4326)\",\n    fill = \"Elevation (metres)\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = srtm1\n  ) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Transformed Continuous Values Raster\",\n    subtitle = \"Projected CRS: UTM zone 12N (EPSG:32612)\",\n    fill = \"Elevation (metres)\"\n  )\n\n\ng &lt;- g1 + g2 +\n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    caption = \"Elevation, above sea level in metres, from the Shuttle Radar Topography Mission (SRTM)\",\n    theme = theme(\n      plot.caption = element_text(\n        hjust = 0\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-8_1.png\"),\n  height = 800,\n  width = 1200,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: Warping or Re-sampling a continuous value raster (akin to reprojection) using terra::project() which uses bilinear method - estimates re-sampled raster values using distance weighted mean from nearest 4 cells.\n\n\n\n\nProjection Selection: Depends on the task. Use equal-area projections for density calculations, such as points per grid cell or inhabitants per grid cell.\nKey Functions:\n\nproject() (terra): Reprojects rasters.\nst_transform() (sf): Reprojects vector data.\n\nA more apparent example is shown in Figure 5 for Greenland’s elevation data from {geodata} (Hijmans et al. 2024) using terra::project()\n\n\n\nCode\ngreenland_raster &lt;- geodata::elevation_30s(\n  country = \"GRL\",\n  path = tempdir()\n  )\n\ngreenland_raster1 &lt;- greenland_raster |&gt; \n  terra::project(\n    \"EPSG:3413\",\n    method = \"bilinear\"\n  )\n\ng1 &lt;- ggplot() +\n  geom_spatraster(\n    data = greenland_raster\n  ) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Original Elevation Raster\",\n    subtitle = \"Geographic CRS: WGS 84 (EPSG:4326)\",\n    fill = \"Elevation (metres)\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = greenland_raster1\n  ) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Transformed Continuous Values Raster\",\n    subtitle = \"Projected CRS: EPSG:3413 (North Pole Stereographic)\",\n    fill = \"Elevation (metres)\"\n  )\n\n\ng &lt;- g1 + g2 +\n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    caption = \"Elevation, above sea level in metres from {geodata}\",\n    theme = theme(\n      plot.caption = element_text(\n        hjust = 0\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-8_2.png\"),\n  height = 700,\n  width = 1400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 5: Warping or Re-sampling elevation data for Greenland (obtained from {geodata} package) using terra::project() which uses bilinear method - estimates re-sampled raster values using distance weighted mean from nearest 4 cells.\n\n\n\n\n\n7.9 Custom Map Projections\n\nEstablished CRSs (e.g., EPSG:4326) are widely used but may not always fit specific needs; custom CRSs are an alternative.\nCustom CRS Creation: Modify existing WKT CRS definitions, example shown in Figure 6, with:\n\nFor vector objects: sf::st_crs() and sf::st_transform()\nFor raster objects: terra::crs() and terra::project()\n\n\n\n\nCode\n# Example creating a custom azimuthal equidistant (AEQD) CRS projection focussed on Greenland\n\n# Deduce the centre of Greenland\ngreenland |&gt; \n  st_centroid() |&gt; \n  st_geometry() |&gt; \n  st_as_text()\n# \"POINT (-41.81367 73.08122)\"\n\nst_crs(greenland)\n\ng1 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  labs(\n    title = \"WGS 84 (Geographic) CRS\",\n    subtitle = \"Default Geographic CRS in the data\"\n  )\n\ncustom_crs &lt;- ('PROJCS[\"Custom_AEQD\",\n GEOGCS[\"GCS_WGS_1984\",\n  DATUM[\"WGS_1984\",\n   SPHEROID[\"WGS_1984\",6378137.0,298.257223563]],\n  PRIMEM[\"Greenwich\",0.0],\n  UNIT[\"Degree\",0.0174532925199433]],\n PROJECTION[\"Azimuthal_Equidistant\"],\n PARAMETER[\"Central_Meridian\",-41.81367],\n PARAMETER[\"Latitude_Of_Origin\",73.08122],\n UNIT[\"Meter\",1.0]]')\n\ng2 &lt;- greenland |&gt; \n  ggplot() +\n  geom_sf() +\n  geom_sf(data = st_centroid(greenland), size = 1.5) +\n  coord_sf(crs = custom_crs) +\n  labs(\n    title = \"Custom AEQD CRS\",\n    subtitle = \"Focussed around the centroid of Greenland (black dot)\"\n  )\n\ng &lt;- g1 + g2 +\n  plot_layout(\n    nrow = 1\n  ) +\n  plot_annotation(\n    title = \"Creating a custom AEQD CRS for Greenland\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(hjust = 0.5, size = 30)\n    )\n  ) &\n  theme(\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 24, \n      face = \"bold\"\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-9_1.png\"),\n  height = 700,\n  width = 1400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 6: An example creating a custom azimuthal equidistant (AEQD) CRS projection focussed on Greenland\n\n\n\n\nProjection Wizard:\n\nInteractive tool for selecting spatial extents and distortion properties (Projection Wizard).\nGenerates WKT definitions for re-projections.\n\n\n\n\n\n\n\n\nNote\n\n\n\nKey Learnings from the Projection Wizard Website\n\nInteractive Custom Projections: Simplifies the creation of custom map projections based on user-defined extents and purposes.\nUser Guidance: Recommends optimal projections for specific geographic areas to minimize distortions.\nMultiple Criteria: Supports area, distance, direction, or local shape preservation in projections.\nExport Options: Provides projection strings (e.g., WKT, PROJ) for direct use in GIS and programming tools.\nEducational Resource: Visualizes distortions to enhance understanding of projection impacts.\n\n\n\n\nPROJ Strings:\n\nCreate projections with +proj= strings (PROJ documentation) as shown in an example in Figure 7\nCommon projections for World Maps:\n\nMollweide (+proj=moll): Preserves area relationships.\nWinkel Tripel (+proj=wintri): Minimizes distortion across spatial properties.\nLambert Azimuthal Equal-Area (+proj=laea): Centered with +lon_0 and +lat_0 parameters. The parameters can be changed to suit the location you want to focus on, as shown in example below.\n\n\n\n\n\nCode\n# An example to plot the World map focussed around 4 major cities\n\n# Getting the World Map\nworld_map &lt;- rnaturalearth::ne_countries(scale = \"small\")\n\n# Create a tibble of major cities with their latitude and longitude\nmajor_cities &lt;- tibble::tibble(\n  city = c(\"New York\", \"London\", \"Tokyo\", \"Sydney\"),\n  latitude = c(40.7128, 51.5074, 35.6895, -33.8688),\n  longitude = c(-74.0060, -0.1278, 139.6917, 151.2093)\n)\n\ncities_geometry &lt;- major_cities |&gt; \n  st_as_sf(coords = c(\"longitude\", \"latitude\")) |&gt; \n  st_set_crs(value = \"EPSG:4326\")\n\n\ncustom_plot &lt;- function(city_name){\n  # Select the city\n  city_df &lt;- major_cities |&gt; filter(city == city_name)\n  # Create custom LAEA projection focussed around the city coordinates\n  new_crs = paste0(\"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n                   city_df$longitude, \" +lat_0=\", \n                   city_df$latitude)\n  ggplot() +\n    geom_sf(data = world_map) +\n    geom_sf(\n      data = cities_geometry |&gt; filter(city == city_name),\n      size = 2, \n      colour = \"red\"\n    ) +\n    coord_sf(crs = new_crs) +\n    labs(\n      title = city_name,\n      subtitle = paste0(\"Custom LAEA projection centered around \", city_name)\n    ) +\n    theme(\n      axis.text = element_blank()\n    )\n}\n\ng1 &lt;- ggplot() +\n    geom_sf(data = world_map) +\n    labs(\n      title = \"World Map\",\n      subtitle = \"Default Geographic CRS: WGS 84\"\n    )\ng6 &lt;- ggplot() +\n    geom_sf(data = st_transform(world_map, crs = \"ESRI:54009\")) +\n    labs(\n      title = \"World Map (ESRI:54009)\",\n      subtitle = \"Mollweide Projection\"\n    )\n\ng2 &lt;- custom_plot(\"New York\")\ng3 &lt;- custom_plot(\"London\")\ng4 &lt;- custom_plot(\"Tokyo\")\ng5 &lt;- custom_plot(\"Sydney\")\n\nmy_design &lt;- (\"\nAAFF\nBCDE\n\")\n\ng &lt;- wrap_plots(g1, g2, g3, g4, g5, g6) +\n  plot_layout(\n    design = my_design,\n    heights = c(1.4, 1)\n  ) +\n  plot_annotation(\n    title = \"Creating custom projections with {sf} in R\",\n    subtitle = \"Lambert azimuthal equal-area projection, customized to be centered on any City around the globe\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(hjust = 0.5, size = 60, face = \"bold\"),\n      plot.subtitle = element_text(hjust = 0.5, size = 30, face = \"bold\")\n    )\n  ) &\n  theme(\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 24, \n      face = \"bold\"\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-9_2.png\"),\n  height = 1400,\n  width = 2000,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 7: An array of maps to demonstrate the power of R and {sf} to create custom projections. Part (a) shows the world map in Geographic CRS, best used for web-mapping. Part (b) shows the Mollweide Projection, showing the global map. The parts (c), (d), (e) and (f) are world maps focussed around a city around the globe in the Lambert Azimuthal Equal-Area projection, created using a custom function with coord_sf() and \"+proj\" strings.\n\n\n\n\nOther Resources:\n\nLearn about custom CRS definitions with WKT strings (OGC documentation).\nExplore PROJ parameters and CRS modifications (PROJ documentation).\n\n\n\n\n7.10 Exercises\n\n\nE1.\nCreate a new object called nz_wgs by transforming nz object into the WGS84 CRS.\n\nCreate an object of class crs for both and use this to query their CRSs.\nWith reference to the bounding box of each object, what units does each CRS use?\nRemove the CRS from nz_wgs and plot the result: what is wrong with this map of New Zealand and why?\n\nThe code chunk below shows the method to transform the CRS on nz object into WGS84 and querying their CRS using st_crs()$WktPretty |&gt; str_view(). The New Zealand Transverse Mercator 2000 projection uses 1 metre as a unit, and WGS84 uses 1 degree of longitude / latitude as a unit. The result of removing the CRS from the nz_wgs object is plotted, along with original nz_wgs object, in Figure 8 .\n\ndata(\"nz\")\nnz_wgs &lt;- nz |&gt;\n  st_transform(crs = \"EPSG:4326\")\nst_crs(nz)$WktPretty |&gt; str_view()\n\n[1] │ PROJCS[\"NZGD2000 / New Zealand Transverse Mercator 2000\",\n    │     GEOGCS[\"NZGD2000\",\n    │         DATUM[\"New_Zealand_Geodetic_Datum_2000\",\n    │             SPHEROID[\"GRS 1980\",6378137,298.257222101,\n    │                 AUTHORITY[\"EPSG\",\"7019\"]],\n    │             TOWGS84[0,0,0,0,0,0,0],\n    │             AUTHORITY[\"EPSG\",\"6167\"]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             AUTHORITY[\"EPSG\",\"8901\"]],\n    │         UNIT[\"degree\",0.0174532925199433,\n    │             AUTHORITY[\"EPSG\",\"9122\"]],\n    │         AUTHORITY[\"EPSG\",\"4167\"]],\n    │     PROJECTION[\"Transverse_Mercator\"],\n    │     PARAMETER[\"latitude_of_origin\",0],\n    │     PARAMETER[\"central_meridian\",173],\n    │     PARAMETER[\"scale_factor\",0.9996],\n    │     PARAMETER[\"false_easting\",1600000],\n    │     PARAMETER[\"false_northing\",10000000],\n    │     UNIT[\"metre\",1,\n    │         AUTHORITY[\"EPSG\",\"9001\"]],\n    │     AXIS[\"Easting\",EAST],\n    │     AXIS[\"Northing\",NORTH],\n    │     AUTHORITY[\"EPSG\",\"2193\"]]\n\nst_crs(nz_wgs)$WktPretty |&gt; str_view()\n\n[1] │ GEOGCS[\"WGS 84\",\n    │     DATUM[\"WGS_1984\",\n    │         SPHEROID[\"WGS 84\",6378137,298.257223563]],\n    │     PRIMEM[\"Greenwich\",0],\n    │     UNIT[\"degree\",0.0174532925199433,\n    │         AUTHORITY[\"EPSG\",\"9122\"]],\n    │     AXIS[\"Latitude\",NORTH],\n    │     AXIS[\"Longitude\",EAST],\n    │     AUTHORITY[\"EPSG\",\"4326\"]]\n\nst_crs(nz)$units\n\n[1] \"m\"\n\nst_crs(nz_wgs)$units\n\nNULL\n\n\n\n\nCode\ng1 &lt;- ggplot(data = nz_wgs) +\n  geom_sf() +\n  labs(\n    title = \"WGS84 Projection (Geographic)\",\n    subtitle = \"The map is shown in aspect ratio as per the projection.\"\n  ) +\n  theme(\n    plot.title.position = \"plot\"\n  )\n\nnz_wgs1 &lt;- nz_wgs\nst_crs(nz_wgs1) &lt;- NA\n\ng2 &lt;- ggplot(data = nz_wgs1) +\n  geom_sf() +\n  labs(\n    title = \"Same Map without projection (NA)\",\n    subtitle = \"The map loses its fixed aspect ratio, and converts to equal axes spacing.\"\n  ) +\n  theme(\n    plot.title.position = \"plot\"\n  )\n\ng &lt;- g1 + g2 +\n  plot_layout(\n    nrow = 1\n  ) +\n  plot_annotation(\n    title = \"Removing the CRS from New Zealand Map\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(hjust = 0.5, size = 30)\n    )\n  ) &\n  theme(\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 24, \n      face = \"bold\"\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-ex1.png\"),\n  height = 700,\n  width = 1400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 8: Removing the CRS from a map causes coord_sf() to use coord_equal() instead of desirable aspect ratio prescribed in the original CRS displays.\n\n\n\n\n\nE2.\nTransform the world dataset to the transverse Mercator projection (\"+proj=tmerc\") and plot the result. What has changed and why? Try to transform it back into WGS 84 and plot the new object. Why does the new object differ from the original one?\nThe Figure 9 shows the entire result of transforming a Geographic CRS: map (a) in Figure 9, into Transverse Mercator Projection: map (b) in Figure 9, and then re-projecting it back into the same geographic CRS WGS84: map (c) in Figure 9 .\nWhile geographic (GCS) and projected (PCS) systems allow versatile transformations, they are not perfectly reversible in real-world data due to floating-point precision limits and approximations inherent in projection algorithms. After transforming back to WGS 84, some distortions may appear because the process involves approximations during the transformation, especially if the intermediate PCS introduced distortion.\n\n\nCode\nworld &lt;- rnaturalearth::ne_countries(\n    scale = \"small\", \n    returnclass = \"sf\"\n  ) |&gt; \n  select(name, geometry)\n  # Removing Indonesia for easy plotting\n  # filter(name != \"Indonesia\")\n\ng1 &lt;- ggplot(data = world) +\n  geom_sf() +\n  labs(\n    title = \"Original World Map\",\n    subtitle = \"Geographic CRS: WGS84\"\n  )\n\ng2 &lt;- ggplot(data = world |&gt; st_transform(\"+proj=tmerc\")) +\n  geom_sf() +\n  labs(\n    title = \"Transverse Mercator Projection\",\n    subtitle = \"Using st_crs(\\\"proj=tmerc\\\")\"\n  )\n\ng3 &lt;- ggplot(\n  data = world |&gt; \n    st_transform(\"+proj=tmerc\") |&gt; \n    st_transform(\"WGS84\")\n  ) +\n  geom_sf() +\n  labs(\n    title = \"Back to original CRS (WGS84)\",\n    subtitle = \"Russian and Antarctica segments are distorted.\"\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    nrow = 1\n  ) +\n  plot_annotation(\n    title = \"Transforming, and reverting back from a Transverse Mercator to Geographic CRS\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(hjust = 0.5, size = 42)\n    )\n  ) &\n  theme(\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 24, \n      face = \"bold\"\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-ex2.png\"),\n  height = 700,\n  width = 2400,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 9: The entire result of transforming a Geographic CRS: original map (a), into (b) Transverse Mercator Projection, and then (c) back into the same geographic CRS WGS84.\n\n\n\n\n\nE3.\nTransform the continuous raster (con_raster) into NAD83 / UTM zone 12N using the nearest neighbor interpolation method. What has changed? How does it influence the results?\nThe code below, with the results shown in Figure 10, depicts an original continuous raster (con_raster) in part (a) of Figure 10, then the raster transformed into NAD83 / UTM Zone 12N with nearest neighbour method in part (b) of Figure 10, and finally, the raster transformed into NAD83 / UTM Zone 12N with bilinear method in part (c) of Figure 10 .\nChanges:\n\nThe spatial alignment and resolution may change depending on the target CRS and grid size.\nThe edges of the raster may introduce distortions or artifacts, especially if the original CRS and UTM grid are significantly different.\n\nImpact on Results:\n\nAdvantages: Nearest neighbor preserves the exact original values, which is critical for discrete data.\nDisadvantages: For continuous rasters, it may introduce blocky artifacts, reducing the smoothness and potentially affecting analyses like slope or gradient computation.\n\n\n\nCode\ncon_raster &lt;- rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = con_raster) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Original Raster\",\n    subtitle = \"Geographic CRS: WGS84\",\n    fill = \"Elevation (m)\"\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = con_raster |&gt; \n      terra::project(\"EPSG:32612\", method = \"near\")\n  ) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"NAD83 / UTM zone 12N\",\n    subtitle = \"Using method = \\\"near\\\"\",\n    fill = \"Elevation (m)\"\n  )\n\ng3 &lt;- ggplot() +\n  geom_spatraster(\n    data = con_raster |&gt; \n      terra::project(\"EPSG:32612\", method = \"bilinear\")\n  ) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"NAD83 / UTM zone 12N\",\n    subtitle = \"Using method = \\\"bilinear\\\"\",\n    fill = \"Elevation (m)\"\n  )\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Transforming a continuous raster using the nearest neighbor interpolation method.\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(hjust = 0.5, size = 42)\n    )\n  ) &\n  theme(\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 24, \n      face = \"bold\"\n    ),\n    legend.key.width = unit(5, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-ex3.png\"),\n  height = 700,\n  width = 1800,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 10\n\n\n\n\n\nE4.\nTransform the categorical raster (cat_raster) into WGS 84 using the bilinear interpolation method. What has changed? How does it influence the results?\nTransforming a categorical raster (cat_raster) from its original coordinate reference system (CRS) (NAD83 / UTM Zone 12N) (shown in (a) of Figure 11) into another CRS (such as WGS 84) using bilinear interpolation significantly alters its characteristics and interpretation, as shown in (b) of Figure 11.\n\nConversion of Raster Values:\n\nA categorical raster represents discrete classes, such as land cover types (e.g., forest, urban, water), using integer values that act as category identifiers.\nWhen transformed using bilinear interpolation, the algorithm treats these integers as continuous numeric values. It calculates a weighted average of the values from the nearest four cells in the input raster to assign values to the output raster.\nThis process results in non-integer values in the output raster, which no longer correspond to the original categories.\n\nLoss of Categorical Meaning: The integer values in the original raster have a specific meaning tied to the categories they represent (e.g., 1 = forest, 2 = urban). After bilinear interpolation, the resulting non-integer values are meaningless in the context of categorical data because they no longer map directly to the predefined classes.\nBlurring of Boundaries: Bilinear interpolation introduces smoothing between adjacent cells, which creates gradual transitions between values. This results in blurred boundaries between distinct categories, further distorting the original discrete nature of the data.\nIntroduction of Artefacts: The process can introduce artificial gradients or intermediate values that did not exist in the original data. For example, if the original raster has categories 1 (forest) and 2 (urban), interpolation might produce values like 1.5, which have no real-world significance.\n\nThis influences the results in the following ways: —\n\nInappropriate Representation: The output raster is now a continuous raster, which is unsuitable for applications requiring categorical data, such as land cover analysis or habitat classification. This could lead to misinterpretations if the data is used without understanding the transformation process.\nLoss of Original Information: The categorical structure and associated metadata (e.g., legends, class descriptions) are effectively destroyed, rendering the raster unusable for its original purpose.\nImpact on Analysis: Any analysis that relies on the classification of discrete land cover types (e.g., area statistics, habitat mapping) would yield invalid results, as the categories no longer exist in their original form.\n\nThus, for transforming categorical rasters between CRSs, nearest-neighbor interpolation (show in part (c) of Figure 11) should be used instead of bilinear interpolation. Nearest-neighbor interpolation preserves the integer values of the categories, ensuring that the categorical meaning of the data is retained.\n\n\nCode\ncat_raster &lt;- rast(system.file(\"raster/nlcd.tif\", \n                               package = \"spDataLarge\"))\n\n# Get the CRS of the raster\ncrs(cat_raster) |&gt; str_view()\n\n# Check associated colours with the raster\n# has.colors(cat_raster)\n# coltab(cat_raster)\n\n# My custom palette for uniformity\nmypal &lt;- c(\"#008ee0\", \"darkred\", \"grey80\", \"darkgreen\",\n           \"#858f42\", \"#90bf7e\", \"#d9e86b\", \"#96defa\")\ng1 &lt;- ggplot() +\n  geom_spatraster(data = cat_raster) +\n  scale_fill_manual(values = mypal) +\n  coord_sf(expand = FALSE) +\n  labs(\n    title = \"Categorical Raster\",\n    subtitle = \"CRS NAD83 / UTM Zone 12 N\",\n    fill = \"Land Cover Type\"\n  )\n\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = cat_raster |&gt; \n            project(\"WGS84\", method = \"bilinear\")\n  ) +\n  coord_sf(expand = FALSE) +\n  scale_fill_princess_c(na.value = \"black\") +\n  labs(\n    title = \"Projected Raster (bilinear)\",\n    subtitle = \"Raster converted into a Continuous Raster.\\nCategories are Lost !\",\n    fill = \"Value\"\n  )\n\ng3 &lt;- ggplot() +\n  geom_spatraster(\n    data = cat_raster |&gt; \n            project(\"WGS84\", method = \"near\")\n  ) +\n  coord_sf(expand = FALSE) +\n  scale_fill_manual(values = mypal, na.value = \"black\") +\n  labs(\n    title = \"Projected Raster (nearest neighbour)\",\n    subtitle = \"Interpolation into Geographic CRS: WGS84.\\nA new category of `NA` is introduced, as expected.\",\n    fill = \"Land Cover Type\"\n  )\n\n\ng &lt;- g1 + g2 + g3 +\n  plot_layout(\n    nrow = 1\n  ) +\n  plot_annotation(\n    title = \"Transforming a categorical raster using the nearest neighbor and bilinear interpolation method.\",\n    subtitle = \"Bilinear interpolation computes averages, and leads the raster to lose all meaning, and convert into a continuous raster. (NA values are in black).\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(hjust = 0.5, size = 36),\n      plot.subtitle = element_text(hjust = 0.5, size = 24)\n    )\n  ) &\n  theme(\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 24, \n      face = \"bold\"\n    ),\n    legend.key.width = unit(5, \"pt\"),\n    plot.margin = margin(0,5,0,5, \"pt\"),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"book_solutions\", \"images\", \"chapter7-ex4.png\"),\n  height = 800,\n  width = 2100,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 11\n\n\n\n\n\n\n\n\nReferences\n\nCheng, Joe, Barret Schloerke, Bhaskar Karambelkar, and Yihui Xie. 2024. “Leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library.” https://CRAN.R-project.org/package=leaflet.\n\n\nHijmans, Robert J. 2024a. “Terra: Spatial Data Analysis.” https://CRAN.R-project.org/package=terra.\n\n\n———. 2024b. “Terra: Spatial Data Analysis.” https://CRAN.R-project.org/package=terra.\n\n\nHijmans, Robert J., Márcia Barbosa, Aniruddha Ghosh, and Alex Mandel. 2024. “Geodata: Download Geographic Data.” https://CRAN.R-project.org/package=geodata.\n\n\nPebesma, Edzer, and Roger Bivand. 2023a. “Spatial Data Science: With Applications in r.” https://doi.org/10.1201/9780429459016.\n\n\n———. 2023b. “Spatial Data Science: With Applications in r,” 352. https://doi.org/10.1201/9780429459016.\n\n\nWalker, Kyle. 2022. “Crsuggest: Obtain Suggested Coordinate Reference System Information for Spatial Data.” https://CRAN.R-project.org/package=crsuggest."
  },
  {
    "objectID": "geocomputation/custom_geofacet.html",
    "href": "geocomputation/custom_geofacet.html",
    "title": "Customizing {geofacet} for plotting geographically faceted graphs",
    "section": "",
    "text": "The geofacet package provides an innovative approach to visualizing geographically structured data by arranging small multiples (facets) in a grid that mirrors the spatial arrangement of regions on a map. This facilitates comparison across regions while retaining geographical context. The package includes built-in grids for various regions, such as state_grid1 for the United States, but users can also create custom grids using grid_preview() to visualize the structure. Integration with ggplot2 allows for seamless creation of geofaceted visualizations, making it possible to apply any ggplot-compatible data. The package is highly customizable, with functions like facet_geo() providing flexibility to specify grids and scales. Additionally, geofacet supports data from other countries, such as Japan and Australia, with pre-built grids available for quick exploration. For more advanced applications, users can define their own layouts using add_custom_grid(). This makes geofacet a powerful tool for researchers and analysts working with spatially contextual data.\n\n\n\n\nCode\n# install.packages(\"geofacet\")\nlibrary(tidyverse)             # Data Wrangling\nlibrary(sf)                    # Simple Features in R\nlibrary(geofacet)              # Geographic faceting\nlibrary(patchwork)             # Compiling Plots\nlibrary(gt)                    # Great Tables in R  \n\n\n# Setting themes etc. ----------------------------------\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 14,\n    base_line_size = 0.2\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\"\n      ),\n      plot.title = element_text(\n        size = 24,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\")\n      ),\n      plot.subtitle = element_text(\n        size = 16,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\"),\n        lineheight = 0.3\n      )\n    )\n)\n\n\n\n\n\nThis code demonstrates how to use the geofacet package to create geofaceted bar plots shown in Figure 1, of state ranks for U.S. states, utilizing two different in-built grid layouts: us_state_grid1 and us_state_grid2. It showcases comparison across layouts by combining plots with patchwork, adding annotations, and saving the final visualization as an image.\n\n\nCode\ndata(\"state_ranks\")\n\ng1 &lt;- state_ranks |&gt; \n  as_tibble() |&gt; \n  mutate(variable = str_to_title(variable)) |&gt; \n  ggplot(aes(rank, variable, fill = variable)) +\n  geom_col() +\n  geom_text(\n    aes(label = rank),\n    size = 2,\n    colour = \"white\",\n    hjust = 1.1\n  ) +\n  facet_geo(~state) +\n  paletteer::scale_fill_paletteer_d(\n    \"ggthemes::Classic_Purple_Gray_6\"\n  ) +\n  labs(\n    y = NULL, x = \"Rank of the State\",\n    title = \"Layout 1: `us_state_grid1`\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.x = element_blank(),\n    plot.title = element_text(\n      hjust = 0, size = 48\n    )\n  )\n\ng2 &lt;- state_ranks |&gt; \n  as_tibble() |&gt; \n  mutate(variable = str_to_title(variable)) |&gt; \n  ggplot(aes(rank, variable, fill = variable)) +\n  geom_col() +\n  geom_text(\n    aes(label = rank),\n    size = 2,\n    colour = \"white\",\n    hjust = 1.1\n  ) +\n  facet_geo(~state, grid = \"us_state_grid2\") +\n  paletteer::scale_fill_paletteer_d(\n    \"ggthemes::Classic_Purple_Gray_6\"\n  ) +\n  labs(\n    y = NULL, x = \"Rank of the State\",\n    title = \"Layout 2: `us_state_grid2`\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.x = element_blank(),\n    plot.title = element_text(\n      hjust = 0, size = 48\n    )\n  )\n\n# Compiling Plots ----------------------------------------\ng &lt;- g1 + g2 + \n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  )  +\n  plot_annotation(\n    title = \"Two in-built payouts from {geofacet}\",\n    subtitle = \"Displaying state ranks for US states, using in-built dataset from {geofacet}\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(\n        hjust = 0.5, size = 54,\n        margin = margin(2,0,5,0, \"pt\"),\n        face = \"bold\"\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5, size = 36,\n        margin = margin(2,0,5,0, \"pt\")\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 48, face = \"bold\"\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    panel.spacing = unit(0, \"pt\"),\n    strip.text = element_text(\n      margin = margin(0,0,0,0, \"pt\"),\n      size = 24, face = \"bold\"\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"custom_geofacet_1.png\"),\n  height = 1300,\n  width = 3000,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Maps of USA with statitics (ranks) for each state plotted as horizontal bar charts. Facet layouts compiled using: for map (a) geofacet::facet_geo() and for map (b) using geofacet::facet_geo(grid = \"us_state_grid2\")"
  },
  {
    "objectID": "geocomputation/custom_geofacet.html#an-example-submitting-a-custom-grid-to-geofacet",
    "href": "geocomputation/custom_geofacet.html#an-example-submitting-a-custom-grid-to-geofacet",
    "title": "Customizing {geofacet} for plotting geographically faceted graphs",
    "section": "An Example: submitting a custom Grid to {geofacet}",
    "text": "An Example: submitting a custom Grid to {geofacet}\nCustom Facets for Districts of the state of Haryana\n\n\nCode\nlibrary(tibble)\nlibrary(gt)\n\nharyana_districts &lt;- tibble(\n  District_Name = c(\n    \"Ambala\", \"Bhiwani\", \"Charkhi Dadri\", \"Faridabad\", \"Fatehabad\",\n    \"Gurugram\", \"Hisar\", \"Jhajjar\", \"Jind\", \"Kaithal\",\n    \"Karnal\", \"Kurukshetra\", \"Mahendragarh\", \"Nuh\", \"Palwal\",\n    \"Panchkula\", \"Panipat\", \"Rewari\", \"Rohtak\", \"Sirsa\",\n    \"Sonipat\", \"Yamunanagar\"\n  ),\n  Two_Letter_Code = c(\n    \"AM\", \"BH\", \"CD\", \"FR\", \"FT\", \"GU\", \"HI\", \"JH\", \"JI\", \"KT\",\n    \"KR\", \"KU\", \"MA\", \"NU\", \"PW\", \"PK\", \"PP\", \"RE\", \"RO\", \"SI\",\n    \"SN\", \"YN\"\n  ),\n  Three_Letter_Code = c(\n    \"AMB\", \"BHW\", \"CHD\", \"FAR\", \"FAT\", \"GUR\", \"HIS\", \n    \"JHA\", \"JIN\", \"KAI\",\n    \"KAR\", \"KUR\", \"MAH\", \"NUH\", \"PAL\", \"PAN\", \"PNP\", \n    \"REW\", \"ROH\", \"SIR\", \"SON\", \"YAM\"\n  ),\n  Latitude = c(\n    30.3782, 28.7930, 28.5921, 28.4089, 29.5252,\n    28.4595, 29.1492, 28.6064, 29.3162, 29.8010,\n    29.6857, 29.9695, 28.2692, 28.1070, 28.1447,\n    30.6942, 29.3909, 28.1970, 28.8955, 29.5349,\n    28.9931, 30.1290\n  ),\n  Longitude = c(\n    76.7767, 76.1390, 76.2711, 77.3178, 75.4540,\n    77.0266, 75.7217, 76.6565, 76.3144, 76.3995,\n    76.9905, 76.8783, 76.1521, 77.0010, 77.3260,\n    76.8606, 76.9635, 76.6170, 76.6066, 75.0280,\n    77.0151, 77.2674\n  )\n)\n\ngt(haryana_districts) |&gt; \n  cols_label_with(fn = snakecase::to_title_case) |&gt; \n  fmt_number(columns = c(Latitude, Longitude)) |&gt; \n  opt_interactive()\n\n\n\n\nTable 1: Summary of 22 Districts in the state of Haryana, along with their approximate centroid locations\n\n\n\n\n\n\n\n\n\n\n\n\n\nDisplaying the custom grid design for Haryana created using geofacet::grid_design()\n\n\nCode\nharyana_grid &lt;- data.frame(\n  name = c(\"Panchkula\", \"Ambala\", \"Kaithal\", \"Yamunanagar\", \"Fatehabad\", \"Kurukshetra\", \"Karnal\", \"Sirsa\", \"Jind\", \"Panipat\", \"Hisar\", \"Rohtak\", \"Bhiwani\", \"Sonipat\", \"Charkhi Dadri\", \"Jhajjar\", \"Rewari\", \"Mahendragarh\", \"Faridabad\", \"Gurugram\", \"Nuh\", \"Palwal\"),\n  code = c(\"PAN\", \"AMB\", \"KAI\", \"YAM\", \"FAT\", \"KUR\", \"KAR\", \"SIR\", \"JIN\", \"PNP\", \"HIS\", \"ROH\", \"BHW\", \"SON\", \"CHD\", \"JHA\", \"REW\", \"MAH\", \"FAR\", \"GUR\", \"NUH\", \"PAL\"),\n  row = c(1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8),\n  col = c(4, 4, 3, 5, 2, 3, 4, 1, 3, 4, 2, 4, 2, 5, 3, 4, 3, 2, 5, 4, 4, 5),\n  stringsAsFactors = FALSE\n)\n\ngeofacet::grid_preview(\n  haryana_grid,\n  label = \"name\"\n  )\n\n\nRaw Data to display for Haryana districts\n\n\nCode\nlibrary(tidyverse)\nlibrary(gt)\nhy_zones &lt;- structure(list(buf_dist = structure(c(1L, 2L, 3L, 4L, 5L, 6L, \n7L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, \n3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, \n6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, \n2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, \n4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, \n1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, \n5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, \n2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, \n4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L), levels = c(\"&lt; 1 km\", \n\"1 - 4 km\", \"4 - 8 km\", \"8 - 12 km\", \"12 - 16 km\", \"16 - 20 km\", \n\"&gt; 20 km\"), class = \"factor\"), district = c(\"Ambala\", \"Ambala\", \n\"Ambala\", \"Ambala\", \"Ambala\", \"Ambala\", \"Ambala\", \"Bhiwani\", \n\"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \n\"Faridabad\", \"Faridabad\", \"Faridabad\", \"Faridabad\", \"Faridabad\", \n\"Faridabad\", \"Fatehabad\", \"Fatehabad\", \"Fatehabad\", \"Fatehabad\", \n\"Fatehabad\", \"Fatehabad\", \"Fatehabad\", \"Gurugram\", \"Gurugram\", \n\"Gurugram\", \"Gurugram\", \"Gurugram\", \"Gurugram\", \"Hisar\", \"Hisar\", \n\"Hisar\", \"Hisar\", \"Hisar\", \"Hisar\", \"Hisar\", \"Jhajjar\", \"Jhajjar\", \n\"Jhajjar\", \"Jhajjar\", \"Jhajjar\", \"Jhajjar\", \"Jind\", \"Jind\", \"Jind\", \n\"Jind\", \"Jind\", \"Jind\", \"Jind\", \"Kaithal\", \"Kaithal\", \"Kaithal\", \n\"Kaithal\", \"Kaithal\", \"Kaithal\", \"Kaithal\", \"Karnal\", \"Karnal\", \n\"Karnal\", \"Karnal\", \"Karnal\", \"Karnal\", \"Karnal\", \"Kurukshetra\", \n\"Kurukshetra\", \"Kurukshetra\", \"Kurukshetra\", \"Kurukshetra\", \"Kurukshetra\", \n\"Mahendragarh\", \"Mahendragarh\", \"Mahendragarh\", \"Mahendragarh\", \n\"Mahendragarh\", \"Mahendragarh\", \"Mahendragarh\", \"Mewat\", \"Mewat\", \n\"Mewat\", \"Mewat\", \"Mewat\", \"Mewat\", \"Palwal\", \"Palwal\", \"Palwal\", \n\"Palwal\", \"Palwal\", \"Palwal\", \"Panchkula\", \"Panchkula\", \"Panchkula\", \n\"Panchkula\", \"Panchkula\", \"Panchkula\", \"Panipat\", \"Panipat\", \n\"Panipat\", \"Panipat\", \"Panipat\", \"Panipat\", \"Rewari\", \"Rewari\", \n\"Rewari\", \"Rewari\", \"Rewari\", \"Rewari\", \"Rohtak\", \"Rohtak\", \"Rohtak\", \n\"Rohtak\", \"Rohtak\", \"Rohtak\", \"Rohtak\", \"Sirsa\", \"Sirsa\", \"Sirsa\", \n\"Sirsa\", \"Sirsa\", \"Sirsa\", \"Sirsa\", \"Sonipat\", \"Sonipat\", \"Sonipat\", \n\"Sonipat\", \"Sonipat\", \"Sonipat\", \"Sonipat\", \"Yamunanagar\", \"Yamunanagar\", \n\"Yamunanagar\", \"Yamunanagar\", \"Yamunanagar\", \"Yamunanagar\", \"Yamunanagar\", \n\"Charkhi Dadri\", \"Charkhi Dadri\", \"Charkhi Dadri\", \"Charkhi Dadri\", \n\"Charkhi Dadri\", \"Charkhi Dadri\"), perc = c(0.0329, 0.1599, 0.2706, \n0.2768, 0.2065, 0.0467, 0.0066, 0.0138, 0.1099, 0.2747, 0.3029, \n0.2181, 0.0781, 0.0025, 0.1514, 0.3398, 0.3459, 0.1553, 0.0076, \n0, 0.0131, 0.1151, 0.2478, 0.3059, 0.2378, 0.0765, 0.0039, 0.134, \n0.3348, 0.3725, 0.144, 0.0148, 0, 0.0198, 0.1407, 0.3248, 0.3301, \n0.1507, 0.0327, 0.0011, 0.0263, 0.2238, 0.4302, 0.2664, 0.0528, \n5e-04, 0.0152, 0.1458, 0.2934, 0.2476, 0.1642, 0.0774, 0.0564, \n0.0164, 0.1475, 0.3411, 0.2832, 0.1225, 0.0676, 0.0218, 0.0247, \n0.2134, 0.4162, 0.219, 0.0831, 0.0358, 0.0077, 0.0358, 0.2324, \n0.4168, 0.2253, 0.0823, 0.0073, 0.0226, 0.167, 0.3579, 0.3207, \n0.0972, 0.0212, 0.0134, 0.0167, 0.1676, 0.4231, 0.2727, 0.1134, \n0.0065, 0.0242, 0.1469, 0.3006, 0.3515, 0.1731, 0.0037, 0.0618, \n0.266, 0.3477, 0.2475, 0.0607, 0.0162, 0.0445, 0.2475, 0.4688, \n0.2171, 0.0217, 4e-04, 0.0262, 0.2104, 0.4112, 0.269, 0.0819, \n0.0013, 0.0359, 0.1939, 0.3301, 0.2855, 0.1055, 0.0407, 0.0082, \n0.0088, 0.088, 0.2127, 0.2543, 0.2169, 0.1081, 0.1112, 0.0313, \n0.2556, 0.4207, 0.2006, 0.0532, 0.0293, 0.0092, 0.029, 0.1784, \n0.3443, 0.2619, 0.1442, 0.0403, 0.0019, 0.0246, 0.2249, 0.4622, \n0.2321, 0.0512, 0.005)), row.names = c(NA, -144L), class = c(\"tbl_df\", \n\"tbl\", \"data.frame\"))\n\nhy_zones |&gt; \n  mutate(perc = perc * 100) |&gt; \n  pivot_wider(\n    id_cols = district,\n    names_from = buf_dist,\n    values_from = perc\n  ) |&gt; \n  gt() |&gt; \n  cols_label(\n    district = \"District\"\n  ) |&gt; \n  opt_interactive() |&gt; \n  tab_header(\n    title = \"Percentage area of each district, in each zone\",\n    subtitle = \"Column headings represent the distance from the nearest health-care facility\"\n  )\n\n\n\n\nTable 2: The Raw data for distance zones from nearest health-care facility for the 22 districts of Haryana\n\n\n\n\n\n\nPercentage area of each district, in each zone\nColumn headings represent the distance from the nearest health-care facility\n\n\n\n\n\n\n\n\n\nDisplaying Pie charts for each area\n\n\nCode\n# Setting themes etc. ----------------------------------\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 14,\n    base_line_size = 0.2\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\"\n      ),\n      plot.title = element_text(\n        size = 24,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\")\n      ),\n      plot.subtitle = element_text(\n        size = 16,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\"),\n        lineheight = 0.3\n      )\n    )\n)\n\n# Improve hy_zones tibble into final plotting tibble \"plotdf\"\nplotdf &lt;- hy_zones |&gt; \n  left_join(\n    haryana_districts |&gt; \n      select(District_Name, Three_Letter_Code),\n    by = join_by(district == District_Name)\n  ) |&gt; \n  rename(code = Three_Letter_Code,\n         name = district)\n\n# Routine facet plot ----------------------------------\ng1 &lt;- plotdf |&gt; \n  ggplot(\n    mapping = aes(\n      x = 1,\n      y = perc,\n      group = buf_dist,\n      fill = buf_dist\n    )\n  ) +\n  geom_col(\n    position = position_stack(),\n    colour = \"white\"\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(round(100 * perc, 1), \"%\")\n    ),\n    position = position_stack(\n      vjust = 0.5\n    ),\n    family = \"body_font\",\n    size = 2\n  ) +\n  scale_fill_manual(\n    values = paletteer::paletteer_d(\"MexBrewer::Taurus1\")\n  ) +\n  guides(\n    fill = guide_legend(\n      nrow = 1\n    )\n  ) +\n  facet_wrap(~name) +\n  coord_polar(\n    theta = \"y\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    fill = \"Distance from nearest health-care facility\",\n    title = \"Regular facet_wrap() layout\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 24\n  )\n\n# A custom geofacet layout ------------------------------\ng2 &lt;- plotdf |&gt; \n  drop_na() |&gt; \n  ggplot(\n    mapping = aes(\n      x = 1,\n      y = perc,\n      group = buf_dist,\n      fill = buf_dist\n    )\n  ) +\n  geom_col(\n    position = position_stack(),\n    colour = \"white\"\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(round(100 * perc, 1), \"%\")\n    ),\n    position = position_stack(\n      vjust = 0.5\n    ),\n    family = \"body_font\",\n    size = 2\n  ) +\n  scale_fill_manual(\n    values = paletteer::paletteer_d(\"MexBrewer::Taurus1\")\n  ) +\n  guides(\n    fill = guide_legend(\n      nrow = 1\n    )\n  ) +\n  facet_geo(\n    ~code, \n    grid = haryana_grid,\n    label = \"name\"\n  ) +\n  coord_polar(\n    theta = \"y\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    fill = \"Distance from nearest health-care facility\",\n    title = \"Customized facet_geo() layout\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 24\n  )\n\n\n# Compiling Plots ----------------------------------------\ng &lt;- g1 + g2 + \n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  )  +\n  plot_annotation(\n    title = \"Comparing facet_wrap() and facet_geo()\",\n    subtitle = \"Percentage area of each district in Haryana that falls within a certain distance zone from nearest health-care facility\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.subtitle = element_text(\n        hjust = 0.5, size = 36,\n        margin = margin(2,0,5,0, \"pt\")\n      )\n    )\n  ) &\n  theme(\n    panel.grid = element_blank(),\n    axis.text = element_blank(),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    panel.spacing = unit(0, \"pt\"),\n    strip.text = element_text(\n      margin = margin(0,0,0,0, \"pt\")\n    ),\n    legend.title = element_text(hjust = 0.5, size = 40,\n                                margin = margin(0,0,0,0, \"pt\")),\n    legend.text = element_text(\n      margin = margin(0,4,0,2, \"pt\")\n    ),\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 48,\n      margin = margin(2,2,2,2, \"pt\")\n    ),\n    plot.margin = margin(0,5,0,5, \"pt\"),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    plot.title = element_text(\n      size = 60, \n      margin = margin(2,0,2,0, \"pt\"),\n      hjust = 0.5\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"custom_geofacet_4.png\"),\n  height = 1800,\n  width = 3000,\n  unit = \"px\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "geocomputation/custom_geofacet.html#part-1-working-with-the-geofacet-package",
    "href": "geocomputation/custom_geofacet.html#part-1-working-with-the-geofacet-package",
    "title": "Customizing {geofacet} for plotting geographically faceted graphs",
    "section": "",
    "text": "The geofacet package provides an innovative approach to visualizing geographically structured data by arranging small multiples (facets) in a grid that mirrors the spatial arrangement of regions on a map. This facilitates comparison across regions while retaining geographical context. The package includes built-in grids for various regions, such as state_grid1 for the United States, but users can also create custom grids using grid_preview() to visualize the structure. Integration with ggplot2 allows for seamless creation of geofaceted visualizations, making it possible to apply any ggplot-compatible data. The package is highly customizable, with functions like facet_geo() providing flexibility to specify grids and scales. Additionally, geofacet supports data from other countries, such as Japan and Australia, with pre-built grids available for quick exploration. For more advanced applications, users can define their own layouts using add_custom_grid(). This makes geofacet a powerful tool for researchers and analysts working with spatially contextual data.\n\n\n\n\nCode\n# install.packages(\"geofacet\")\nlibrary(tidyverse)             # Data Wrangling\nlibrary(sf)                    # Simple Features in R\nlibrary(geofacet)              # Geographic faceting\nlibrary(patchwork)             # Compiling Plots\nlibrary(gt)                    # Great Tables in R  \n\n\n# Setting themes etc. ----------------------------------\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 14,\n    base_line_size = 0.2\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\"\n      ),\n      plot.title = element_text(\n        size = 24,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\")\n      ),\n      plot.subtitle = element_text(\n        size = 16,\n        margin = margin(0.1, 0.1, 0.1, 0.1, \"lines\"),\n        lineheight = 0.3\n      )\n    )\n)\n\n\n\n\n\nThis code demonstrates how to use the geofacet package to create geofaceted bar plots shown in Figure 1, of state ranks for U.S. states, utilizing two different in-built grid layouts: us_state_grid1 and us_state_grid2. It showcases comparison across layouts by combining plots with patchwork, adding annotations, and saving the final visualization as an image.\n\n\nCode\ndata(\"state_ranks\")\n\ng1 &lt;- state_ranks |&gt; \n  as_tibble() |&gt; \n  mutate(variable = str_to_title(variable)) |&gt; \n  ggplot(aes(rank, variable, fill = variable)) +\n  geom_col() +\n  geom_text(\n    aes(label = rank),\n    size = 2,\n    colour = \"white\",\n    hjust = 1.1\n  ) +\n  facet_geo(~state) +\n  paletteer::scale_fill_paletteer_d(\n    \"ggthemes::Classic_Purple_Gray_6\"\n  ) +\n  labs(\n    y = NULL, x = \"Rank of the State\",\n    title = \"Layout 1: `us_state_grid1`\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.x = element_blank(),\n    plot.title = element_text(\n      hjust = 0, size = 48\n    )\n  )\n\ng2 &lt;- state_ranks |&gt; \n  as_tibble() |&gt; \n  mutate(variable = str_to_title(variable)) |&gt; \n  ggplot(aes(rank, variable, fill = variable)) +\n  geom_col() +\n  geom_text(\n    aes(label = rank),\n    size = 2,\n    colour = \"white\",\n    hjust = 1.1\n  ) +\n  facet_geo(~state, grid = \"us_state_grid2\") +\n  paletteer::scale_fill_paletteer_d(\n    \"ggthemes::Classic_Purple_Gray_6\"\n  ) +\n  labs(\n    y = NULL, x = \"Rank of the State\",\n    title = \"Layout 2: `us_state_grid2`\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.x = element_blank(),\n    plot.title = element_text(\n      hjust = 0, size = 48\n    )\n  )\n\n# Compiling Plots ----------------------------------------\ng &lt;- g1 + g2 + \n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  )  +\n  plot_annotation(\n    title = \"Two in-built payouts from {geofacet}\",\n    subtitle = \"Displaying state ranks for US states, using in-built dataset from {geofacet}\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.title = element_text(\n        hjust = 0.5, size = 54,\n        margin = margin(2,0,5,0, \"pt\"),\n        face = \"bold\"\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5, size = 36,\n        margin = margin(2,0,5,0, \"pt\")\n      )\n    )\n  ) &\n  theme(\n    plot.tag = element_text(\n      size = 48, face = \"bold\"\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.text = element_text(\n      margin = margin(0,0,0,0, \"mm\")\n    ),\n    panel.spacing = unit(0, \"pt\"),\n    strip.text = element_text(\n      margin = margin(0,0,0,0, \"pt\"),\n      size = 24, face = \"bold\"\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"custom_geofacet_1.png\"),\n  height = 1300,\n  width = 3000,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Maps of USA with statitics (ranks) for each state plotted as horizontal bar charts. Facet layouts compiled using: for map (a) geofacet::facet_geo() and for map (b) using geofacet::facet_geo(grid = \"us_state_grid2\")"
  },
  {
    "objectID": "geocomputation/custom_geofacet.html#part-2-an-example-submitting-a-custom-grid-to-geofacet",
    "href": "geocomputation/custom_geofacet.html#part-2-an-example-submitting-a-custom-grid-to-geofacet",
    "title": "Customizing {geofacet} for plotting geographically faceted graphs",
    "section": "Part 2: An Example submitting a custom Grid to {geofacet}",
    "text": "Part 2: An Example submitting a custom Grid to {geofacet}\n\nAbout the 22 districts in the State of Haryana\nThis code creates a detailed summary table of the 22 districts of Haryana, including their names, codes, and approximate centroid locations (latitude and longitude). Using the tibble package, it structures the data, and the gt package formats it into an interactive table with customized column labels and number formatting, shown in Table 1.\n\n\nCode\nharyana_districts &lt;- tibble(\n  District_Name = c(\n    \"Ambala\", \"Bhiwani\", \"Charkhi Dadri\", \"Faridabad\", \"Fatehabad\",\n    \"Gurugram\", \"Hisar\", \"Jhajjar\", \"Jind\", \"Kaithal\",\n    \"Karnal\", \"Kurukshetra\", \"Mahendragarh\", \"Nuh\", \"Palwal\",\n    \"Panchkula\", \"Panipat\", \"Rewari\", \"Rohtak\", \"Sirsa\",\n    \"Sonipat\", \"Yamunanagar\"\n  ),\n  Two_Letter_Code = c(\n    \"AM\", \"BH\", \"CD\", \"FR\", \"FT\", \"GU\", \"HI\", \"JH\", \"JI\", \"KT\",\n    \"KR\", \"KU\", \"MA\", \"NU\", \"PW\", \"PK\", \"PP\", \"RE\", \"RO\", \"SI\",\n    \"SN\", \"YN\"\n  ),\n  Three_Letter_Code = c(\n    \"AMB\", \"BHW\", \"CHD\", \"FAR\", \"FAT\", \"GUR\", \"HIS\", \n    \"JHA\", \"JIN\", \"KAI\",\n    \"KAR\", \"KUR\", \"MAH\", \"NUH\", \"PAL\", \"PAN\", \"PNP\", \n    \"REW\", \"ROH\", \"SIR\", \"SON\", \"YAM\"\n  ),\n  Latitude = c(\n    30.3782, 28.7930, 28.5921, 28.4089, 29.5252,\n    28.4595, 29.1492, 28.6064, 29.3162, 29.8010,\n    29.6857, 29.9695, 28.2692, 28.1070, 28.1447,\n    30.6942, 29.3909, 28.1970, 28.8955, 29.5349,\n    28.9931, 30.1290\n  ),\n  Longitude = c(\n    76.7767, 76.1390, 76.2711, 77.3178, 75.4540,\n    77.0266, 75.7217, 76.6565, 76.3144, 76.3995,\n    76.9905, 76.8783, 76.1521, 77.0010, 77.3260,\n    76.8606, 76.9635, 76.6170, 76.6066, 75.0280,\n    77.0151, 77.2674\n  )\n)\n\ngt(haryana_districts) |&gt; \n  cols_label_with(fn = snakecase::to_title_case) |&gt; \n  fmt_number(columns = c(Latitude, Longitude)) |&gt; \n  opt_interactive() |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 1: Summary of 22 Districts in the state of Haryana, along with their approximate centroid locations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreating Haryana’s Custom {geofacet} grid\nThis code creates a custom geofacet grid for visualizing Haryana’s districts in a spatially relevant layout. It defines the grid’s structure using a data frame, previews the layout with grid_preview(), and customizes the appearance with titles and themes. Finally, the grid is saved as an image, shown in Figure 2.\n\n\nCode\nharyana_grid &lt;- data.frame(\n  name = c(\"Panchkula\", \"Ambala\", \"Kaithal\", \"Yamunanagar\", \"Fatehabad\", \"Kurukshetra\", \"Karnal\", \"Sirsa\", \"Jind\", \"Panipat\", \"Hisar\", \"Rohtak\", \"Bhiwani\", \"Sonipat\", \"Charkhi Dadri\", \"Jhajjar\", \"Rewari\", \"Mahendragarh\", \"Faridabad\", \"Gurugram\", \"Nuh\", \"Palwal\"),\n  code = c(\"PAN\", \"AMB\", \"KAI\", \"YAM\", \"FAT\", \"KUR\", \"KAR\", \"SIR\", \"JIN\", \"PNP\", \"HIS\", \"ROH\", \"BHW\", \"SON\", \"CHD\", \"JHA\", \"REW\", \"MAH\", \"FAR\", \"GUR\", \"NUH\", \"PAL\"),\n  row = c(1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8),\n  col = c(4, 4, 3, 5, 2, 3, 4, 1, 3, 4, 2, 4, 2, 5, 3, 4, 3, 2, 5, 4, 4, 5),\n  stringsAsFactors = FALSE\n)\n\ng &lt;- geofacet::grid_preview(\n  haryana_grid,\n  label = \"name\"\n  ) +\n  labs(\n    title = \"A custom geofacet grid for the districts in State of Haryana (India)\",\n    subtitle = \"Created using geofacet::grid_design()\",\n    x = \"Column Number\", y = \"Row Number\"\n  ) +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5\n    ),\n    plot.subtitle = element_text(\n      hjust = 0.5\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \n                        \"custom_geofacet_2.png\"),\n  height = 700,\n  width = 800,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 2: A custom grid created using geofacet::design_grid() is displayed using geofacet::grid_preview()\n\n\n\n\n\nAn example dataset to plot\nThis code creates an interactive table summarizing the percentage area of each zone, categorized by proximity to health-care facilities, across districts in Haryana. For how this data was calculated, and the compete project, check out this webpage. It uses tidyverse for data manipulation, reshapes the dataset with pivot_wider(), and formats the table using gt() with an interactive display and customized headers, shown in Table 2 .\n\n\nCode\nlibrary(tidyverse)\nlibrary(gt)\nhy_zones &lt;- structure(list(buf_dist = structure(c(1L, 2L, 3L, 4L, 5L, 6L, \n7L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, \n3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, \n6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, \n2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, \n4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, \n1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, \n5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, \n2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 1L, 2L, 3L, \n4L, 5L, 6L, 7L, 1L, 2L, 3L, 4L, 5L, 6L), levels = c(\"&lt; 1 km\", \n\"1 - 4 km\", \"4 - 8 km\", \"8 - 12 km\", \"12 - 16 km\", \"16 - 20 km\", \n\"&gt; 20 km\"), class = \"factor\"), district = c(\"Ambala\", \"Ambala\", \n\"Ambala\", \"Ambala\", \"Ambala\", \"Ambala\", \"Ambala\", \"Bhiwani\", \n\"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \"Bhiwani\", \n\"Faridabad\", \"Faridabad\", \"Faridabad\", \"Faridabad\", \"Faridabad\", \n\"Faridabad\", \"Fatehabad\", \"Fatehabad\", \"Fatehabad\", \"Fatehabad\", \n\"Fatehabad\", \"Fatehabad\", \"Fatehabad\", \"Gurugram\", \"Gurugram\", \n\"Gurugram\", \"Gurugram\", \"Gurugram\", \"Gurugram\", \"Hisar\", \"Hisar\", \n\"Hisar\", \"Hisar\", \"Hisar\", \"Hisar\", \"Hisar\", \"Jhajjar\", \"Jhajjar\", \n\"Jhajjar\", \"Jhajjar\", \"Jhajjar\", \"Jhajjar\", \"Jind\", \"Jind\", \"Jind\", \n\"Jind\", \"Jind\", \"Jind\", \"Jind\", \"Kaithal\", \"Kaithal\", \"Kaithal\", \n\"Kaithal\", \"Kaithal\", \"Kaithal\", \"Kaithal\", \"Karnal\", \"Karnal\", \n\"Karnal\", \"Karnal\", \"Karnal\", \"Karnal\", \"Karnal\", \"Kurukshetra\", \n\"Kurukshetra\", \"Kurukshetra\", \"Kurukshetra\", \"Kurukshetra\", \"Kurukshetra\", \n\"Mahendragarh\", \"Mahendragarh\", \"Mahendragarh\", \"Mahendragarh\", \n\"Mahendragarh\", \"Mahendragarh\", \"Mahendragarh\", \"Mewat\", \"Mewat\", \n\"Mewat\", \"Mewat\", \"Mewat\", \"Mewat\", \"Palwal\", \"Palwal\", \"Palwal\", \n\"Palwal\", \"Palwal\", \"Palwal\", \"Panchkula\", \"Panchkula\", \"Panchkula\", \n\"Panchkula\", \"Panchkula\", \"Panchkula\", \"Panipat\", \"Panipat\", \n\"Panipat\", \"Panipat\", \"Panipat\", \"Panipat\", \"Rewari\", \"Rewari\", \n\"Rewari\", \"Rewari\", \"Rewari\", \"Rewari\", \"Rohtak\", \"Rohtak\", \"Rohtak\", \n\"Rohtak\", \"Rohtak\", \"Rohtak\", \"Rohtak\", \"Sirsa\", \"Sirsa\", \"Sirsa\", \n\"Sirsa\", \"Sirsa\", \"Sirsa\", \"Sirsa\", \"Sonipat\", \"Sonipat\", \"Sonipat\", \n\"Sonipat\", \"Sonipat\", \"Sonipat\", \"Sonipat\", \"Yamunanagar\", \"Yamunanagar\", \n\"Yamunanagar\", \"Yamunanagar\", \"Yamunanagar\", \"Yamunanagar\", \"Yamunanagar\", \n\"Charkhi Dadri\", \"Charkhi Dadri\", \"Charkhi Dadri\", \"Charkhi Dadri\", \n\"Charkhi Dadri\", \"Charkhi Dadri\"), perc = c(0.0329, 0.1599, 0.2706, \n0.2768, 0.2065, 0.0467, 0.0066, 0.0138, 0.1099, 0.2747, 0.3029, \n0.2181, 0.0781, 0.0025, 0.1514, 0.3398, 0.3459, 0.1553, 0.0076, \n0, 0.0131, 0.1151, 0.2478, 0.3059, 0.2378, 0.0765, 0.0039, 0.134, \n0.3348, 0.3725, 0.144, 0.0148, 0, 0.0198, 0.1407, 0.3248, 0.3301, \n0.1507, 0.0327, 0.0011, 0.0263, 0.2238, 0.4302, 0.2664, 0.0528, \n5e-04, 0.0152, 0.1458, 0.2934, 0.2476, 0.1642, 0.0774, 0.0564, \n0.0164, 0.1475, 0.3411, 0.2832, 0.1225, 0.0676, 0.0218, 0.0247, \n0.2134, 0.4162, 0.219, 0.0831, 0.0358, 0.0077, 0.0358, 0.2324, \n0.4168, 0.2253, 0.0823, 0.0073, 0.0226, 0.167, 0.3579, 0.3207, \n0.0972, 0.0212, 0.0134, 0.0167, 0.1676, 0.4231, 0.2727, 0.1134, \n0.0065, 0.0242, 0.1469, 0.3006, 0.3515, 0.1731, 0.0037, 0.0618, \n0.266, 0.3477, 0.2475, 0.0607, 0.0162, 0.0445, 0.2475, 0.4688, \n0.2171, 0.0217, 4e-04, 0.0262, 0.2104, 0.4112, 0.269, 0.0819, \n0.0013, 0.0359, 0.1939, 0.3301, 0.2855, 0.1055, 0.0407, 0.0082, \n0.0088, 0.088, 0.2127, 0.2543, 0.2169, 0.1081, 0.1112, 0.0313, \n0.2556, 0.4207, 0.2006, 0.0532, 0.0293, 0.0092, 0.029, 0.1784, \n0.3443, 0.2619, 0.1442, 0.0403, 0.0019, 0.0246, 0.2249, 0.4622, \n0.2321, 0.0512, 0.005)), row.names = c(NA, -144L), class = c(\"tbl_df\", \n\"tbl\", \"data.frame\")) |&gt; \n  mutate(district = if_else(district == \"Mewat\", \"Nuh\", district))\n\nhy_zones |&gt; \n  mutate(perc = perc * 100) |&gt; \n  pivot_wider(\n    id_cols = district,\n    names_from = buf_dist,\n    values_from = perc\n  ) |&gt; \n  gt() |&gt; \n  cols_label(\n    district = \"District\"\n  ) |&gt; \n  opt_interactive() |&gt; \n  tab_header(\n    title = \"Percentage area of each district, in each zone\",\n    subtitle = \"Column headings represent the distance from the nearest health-care facility\"\n  ) |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 2: The Raw data for distance zones from nearest health-care facility for the 22 districts of Haryana\n\n\n\n\n\n\nPercentage area of each district, in each zone\nColumn headings represent the distance from the nearest health-care facility\n\n\n\n\n\n\n\n\n\n\n\nA customized {geofacet} graphic\nThis code demonstrates how to visualize the percentage of Haryana’s district areas within certain distance zones from health-care facilities using both standard facet_wrap() and customized facet_geo() layouts. The plots use stacked polar bar charts for comparison, with a custom geofacet layout reflecting Haryana’s spatial arrangement. The combined plots are styled, annotated, and saved as a PNG file for further use, shown in Figure 3 .\n\n\nCode\n# Improve hy_zones tibble into final plotting tibble \"plotdf\"\nplotdf &lt;- hy_zones |&gt; \n  left_join(\n    haryana_districts |&gt; \n      select(District_Name, Three_Letter_Code),\n    by = join_by(district == District_Name)\n  ) |&gt; \n  rename(code = Three_Letter_Code,\n         name = district)\n\n# Routine facet plot ----------------------------------\ng1 &lt;- plotdf |&gt; \n  ggplot(\n    mapping = aes(\n      x = 1,\n      y = perc,\n      group = buf_dist,\n      fill = buf_dist\n    )\n  ) +\n  geom_col(\n    position = position_stack(),\n    colour = \"white\",\n    linewidth = 0.2\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(round(100 * perc, 1), \"%\")\n    ),\n    position = position_stack(\n      vjust = 0.5\n    ),\n    family = \"body_font\",\n    size = 4,\n    check_overlap = TRUE\n  ) +\n  scale_x_continuous(expand = expansion(0)) +\n  scale_fill_manual(\n    values = paletteer::paletteer_d(\"MexBrewer::Taurus1\")\n  ) +\n  guides(\n    fill = guide_legend(\n      nrow = 1\n    )\n  ) +\n  facet_wrap(~name) +\n  coord_polar(\n    theta = \"y\"\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    fill = \"Distance from nearest health-care facility\",\n    title = \"Regular facet_wrap() layout\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 24\n  )\n\n# A custom geofacet layout ------------------------------\ng2 &lt;- plotdf |&gt; \n  drop_na() |&gt; \n  ggplot(\n    mapping = aes(\n      x = 1,\n      y = perc,\n      group = buf_dist,\n      fill = buf_dist\n    )\n  ) +\n  geom_col(\n    position = position_stack(),\n    colour = \"white\",\n    linewidth = 0.2\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(round(100 * perc, 1), \"%\")\n    ),\n    position = position_stack(\n      vjust = 0.5\n    ),\n    family = \"body_font\",\n    size = 4,\n    check_overlap = TRUE\n  ) +\n  scale_x_continuous(expand = expansion(0)) +\n  scale_fill_manual(\n    values = paletteer::paletteer_d(\"MexBrewer::Taurus1\")\n  ) +\n  guides(\n    fill = guide_legend(\n      nrow = 1\n    )\n  ) +\n  facet_geo(\n    ~code, \n    grid = haryana_grid,\n    label = \"name\"\n  ) +\n  coord_radial(\n    theta = \"y\",\n    expand = FALSE\n  ) +\n  labs(\n    x = NULL, y = NULL,\n    fill = \"Distance from nearest health-care facility\",\n    title = \"Customized facet_geo() layout\"\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = 24\n  )\n\n\n# Compiling Plots ----------------------------------------\ng &lt;- g1 + g2 + \n  plot_layout(\n    nrow = 1,\n    guides = \"collect\"\n  )  +\n  plot_annotation(\n    title = \"Comparing facet_wrap() and facet_geo()\",\n    subtitle = \"Percentage area of each district in Haryana that falls within a certain distance zone from nearest health-care facility\",\n    tag_levels = \"a\",\n    tag_prefix = \"(\",\n    tag_suffix = \")\",\n    theme = theme(\n      plot.subtitle = element_text(\n        hjust = 0.5, size = 36,\n        margin = margin(2,0,5,0, \"pt\")\n      )\n    )\n  ) &\n  theme(\n    panel.grid = element_blank(),\n    axis.text = element_blank(),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    panel.spacing = unit(0, \"pt\"),\n    strip.text = element_text(\n      margin = margin(0,0,0,0, \"pt\")\n    ),\n    legend.title = element_text(hjust = 0.5, size = 40,\n                                margin = margin(0,0,2,0, \"pt\")),\n    legend.text = element_text(\n      margin = margin(0,4,0,2, \"pt\")\n    ),\n    plot.title.position = \"plot\",\n    plot.tag = element_text(\n      size = 48,\n      margin = margin(2,2,2,2, \"pt\")\n    ),\n    plot.margin = margin(0,5,0,5, \"pt\"),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    plot.title = element_text(\n      size = 60, \n      margin = margin(2,0,2,0, \"pt\"),\n      hjust = 0.5\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"custom_geofacet_4.png\"),\n  height = 2400,\n  width = 3000,\n  unit = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 3: Two plots. (a) Displaying the percentage area of each district that falls within a certain zone as pie charts arranged in regular faceted pattern of {ggplot2} using facet_wrap(). (b) Same pie charts now arranged in a custom {geofacet} layout provided using facet_geo()\n\n\n\nThe Figure 4 shows a graphic for custom facet_geo() to publish online. The full code to generate it is here.\n\n\n\n\n\n\nFigure 4: Pie-charts depicting the percentage area of each district of Haryana that falls within a particular distance zone from the nearest health-care facility. The charts are arranged in a customized facet pattern using geofacet::facet_geo() to mimic the approximate geographic location of the districts."
  },
  {
    "objectID": "book_solutions/chapter8.html",
    "href": "book_solutions/chapter8.html",
    "title": "Chapter 8: Geographic data I/O",
    "section": "",
    "text": "Code\nlibrary(sf)        # Simple Features in R\nlibrary(terra)     # Handling rasters in R\nlibrary(tidyterra) # For plotting rasters in ggplot2\nlibrary(magrittr)  # Using pipes with raster objects\nlibrary(tidyverse) # All things tidy; Data Wrangling\nlibrary(spData)    # Spatial Datasets\nlibrary(patchwork) # Composing plots\nlibrary(gt)        # Display GT tables with R"
  },
  {
    "objectID": "book_solutions/chapter8.html#introduction",
    "href": "book_solutions/chapter8.html#introduction",
    "title": "Chapter 8: Geographic data I/O",
    "section": "8.1 Introduction",
    "text": "8.1 Introduction\n\nImportance of Data I/O: Geographic data input/output (I/O) is critical for geocomputation, ensuring accurate real-world applications and enabling data sharing.\nImpact of Errors: Mistakes in data I/O (e.g., using outdated datasets) can cause significant issues later in projects."
  },
  {
    "objectID": "book_solutions/chapter8.html#file-formats",
    "href": "book_solutions/chapter8.html#file-formats",
    "title": "Chapter 8: Geographic data I/O",
    "section": "8.2 File Formats",
    "text": "8.2 File Formats\n\nGeographic data storage: Stored as files or spatial databases. File formats can store either vector or raster data; databases can handle both, and the most common types are shown in Table 1.\n\n\n\nCode\n# A Code to fetch icons of different file formats\n# Get file icons for common file types\nfile_format = c(\n  \"Shapefile\", \"GeoJSON\", \"KML\", \"GPKG\", \"CSV\", \"DXF\", \"MapInfo File\", \"GML\", \n  \"PostGIS\", \"TopoJSON\", \"GeoTIFF\", \"NetCDF\", \"JPEG\", \"PNG\", \"HDF4\", \"HDF5\", \n  \"GRIB\", \"Erdas Imagine\", \"ASCII Grid\", \"MBTiles\")\n\ntemp_df &lt;- tibble(\n  file_format = file_format,\n  id = 1:20\n)\n\n# Get a custom google search engine and API key\n# Tutorial: https://developers.google.com/custom-search/v1/overview\n# Tutorial 2: https://programmablesearchengine.google.com/\n# google_api_key &lt;- \"LOAD YOUR GOOGLE API KEY HERE\"\n# my_cx &lt;- \"GET YOUR CUSTOM SEARCH ENGINE ID HERE\"\n\n\n# Load necessary packages\nlibrary(httr)\nlibrary(magick)\n\n# Define function to download and save movie poster\ndownload_icons &lt;- function(file_format_name, id) {\n  \n  api_key &lt;- google_api_key\n  cx &lt;- my_cx\n  \n  # Build the API request URL\n  url &lt;- paste0(\"https://www.googleapis.com/customsearch/v1?q=\", \n                URLencode(paste0(file_format_name, \" file icon svg\")), \n                \"&cx=\", cx, \n                \"&searchType=image&key=\", api_key)\n  \n  # Make the request\n  response &lt;- GET(url)\n  result &lt;- content(response, \"parsed\")\n  \n  # Get the URL of the first image result\n  image_url &lt;- result$items[[1]]$link\n  \n  im &lt;- magick::image_read(image_url) |&gt; \n    image_resize(\"x100\")\n  \n  # set background as white\n  image_write(\n    image = im,\n    path = here::here(\"book_solutions\", \"images\", \"temp_icons\", \n                      paste0(\"temp_icon_\", id,\".png\")),\n    format = \"png\"\n    )\n}\n\nfor (i in 1:20) {\n  download_icons(\n    file_format_name = temp_df$file_format[i],\n    id = i\n  )\n}\n\n\n# for (i in c(1:3, 5:14, 16:17, 19)) {\n#   download_icons(\n#     file_format_name = temp_df$file_format[i],\n#     id = i\n#   )\n# }\n\n# Some custom work\nimage_url_4 &lt;- \"https://icons.veryicon.com/png/o/construction-tools/supermap-gis-product-color-system-function/postgis-workspace.png\"\n\nimage_url_15 &lt;- \"https://cdn.iconscout.com/icon/premium/png-256-thumb/hdf-file-2538306-2129659.png\"\n\nimage_url_18 &lt;- \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQA0Pb2JqaMO5UGuYCgZzRi4BXQCw9lbmTDvg&s\"\n\nimage_url_20 &lt;- \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRlucEC8-sm9U0IXIfY-wh_c3nBFKLyg0JJdQ&s\"\n\nimage_url_19 &lt;- \"https://cdn.iconscout.com/icon/premium/png-256-thumb/ascii-file-1934516-1634566.png?f=webp&w=256\"\n\ndownload_icon_custom &lt;- function(id) {\n  im &lt;- magick::image_read(get(paste0(\"image_url_\", id))) |&gt;\n    image_resize(\"x100\")\n\n  # set background as white\n  image_write(\n    image = im,\n    path = here::here(\"book_solutions\", \"images\", \"temp_icons\",\n                      paste0(\"temp_icon_\", id,\".png\")),\n    format = \"png\"\n    )\n}\n\nfor (i in c(4, 15, 18, 20)) {\n  download_icon_custom(i)\n}\n\nimage_url_7 &lt;- \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR0Zb1IW-Ui71fJQy4G5kj3Ue2zQop38Kn1mA&s\"\n\nimage_url_12 &lt;- \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTr8HP5xS8im3nK5Zm8l4iP8zDrGhoiakFbCA&s\"\n\nfor (i in c(7, 12, 19)) {\n  download_icon_custom(i)\n}\n\nimage_url_11 &lt;- \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSHPryNCuawMSnTpre5hHZZiGuWqAhRQsjWQg&s\"\n\ndownload_icon_custom(11)\n\n\n\n\nCode\n# Get file icons for common file types\nfile_format = c(\n  \"Shapefile\", \"GeoJSON\", \"KML\", \"GPKG\", \"CSV\", \"DXF\", \"MapInfo File\", \"GML\", \n  \"PostGIS\", \"TopoJSON\", \"GeoTIFF\", \"NetCDF\", \"JPEG\", \"PNG\", \"HDF4\", \"HDF5\", \n  \"GRIB\", \"Erdas Imagine\", \"ASCII Grid\", \"MBTiles\")\n\ntemp_df &lt;- tibble(\n  file_format = file_format,\n  id = 1:20\n)\n\n\n# Raster formats tibble\nraster_formats &lt;- tibble(\n  Format = c(\n    \"GeoTIFF\", \"NetCDF\", \"JPEG\", \"PNG\", \"HDF4\", \"HDF5\", \n    \"GRIB\", \"Erdas Imagine\", \"ASCII Grid\", \"MBTiles\"\n  ),\n  Description = c(\n    \"Tagged Image File Format for georeferenced raster data.\",\n    \"Network Common Data Form for array-oriented scientific data.\",\n    \"Compressed image format commonly used for photographic images.\",\n    \"Portable Network Graphics format for raster graphics.\",\n    \"Hierarchical Data Format v4 for scientific data.\",\n    \"Hierarchical Data Format v5, successor to HDF4.\",\n    \"Gridded Binary format for meteorological data.\",\n    \"Raster format for Erdas Imagine software.\",\n    \"ASCII representation of raster data.\",\n    \"SQLite-based raster tile storage format.\"\n  ),\n  Extension = c(\n    \".tif/.tiff\", \".nc\", \".jpg/.jpeg\", \".png\", \".hdf\", \n    \".h5\", \".grb/.grib\", \".img\", \".asc\", \".mbtiles\"\n  ),\n  GeoReferencing = c(\n    \"Yes\", \"Yes\", \"No\", \"No\", \"Yes\", \"Yes\", \n    \"Yes\", \"Yes\", \"Yes\", \"Yes\"\n  )\n) |&gt; \n  mutate(group = \"Raster File Formats\")\n\n# Vector formats tibble\nvector_formats &lt;- tibble(\n  Format = c(\"Shapefile\", \"GeoJSON\", \"KML\", \"GPKG\", \"CSV\", \"DXF\", \n             \"MapInfo File\", \"GML\", \"PostGIS\", \"TopoJSON\"),\n  Description = c(\n    \"Esri Shapefile format for vector geometries.\",\n    \"GeoJSON format for encoding a variety of geographic data structures.\",\n    \"Keyhole Markup Language for geographic data in XML.\",\n    \"Geopackage format for spatial data storage.\",\n    \"Comma-Separated Values for point data with attributes.\",\n    \"Drawing Exchange Format for CAD data.\",\n    \"MapInfo TAB format for vector geometries.\",\n    \"Geography Markup Language for XML-based vector data.\",\n    \"PostGIS spatial extension for PostgreSQL database.\",\n    \"TopoJSON format for topology-preserving JSON data.\"\n  ),\n  Extension = c(\".shp\", \".geojson\", \".kml\", \".gpkg\", \".csv\", \".dxf\", \n                \".tab\", \".gml\", \"PostgreSQL\", \".topojson\"),\n  GeoReferencing = c(\n    \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"No\", \"No\", \n    \"Yes\", \"Yes\", \"Yes\", \"Yes\"\n  )\n) |&gt; \n  mutate(\n    group = \"Vector File Formats\"\n  )\n\n# Display vector formats table\nbind_rows(\n  vector_formats,\n  raster_formats\n) |&gt; \n  left_join(temp_df, by = join_by(Format == file_format)) |&gt; \n  mutate(file_path = paste0(\"images/temp_icons/temp_icon_\", id, \".png\")) |&gt; \n  select(-id) |&gt; \n  group_by(group) |&gt; \n  gt() |&gt; \n  cols_label(\n    Format = \"File Format\",\n    Description = \"Description\",\n    Extension = \"File Extension\",\n    GeoReferencing = \"Geo-referencing\",\n    file_path = \"File Icon\"\n  ) |&gt; \n  tab_footnote(\n    md(\"_**Source**: GDAL documentation (https://gdal.org/)_\")\n  ) |&gt; \n  tab_header(\n    title = \"Different kinds of file formats for geographical data\"\n  ) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  fmt_image(\n    columns = file_path\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_body(\n      columns = Format\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(color = \"darkgreen\", weight = \"bold\")\n    ),\n    locations = cells_body(\n      rows = GeoReferencing == \"Yes\",\n      columns = GeoReferencing\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(color = \"red\", weight = \"bold\")\n    ),\n    locations = cells_body(\n      rows = GeoReferencing == \"No\",\n      columns = GeoReferencing\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(align = \"center\")\n    ),\n    locations = cells_body(\n      columns = c(Extension, GeoReferencing)\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(align = \"left\")\n    ),\n    locations = cells_body(\n      columns = Description\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_fill(color = \"lightgrey\"),    \n      cell_text(weight = \"bold\", align = \"center\")      \n    ),\n    locations = cells_row_groups()           \n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(align = \"center\")\n    ),\n    locations = cells_title()\n  )\n\n\n\n\nTable 1: Different kinds of File Formats dealing with Geo-Spatial Data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferent kinds of file formats for geographical data\n\n\nFile Format\nDescription\nFile Extension\nGeo-referencing\nFile Icon\n\n\n\n\nVector File Formats\n\n\nShapefile\nEsri Shapefile format for vector geometries.\n.shp\nYes\n\n\n\nGeoJSON\nGeoJSON format for encoding a variety of geographic data structures.\n.geojson\nYes\n\n\n\nKML\nKeyhole Markup Language for geographic data in XML.\n.kml\nYes\n\n\n\nGPKG\nGeopackage format for spatial data storage.\n.gpkg\nYes\n\n\n\nCSV\nComma-Separated Values for point data with attributes.\n.csv\nNo\n\n\n\nDXF\nDrawing Exchange Format for CAD data.\n.dxf\nNo\n\n\n\nMapInfo File\nMapInfo TAB format for vector geometries.\n.tab\nYes\n\n\n\nGML\nGeography Markup Language for XML-based vector data.\n.gml\nYes\n\n\n\nPostGIS\nPostGIS spatial extension for PostgreSQL database.\nPostgreSQL\nYes\n\n\n\nTopoJSON\nTopoJSON format for topology-preserving JSON data.\n.topojson\nYes\n\n\n\nRaster File Formats\n\n\nGeoTIFF\nTagged Image File Format for georeferenced raster data.\n.tif/.tiff\nYes\n\n\n\nNetCDF\nNetwork Common Data Form for array-oriented scientific data.\n.nc\nYes\n\n\n\nJPEG\nCompressed image format commonly used for photographic images.\n.jpg/.jpeg\nNo\n\n\n\nPNG\nPortable Network Graphics format for raster graphics.\n.png\nNo\n\n\n\nHDF4\nHierarchical Data Format v4 for scientific data.\n.hdf\nYes\n\n\n\nHDF5\nHierarchical Data Format v5, successor to HDF4.\n.h5\nYes\n\n\n\nGRIB\nGridded Binary format for meteorological data.\n.grb/.grib\nYes\n\n\n\nErdas Imagine\nRaster format for Erdas Imagine software.\n.img\nYes\n\n\n\nASCII Grid\nASCII representation of raster data.\n.asc\nYes\n\n\n\nMBTiles\nSQLite-based raster tile storage format.\n.mbtiles\nYes\n\n\n\n\nSource: GDAL documentation (https://gdal.org/)\n\n\n\n\n\n\n\n\n\n\n\n\nGDAL (Geospatial Data Abstraction Library):\n\nUnified library for reading/writing raster and vector formats since the year 2000.\nPowers GIS software like GRASS GIS, ArcGIS, and QGIS.\nSupports over 200 vector and raster formats.\n\nCommon vector file formats:\n\nESRI Shapefile: Multi-file format; limited by 2GB size, 255 columns, and 10-character names.\nGeoJSON: JSON-based, supports coordinates; open format.\nKML/KMZ: XML-based; used for Google Earth.\nGPX: GPS data exchange.\nFlatGeobuf: Fast, single-file with streaming capabilities.\n\nCommon raster file formats:\n\nGeoTIFF: Popular raster format embedding CRS; supports COG (Cloud Optimized GeoTIFF) for efficient online access.\nArc ASCII: Text-based raster format with header and cell values.\n\nDatabase formats:\n\nSQLite/SpatiaLite: Lightweight relational database with spatial extensions.\nESRI FileGDB: Proprietary database format supporting feature classes and topology.\nGeoPackage: Open standard SQLite-based lightweight spatial database for vector, raster, and non-spatial data.\n\nOpen standards by OGC (Open Geospatial Consortium):\n\nPromotes transparency and user-driven development.\nFormats like GML, KML, and GeoPackage adhere to OGC standards.\n\n\n\n\n\n\n\n\nShapeFiles and their Limitations\n\n\n\nESRI Shapefiles have been a cornerstone in geospatial data exchange since their introduction in the early 1990s.\nReasons for Shapefile Popularity:\n\nHistorical Prevalence: Introduced by ESRI in the early 1990s, Shapefiles became widely adopted due to their early entry into the GIS market.\nSimplicity and Compatibility: Shapefiles are straightforward to use and are supported by a vast array of GIS software, facilitating easy sharing and exchange of geographic information across different platforms.\nOpen Specification: Despite being a proprietary format, ESRI published the technical specifications for Shapefiles, allowing other software developers to implement support for them, which contributed to their widespread adoption.\n\nContents of a ShapeFile Folder\n\n.shp: Stores geometric shape data (points, lines, polygons).\n.shx: Index file for quick spatial queries of shapes.\n.dbf: Attribute table with associated data in tabular format.\n.prj: Coordinate system and projection information.\n.cpg: Encoding of character data (e.g., UTF-8).\n.sbn/.sbx: Optional spatial index for faster searches.\n.qpj: Alternative projection format used by some software.\n\nLimitations of Shapefiles:\n\nMulti-File Structure: A single Shapefile consists of multiple files (e.g., .shp, .shx, .dbf), which can complicate file management and increase the risk of losing associated files.\nAttribute Constraints: Field names in the attribute table are limited to 10 characters, and the maximum number of fields is 255, restricting the complexity of attribute data that can be stored.\nFile Size Limitation: Shapefiles have a maximum size limit of 2 GB, which can be restrictive for large datasets.\nLack of Topological Information: Shapefiles do not store topological relationships between features, limiting their utility in analyses that require such information.\nLimited Data Types and Encoding: Shapefiles have poor support for Unicode, limiting international character representation, and they cannot store null values for numeric or text fields, which can lead to data inaccuracies.\n\nEmerging Alternatives:\n\nGeoPackage: An open, standards-based format developed by the Open Geospatial Consortium (OGC), GeoPackage uses a single SQLite database file to store both vector and raster data, overcoming many of the limitations associated with Shapefiles.\nFile Geodatabase: ESRI’s File Geodatabase offers a more robust solution with no size limitations, support for complex data types, and improved performance, making it a suitable alternative for users within the ESRI ecosystem.\nGeoJSON: A format based on JavaScript Object Notation (JSON), GeoJSON is widely used for web applications and supports a variety of geometry types, making it a flexible alternative for sharing geospatial data, especially in web environments.\nFlatGeobuf: A modern, open format designed for performant reading and writing of geospatial data, FlatGeobuf supports spatial indexing and is suitable for web and cloud environments.\n\n\n\n\nOther new emerging formats:\n\nLAS/LAZ: For lidar point clouds.\nNetCDF/HDF: For multidimensional arrays.\nEmerging formats: GeoArrow, Zarr.\n\nNon-spatial formats:\n\nTabular formats (e.g., CSV, Excel) used for simple spatial data sharing.\nLack support for complex geometries and spatial metadata like CRS.\n\nAdditional resources:\n\nGDAL Documentation offers comprehensive details on supported vector formats and raster formats."
  },
  {
    "objectID": "book_solutions/chapter8.html#data-input-i",
    "href": "book_solutions/chapter8.html#data-input-i",
    "title": "Chapter 8: Geographic data I/O",
    "section": "8.3 Data input (I)",
    "text": "8.3 Data input (I)\n\nLoading vector data: Use sf::read_sf() to load vector data into R.\nLoading raster data: Use terra::rast() to read raster data.\nData storage: Imported data is stored in RAM and becomes accessible in the .GlobalEnv of the session.\nWorkspace management: Imported objects can be listed with ls() and are visible in IDE ‘Environment’ panels.\n\n\n8.3.1 Vector Data\n\nSpatial vector data formats: Common formats include .geojson, .gpkg, .shp. Import these with sf::read_sf() or sf::st_read(), which rely on GDAL drivers.\nDriver overview: Use sf::st_drivers() to see available GDAL drivers, their features, and file format capabilities (e.g., vector, raster support).\n\n\n\nCode\nst_drivers(\"vector\") |&gt; \n  as_tibble() |&gt; \n  select(name, long_name, write, copy, is_raster) |&gt; \n  mutate(\n    write = if_else(write, \"Yes\", NA),\n    copy = if_else(copy, \"Yes\", NA),\n    is_raster = if_else(is_raster, \"Yes\", NA)\n  ) |&gt; \n  gt::gt() |&gt; \n  cols_label(\n    name = \"Name\",\n    long_name = \"Full Name of file format\",\n    write = \"Can Write?\",\n    copy = \"Can copy?\",\n    is_raster = \"Also handles rasters?\"\n  ) |&gt; \n  sub_missing(missing_text = \"\") |&gt; \n  tab_style(\n    locations = cells_body(\n      columns = c(write, copy, is_raster)\n    ),\n    style = list(\n      cell_text(\n        align = \"center\"\n      )\n    )\n  ) |&gt; \n  tab_style(\n    locations = cells_body(\n      columns = name\n    ),\n    style = list(\n      cell_text(\n        font = \"monospace\"\n      )\n    )\n  ) |&gt; \n  opt_interactive()\n\n\n\n\nTable 2: The drivers available to GDAL, and therefore {sf}, in R, accessed using st_driver()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nread_sf() arguments and their purposes: —\n\nFile input:\n\ndsn parameter specifies file paths, folders, database credentials, or GeoJSON strings.\nDrivers are auto-detected from file extensions like .gpkg or .shp.\n\nMultiple layers: Some formats (e.g., .gpkg) support multiple data layers. Use the layer argument in read_sf() to specify the desired layer.\nSubset data reading:\n\nquery: Use OGR SQL queries for conditional imports (e.g., filter rows by column values).\nwkt_filter: Filter geometries using Well-Known Text (WKT) spatial queries (e.g., buffers around a region).\n\n\nDriver-specific options:\n\nFormats like .csv require specifying coordinate column names via the options parameter. Refer to GDAL driver documentation for details.\n\nCoordinate Reference Systems (CRS): If missing, assign CRS using sf::st_set_crs().\nOther formats: .kml: Use sf::st_layers() to list layers in KML files before reading specific layers.\nAlternative tools: duckdb, an R interface with spatial extension, offers additional options for data import and querying.\n\n\n\n\n\n\n\nNote\n\n\n\nIntegrating DuckDB’s spatial extension with R and the {sf} package\n\nInstall and Load DuckDB’s Spatial Extension: This setup enables geospatial data processing capabilities within DuckDB.\nlibrary(DBI)\ncon &lt;- dbConnect(duckdb::duckdb())\ndbExecute(con, \"INSTALL spatial;\")\ndbExecute(con, \"LOAD spatial;\")\nImport Geospatial Data into DuckDB: This command reads the specified shapefile and creates a table named spatial_data containing the geospatial information.\nCREATE TABLE spatial_data AS\nSELECT * FROM ST_Read('path/to/your/file.shp');\nPerform Spatial Queries in DuckDB: With the spatial extension, you can execute spatial functions such as ST_Intersects, ST_Within, and ST_Contains directly within DuckDB.\nSELECT *\nFROM spatial_data\nWHERE ST_Within(geometry_column, ST_GeomFromText('POLYGON((...))'));\nExport Data to R for Use with {sf}: After processing, you can export the geospatial data back to R and convert it into an {sf} object for further analysis or visualization.\nspatial_df &lt;- dbGetQuery(con, \"SELECT * FROM spatial_data;\")\nlibrary(sf)\nsf_object &lt;- st_as_sf(spatial_df, wkt = \"geometry_column\")\n\n\n\n\n\n8.3.2 Raster data\n\nRaster File Formats:\n\nRaster data supports single-layer and multi-layer files.\nUse the rast() function from the terra package to load raster files.\nReading Online Raster Data: Use the /vsicurl/ prefix to read raster files from web resources (e.g., HTTP, FTP).\n\n\n\n\n\n\n\n\nNote\n\n\n\nCloud Optimized GeoTIFF (COG) and GeoTIFF Files\n\nGeoTIFF:\n\nGeoTIFF is a public domain metadata standard that allows geo-referencing information to be embedded within a TIFF file.\nStores raster data with spatial reference, essential for GIS and remote sensing applications.\nIncludes metadata like coordinate system, map projections, and georeferencing tags.\n\nCloud Optimized GeoTIFF (COG):\n\nA specialized format of GeoTIFF designed for efficient access and processing over the web.\nCOG files can be accessed using URLs with the /vsicurl/ prefix in GDAL-supported libraries. Functions like terra::crop() or terra::extract() fetch required data portions on demand, without downloading the full dataset.\nThus, /vsicurl/ prefix establishes a connection to the COG file without loading it into RAM. Values are accessed only during specific operations, e.g., crop() or extract().\n\nAdvantages of COG:\n\nStreaming Access: Reads only the necessary portions of data (e.g., specific coordinates), minimizing memory usage.\nCompatibility: Readable by tools like GDAL, Rasterio, and R packages like terra and stars.\n\n\n\n\n\nVirtual File Systems (VFS): GDAL provides several Virtual File System (VFS) prefixes (shown in Table 3) that allow direct access to various file systems, including compressed archives, network resources, and in-memory files. These prefixes can be utilized in R using functions like sf::read_sf() for vector data and terra::rast() for raster data. Source GDAL Virtual File Systems.\n\n\n\nCode\n# Create the tibble\nfile_access_table &lt;- tibble(\n  Prefix = c(\n    \"/vsicurl/\",\n    \"/vsizip/\",\n    \"/vsi7z/\",\n    \"/vsis3/\",\n    \"/vsigs/\",\n    \"/vsicurl_streaming/\"\n  ),\n  Description = c(\n    \"Enables GDAL to access files over [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP), [HTTPS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview), or [FTP](https://en.wikipedia.org/wiki/File_Transfer_Protocol) protocols, allowing direct reading of remote datasets such as [GeoTIFFs](https://gdal.org/drivers/raster/gtiff.html) or [Shapefiles](https://gdal.org/drivers/vector/shapefile.html) hosted online.\",\n    \"Allows reading files directly from [ZIP archives](https://en.wikipedia.org/wiki/Zip_(file_format)) without extraction. ZIP files can contain various geospatial data formats like [Shapefiles](https://gdal.org/drivers/vector/shapefile.html), [GeoJSON](https://gdal.org/drivers/vector/geojson.html), or [KML files](https://gdal.org/drivers/vector/kml.html).\",\n    \"Supports reading files directly from [7z archives](https://en.wikipedia.org/wiki/7z), a high-compression format. These archives can include geospatial files such as [GeoTIFFs](https://gdal.org/drivers/raster/gtiff.html) or [Shapefiles](https://gdal.org/drivers/vector/shapefile.html).\",\n    \"Facilitates access to files stored in [Amazon S3](https://aws.amazon.com/s3/) buckets, enabling operations on remote datasets like [GeoTIFFs](https://gdal.org/drivers/raster/gtiff.html) or [Shapefiles](https://gdal.org/drivers/vector/shapefile.html) stored in the cloud.\",\n    \"Provides access to files stored in [Google Cloud Storage](https://cloud.google.com/storage/), allowing GDAL to read datasets such as [GeoTIFFs](https://gdal.org/drivers/raster/gtiff.html) or [Shapefiles](https://gdal.org/drivers/vector/shapefile.html) directly from cloud storage.\",\n    \"Enables streaming of files over [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP), [HTTPS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview), or [FTP](https://en.wikipedia.org/wiki/File_Transfer_Protocol) without seeking capabilities, suitable for sequential reading of large remote datasets like [GeoJSON](https://gdal.org/drivers/vector/geojson.html) files.\"\n  )\n)\n\n# Display the tibble using gt\nfile_access_table |&gt; \n  gt() |&gt; \n  fmt_markdown(columns = Description) |&gt; \n  tab_header(\n    title = \"Virtual File(s) Access Methods with GDAL\",\n    subtitle = md(\"Prefixes, Descriptions, and Example Usage for `sf::read_sf()` & `terra::rast()`\")\n  ) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  tab_footnote(\n    footnote = md(\"GDAL virtual file system prefixes, their descriptions, and example usage with `read_sf()` and `rast()` functions in R for accessing remote and compressed files. For more details, refer to the [GDAL Virtual File Systems documentation](https://gdal.org/user/virtual_file_systems.html) and the [terra package reference](https://rspatial.org/terra/).\")\n  ) |&gt; \n  tab_style(\n    style = cell_text(\n      size = \"smaller\"\n    ),\n    locations = cells_footnotes()\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(\n        font = \"monospace\",\n        weight = \"bold\"\n      )\n    ),\n    locations = cells_body(\n      columns = c(Prefix)\n    )\n  )\n\n\n\n\nTable 3: Table showcasing various GDAL virtual file system prefixes for accessing remote and compressed files\n\n\n\n\n\n\n\n\n\n\n\n\n\nVirtual File(s) Access Methods with GDAL\n\n\nPrefixes, Descriptions, and Example Usage for sf::read_sf() & terra::rast()\n\n\nPrefix\nDescription\n\n\n\n\n/vsicurl/\nEnables GDAL to access files over HTTP, HTTPS, or FTP protocols, allowing direct reading of remote datasets such as GeoTIFFs or Shapefiles hosted online.\n\n\n/vsizip/\nAllows reading files directly from ZIP archives without extraction. ZIP files can contain various geospatial data formats like Shapefiles, GeoJSON, or KML files.\n\n\n/vsi7z/\nSupports reading files directly from 7z archives, a high-compression format. These archives can include geospatial files such as GeoTIFFs or Shapefiles.\n\n\n/vsis3/\nFacilitates access to files stored in Amazon S3 buckets, enabling operations on remote datasets like GeoTIFFs or Shapefiles stored in the cloud.\n\n\n/vsigs/\nProvides access to files stored in Google Cloud Storage, allowing GDAL to read datasets such as GeoTIFFs or Shapefiles directly from cloud storage.\n\n\n/vsicurl_streaming/\nEnables streaming of files over HTTP, HTTPS, or FTP without seeking capabilities, suitable for sequential reading of large remote datasets like GeoJSON files.\n\n\n\nGDAL virtual file system prefixes, their descriptions, and example usage with read_sf() and rast() functions in R for accessing remote and compressed files. For more details, refer to the GDAL Virtual File Systems documentation and the terra package reference."
  },
  {
    "objectID": "book_solutions/chapter8.html#data-output-o",
    "href": "book_solutions/chapter8.html#data-output-o",
    "title": "Chapter 8: Geographic data I/O",
    "section": "8.4 Data Output (O)",
    "text": "8.4 Data Output (O)\n\n8.4.1 Vector Data\n\nWriting vector data: The counterpart of read_sf() is write_sf(). It writes sf objects to various geographic vector file formats, shown in Table 4\n\nAutomatic driver selection: write_sf() automatically determines the file driver based on the file name.\nOverwriting files: By default, write_sf() overwrites files if the same file name is used.\n\n\n\n\nCode\nlibrary(tibble)\nlibrary(gt)\n\nfile_types &lt;- tibble(\n  `File Type` = c(\"ESRI Shapefile\", \"GeoJSON\", \"GPKG (GeoPackage)\", \"KML\", \"CSV with WKT geometry\"),\n  Extension = c(\".shp\", \".geojson\", \".gpkg\", \".kml\", \".csv\"),\n  `Use Cases` = c(\n    \"Widely used for vector data storage and exchange\",\n    \"Web applications and data sharing\",\n    \"Efficient storage and transfer of spatial data\",\n    \"Sharing geographic data with Google Earth and similar applications\",\n    \"Simple data exchange and interoperability\"\n  ),\n  Advantages = c(\n    \"Broad compatibility with many GIS applications\",\n    \"Human-readable; easy integration with web mapping libraries\",\n    \"Single-file SQLite-based format; supports both vector and raster data\",\n    \"Suitable for visualization in Google Earth\",\n    \"Easy to create and read; compatible with non-GIS software\"\n  ),\n  Disadvantages = c(\n    \"Limited attribute name lengths; consists of multiple files\",\n    \"Larger file sizes; slower read/write performance\",\n    \"Less widespread adoption compared to Shapefile\",\n    \"Limited attribute support; not ideal for large datasets\",\n    \"Lacks spatial indexing; larger file sizes; limited to simple geometries\"\n  )\n)\nfile_types |&gt; \n  gt() |&gt; \n  tab_header(\n    title = md(\"Comparison of File Formats Supported by `sf::st_write()`\")\n  ) |&gt; \n  tab_footnote(\n    footnote = md(\"*Sources: R Spatial Documentation ([r-spatial.github.io](https://r-spatial.github.io/sf/reference/st_write.html)) and GDAL Vector Drivers Documentation ([gdal.org](https://gdal.org/drivers/vector/index.html)).*\")\n  ) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_body(\n      columns = `File Type`\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(font = \"monospace\")\n    ),\n    locations = cells_body(\n      columns = Extension\n    )\n  )\n\n\n\n\nTable 4: The key file formats compatible with the st_write() function in the sf package, including their use cases, advantages, and disadvantages.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparison of File Formats Supported by sf::st_write()\n\n\nFile Type\nExtension\nUse Cases\nAdvantages\nDisadvantages\n\n\n\n\nESRI Shapefile\n.shp\nWidely used for vector data storage and exchange\nBroad compatibility with many GIS applications\nLimited attribute name lengths; consists of multiple files\n\n\nGeoJSON\n.geojson\nWeb applications and data sharing\nHuman-readable; easy integration with web mapping libraries\nLarger file sizes; slower read/write performance\n\n\nGPKG (GeoPackage)\n.gpkg\nEfficient storage and transfer of spatial data\nSingle-file SQLite-based format; supports both vector and raster data\nLess widespread adoption compared to Shapefile\n\n\nKML\n.kml\nSharing geographic data with Google Earth and similar applications\nSuitable for visualization in Google Earth\nLimited attribute support; not ideal for large datasets\n\n\nCSV with WKT geometry\n.csv\nSimple data exchange and interoperability\nEasy to create and read; compatible with non-GIS software\nLacks spatial indexing; larger file sizes; limited to simple geometries\n\n\n\nSources: R Spatial Documentation (r-spatial.github.io) and GDAL Vector Drivers Documentation (gdal.org).\n\n\n\n\n\n\n\n\n\n\n\n\nAdding layers: Use the layer argument to add new layers to formats like GeoPackage instead of overwriting existing files.\n\nExample: layer = \"second_layer\" for additional layers in a .gpkg file.\nWriting spatial data as text: Use the layer_options argument to write spatial data to text files:\n\nGEOMETRY=AS_XY: Creates two columns for coordinates (useful for point datasets).\nGEOMETRY=AS_WKT: Creates a column with well-known text (WKT) representations for complex spatial data.\n\n\nAlternative function: st_write() is equivalent to write_sf(). Key differences:\n\nDoes not overwrite files (throws an error instead).\nProvides a summary of the written file format and object.\n\n\n\n\n8.4.2 Raster Data\n\nSaving Raster Data:\n\nUse writeRaster() from the terra package to save SpatRaster objects. It supports custom file formats, shown in Table 5, data types, and GDAL options.\n\n\n\n\nCode\nlibrary(tibble)\nlibrary(gt)\n\nraster_formats &lt;- tibble::tibble(\n  `File Type` = c(\"GeoTIFF\", \"COG (Cloud Optimized GeoTIFF)\", \"NetCDF\", \"ESRI ASCII\", \"ENVI\"),\n  `Extension` = c(\".tif\", \".tif\", \".nc\", \".asc\", \".envi\"),\n  `Use Cases` = c(\n    \"Widely used for geospatial data storage and exchange\",\n    \"Efficient for web-based applications and cloud storage\",\n    \"Ideal for climate and atmospheric data; supports multidimensional data\",\n    \"Simple text format; useful for data exchange and readability\",\n    \"Commonly used in remote sensing applications\"\n  ),\n  `Advantages` = c(\n    \"Supports multiple bands; allows compression; retains georeferencing info\",\n    \"Optimized for cloud storage; supports streaming and efficient access\",\n    \"Handles large datasets efficiently; self-describing format\",\n    \"Human-readable; easy to edit and share\",\n    \"Supports multiple bands; retains metadata\"\n  ),\n  `Disadvantages` = c(\n    \"Larger file sizes if not compressed\",\n    \"Requires specific software to fully leverage streaming benefits\",\n    \"Complexity in structure; may require specific software to read\",\n    \"Larger file sizes; slower read/write operations\",\n    \"Requires accompanying header file; less widely supported\"\n  )\n)\n\nraster_formats |&gt; \n  gt() |&gt; \n  tab_header(\n    title = md(\"Comparison of Raster File Formats Supported by `terra::writeRaster()`\")\n  ) |&gt; \n  tab_footnote(\n    footnote = md(\"Sourced from the [terra package documentation](https://rdrr.io/cran/terra/man/writeRaster.html) and other geospatial data resources.\")\n  ) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_body(\n      columns = `File Type`\n    )\n  ) |&gt; \n  tab_style(\n    style = list(\n      cell_text(font = \"monospace\")\n    ),\n    locations = cells_body(\n      columns = Extension\n    )\n  )\n\n\n\n\nTable 5: This table summarizes key details about various raster file formats supported by the terra::writeRaster() function in R\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparison of Raster File Formats Supported by terra::writeRaster()\n\n\nFile Type\nExtension\nUse Cases\nAdvantages\nDisadvantages\n\n\n\n\nGeoTIFF\n.tif\nWidely used for geospatial data storage and exchange\nSupports multiple bands; allows compression; retains georeferencing info\nLarger file sizes if not compressed\n\n\nCOG (Cloud Optimized GeoTIFF)\n.tif\nEfficient for web-based applications and cloud storage\nOptimized for cloud storage; supports streaming and efficient access\nRequires specific software to fully leverage streaming benefits\n\n\nNetCDF\n.nc\nIdeal for climate and atmospheric data; supports multidimensional data\nHandles large datasets efficiently; self-describing format\nComplexity in structure; may require specific software to read\n\n\nESRI ASCII\n.asc\nSimple text format; useful for data exchange and readability\nHuman-readable; easy to edit and share\nLarger file sizes; slower read/write operations\n\n\nENVI\n.envi\nCommonly used in remote sensing applications\nSupports multiple bands; retains metadata\nRequires accompanying header file; less widely supported\n\n\n\nSourced from the terra package documentation and other geospatial data resources.\n\n\n\n\n\n\n\n\n\n\n\n\nSupported Data Types:\n\nSeven types: INT1U, INT2S, INT2U, INT4S, INT4U, FLT4S, FLT8S.\nUse unsigned integers (INT1U, INT2U, INT4U) for categorical data.\nUse floats (FLT4S, FLT8S) for continuous data.\nDefault: FLT4S, but consider smaller types for efficiency based on data range.\n\n\n\n\n\n\n\n\nNote\n\n\n\nOptimizing GeoTIFFs for Efficient Map Serving\nIn his article “GeoTIFF Compression for Dummies,” Paul Ramsey discusses effective strategies for preparing GeoTIFF images for map serving. He recommends using JPEG compression, internal tiling, the YCBCR color space, and internal overviews to significantly reduce file sizes without noticeable loss in visual quality. These techniques enhance performance in open-source rendering engines like MapServer, GeoServer, and Mapnik. Additionally, Ramsey highlights the advantages of Cloud Optimized GeoTIFFs (COGs) for efficient access in cloud storage environments. Some key advantages of Cloud Optimized GeoTIFFs (COGs) over traditional GeoTIFF files:\n\nDirect Access to Data: COGs allow efficient partial reads, enabling users to access specific portions of the file (e.g., particular regions or zoom levels) without downloading the entire file.\nOptimized for Cloud Storage: They are structured to work seamlessly with cloud storage systems, enabling faster access and reducing storage and retrieval costs.\nInternal Overviews and Tiling: COGs come with built-in overviews (lower-resolution versions of the dataset) and tiling, improving performance for applications requiring multi-resolution access, such as web mapping.\nCompatibility with Web-Based Tools: Many open-source tools and cloud platforms, such as AWS S3 and Google Earth Engine, directly support COGs, facilitating their integration into cloud-based workflows.\nImproved Performance for Large Datasets: By accessing only the needed data chunks, COGs reduce network bandwidth requirements and improve responsiveness for large raster datasets.\nInteroperability: COGs are compatible with standard GeoTIFF readers while offering enhanced functionality when used with tools that understand their optimized format."
  },
  {
    "objectID": "book_solutions/chapter8.html#geoportals",
    "href": "book_solutions/chapter8.html#geoportals",
    "title": "Chapter 8: Geographic data I/O",
    "section": "8.5 Geoportals",
    "text": "8.5 Geoportals\n\nInteractive exploration of datasets in a browser is an effective way to understand available layers.\nDownloading data with code is preferable for reproducibility and efficiency. Command-line techniques can initiate downloads using URLs or APIs.\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(gt)\n\ngeoportals &lt;- tibble(\n  `Portal Name` = c(\n    \"[Data.gov](https://catalog.data.gov/dataset?metadata_type=geospatial)\",\n    \"[GEOSS Portal](https://www.geoportal.org/)\",\n    \"[Copernicus Data Space Ecosystem](https://dataspace.copernicus.eu/)\",\n    \"[SEDAC](https://sedac.ciesin.columbia.edu/)\",\n    \"[INSPIRE Geoportal](http://inspire-geoportal.ec.europa.eu/)\",\n    \"[EarthExplorer](https://earthexplorer.usgs.gov/)\"\n  ),\n  `Description` = c(\n    \"Offers a vast array of geospatial datasets, including environmental data, climate records, and transportation networks.\",\n    \"Provides access to global Earth observation data, including satellite imagery and in-situ measurements across agriculture, biodiversity, and climate.\",\n    \"Delivers free access to Copernicus Sentinel satellite data, including high-resolution optical and radar imagery for environmental monitoring.\",\n    \"Focuses on integrating socioeconomic and environmental data, offering population distribution, urban extents, and climate impact indicators.\",\n    \"Facilitates access to European spatial data, including administrative boundaries, hydrography, and transportation networks adhering to INSPIRE standards.\",\n    \"Provides access to remote sensing data like Landsat imagery and digital elevation models managed by the U.S. Geological Survey.\"\n  ),\n  Type = c(\n    \"Raster & Vector\",\n    \"Raster & Vector\",\n    \"Raster\",\n    \"Vector\",\n    \"Raster & Vector\",\n    \"Raster\"\n  )\n)\n\n# Print the tibble\ngeoportals |&gt; \n  gt() |&gt; \n  fmt_markdown(columns = `Portal Name`) |&gt; \n  cols_label_with(fn = snakecase::to_title_case) |&gt; \n  tab_header(\n    title = \"Geospatial Data Portals for Raster and Vector Datasets\"\n  ) |&gt; \n  tab_footnote(\n    footnote = md(\"Data sources: Adapted from the textbook `Geocomputation with R`, *Section 8.5 Geoportals*.\")\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 6: Some Common Geoportals available freely on the internet.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeospatial Data Portals for Raster and Vector Datasets\n\n\nPortal Name\nDescription\nType\n\n\n\n\nData.gov\nOffers a vast array of geospatial datasets, including environmental data, climate records, and transportation networks.\nRaster & Vector\n\n\nGEOSS Portal\nProvides access to global Earth observation data, including satellite imagery and in-situ measurements across agriculture, biodiversity, and climate.\nRaster & Vector\n\n\nCopernicus Data Space Ecosystem\nDelivers free access to Copernicus Sentinel satellite data, including high-resolution optical and radar imagery for environmental monitoring.\nRaster\n\n\nSEDAC\nFocuses on integrating socioeconomic and environmental data, offering population distribution, urban extents, and climate impact indicators.\nVector\n\n\nINSPIRE Geoportal\nFacilitates access to European spatial data, including administrative boundaries, hydrography, and transportation networks adhering to INSPIRE standards.\nRaster & Vector\n\n\nEarthExplorer\nProvides access to remote sensing data like Landsat imagery and digital elevation models managed by the U.S. Geological Survey.\nRaster\n\n\n\nData sources: Adapted from the textbook Geocomputation with R, Section 8.5 Geoportals."
  },
  {
    "objectID": "book_solutions/chapter8.html#geographic-data-packages",
    "href": "book_solutions/chapter8.html#geographic-data-packages",
    "title": "Chapter 8: Geographic data I/O",
    "section": "8.6 Geographic data packages",
    "text": "8.6 Geographic data packages\n\n\nCode\nlibrary(tidyverse)\nlibrary(gt)\n\ngeographic_data_packages &lt;- tibble(\n  Package = c(\n    \"[climateR](https://cran.r-project.org/package=climateR)\",\n    \"[elevatr](https://cran.r-project.org/package=elevatr)\",\n    \"[FedData](https://cran.r-project.org/package=FedData)\",\n    \"[geodata](https://cran.r-project.org/package=geodata)\",\n    \"[osmdata](https://cran.r-project.org/package=osmdata)\",\n    \"[osmextract](https://cran.r-project.org/package=osmextract)\",\n    \"[rnaturalearth](https://cran.r-project.org/package=rnaturalearth)\",\n    \"[rnoaa](https://cran.r-project.org/package=rnoaa)\",\n    \"[giscoR](https://cran.r-project.org/package=giscoR)\"\n  ),\n  Description = c(\n    \"Provides access to over 100,000 gridded climate and landscape datasets from more than 2,000 data providers, allowing users to retrieve data by specifying an area of interest.\",\n    \"Facilitates access to point and raster elevation data from various sources, enabling users to obtain elevation information for specific locations or regions.\",\n    \"Allows users to download datasets maintained by the U.S. federal government, including elevation, land cover, and other geospatial data.\",\n    \"Simplifies the download and import of administrative boundaries, elevation models, WorldClim climate data, and more for various regions worldwide.\",\n    \"Enables downloading and importing of small to medium-sized datasets from OpenStreetMap, suitable for detailed geographic analyses.\",\n    \"Designed for downloading and importing large OpenStreetMap datasets, making it suitable for extensive geographic analyses.\",\n    \"Provides access to Natural Earth vector and raster data, including country boundaries, rivers, and urban areas, useful for creating maps and visualizations.\",\n    \"Interfaces with the National Oceanic and Atmospheric Administration (NOAA) to import climate and weather data, including forecasts, historical data, and severe weather alerts.\",\n    \"Allows users to download and use geospatial data from GISCO (Geographical Information System of the European Commission), including administrative boundaries and other geographic features.\"\n  ),\n  Important_Functions = c(\n    \"`getDataAOI()` – Retrieve data for a specified area of interest.\",\n    \"`get_elev_point()` – Get elevation data for specific points.\",\n    \"`get_ned()` – Download National Elevation Dataset data.\",\n    \"`worldclim_global()` – Access global climate data.\",\n    \"`opq()` – Build an Overpass query; `add_osm_feature()` – Specify features to retrieve.\",\n    \"`oe_read()` – Read OpenStreetMap data for a specified region.\",\n    \"`ne_countries()` – Retrieve country boundaries; `ne_download()` – Download Natural Earth data.\",\n    \"`meteo_pull_monitors()` – Retrieve meteorological data from specified monitors.\",\n    \"`gisco_get_countries()` – Retrieve country boundaries; `gisco_get_nuts()` – Access NUTS regions.\"\n  )\n)\n\ngeographic_data_packages |&gt; \n  gt() |&gt; \n  fmt_markdown(columns = c(Package, \n                           Important_Functions)) |&gt; \n  cols_label_with(fn = snakecase::to_title_case) |&gt; \n  tab_header(\n    title = \"R Packages for Geographic Data\"\n  ) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  tab_style(\n    style = list(\n      cell_text(font = \"monospace\")\n    ),\n    locations = cells_body(\n      columns = Package\n    )\n  )\n\n\n\n\nTable 7: Selected R Packages for Geographic Data Retrieval and Analysis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR Packages for Geographic Data\n\n\nPackage\nDescription\nImportant Functions\n\n\n\n\nclimateR\nProvides access to over 100,000 gridded climate and landscape datasets from more than 2,000 data providers, allowing users to retrieve data by specifying an area of interest.\ngetDataAOI() – Retrieve data for a specified area of interest.\n\n\nelevatr\nFacilitates access to point and raster elevation data from various sources, enabling users to obtain elevation information for specific locations or regions.\nget_elev_point() – Get elevation data for specific points.\n\n\nFedData\nAllows users to download datasets maintained by the U.S. federal government, including elevation, land cover, and other geospatial data.\nget_ned() – Download National Elevation Dataset data.\n\n\ngeodata\nSimplifies the download and import of administrative boundaries, elevation models, WorldClim climate data, and more for various regions worldwide.\nworldclim_global() – Access global climate data.\n\n\nosmdata\nEnables downloading and importing of small to medium-sized datasets from OpenStreetMap, suitable for detailed geographic analyses.\nopq() – Build an Overpass query; add_osm_feature() – Specify features to retrieve.\n\n\nosmextract\nDesigned for downloading and importing large OpenStreetMap datasets, making it suitable for extensive geographic analyses.\noe_read() – Read OpenStreetMap data for a specified region.\n\n\nrnaturalearth\nProvides access to Natural Earth vector and raster data, including country boundaries, rivers, and urban areas, useful for creating maps and visualizations.\nne_countries() – Retrieve country boundaries; ne_download() – Download Natural Earth data.\n\n\nrnoaa\nInterfaces with the National Oceanic and Atmospheric Administration (NOAA) to import climate and weather data, including forecasts, historical data, and severe weather alerts.\nmeteo_pull_monitors() – Retrieve meteorological data from specified monitors.\n\n\ngiscoR\nAllows users to download and use geospatial data from GISCO (Geographical Information System of the European Commission), including administrative boundaries and other geographic features.\ngisco_get_countries() – Retrieve country boundaries; gisco_get_nuts() – Access NUTS regions."
  },
  {
    "objectID": "geocomputation/ggpattern_with_sf.html",
    "href": "geocomputation/ggpattern_with_sf.html",
    "title": "Mapping India’s Cuisines with R: {sf}, {ggpattern}, {magick} and more",
    "section": "",
    "text": "Discover the rich culinary diversity of India with this map, showcasing each state and union territory filled with its most iconic cuisine, accompanied by state names for easy reference. A harmonious blend of geography and gastronomy, crafted with R.\n\n\nStep 1: Get India’s Map Data, and make a base tibble\n\n\nCode\n# Data Import and Wrangling Tools\nlibrary(tidyverse)            # All things tidy\nlibrary(sf)                   # Handling simple features in R\nlibrary(here)                 # Folder management\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\nlibrary(ggpattern)            # Patterns / Images in geoms\nlibrary(magick)               # Handling images\nlibrary(httr)                 # Downloading images from Google\n\n\nindia_map &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\", \"India_State_Boundary.shp\"\n  )\n) |&gt; \n  janitor::clean_names() |&gt; \n  st_simplify(dTolerance = 1000) |&gt; \n  st_transform(\"EPSG:4326\") |&gt; \n  mutate(\n    id = row_number(),\n    area = st_area(geometry)\n  ) |&gt; \n  relocate(id)\n\nindia_map\nindia_map$state_name\n\n\nStep 2: Get images of states’ cuisines from Google’s Programme Search Engine through an API\n\n\nCode\n# Get a custom google search engine and API key\n# Tutorial: https://developers.google.com/custom-search/v1/overview\n# Tutorial 2: https://programmablesearchengine.google.com/\n\n# From:https://developers.google.com/custom-search/v1/overview\n# google_api_key &lt;- \"LOAD YOUR GOOGLE API KEY HERE\"\n\n# From: https://programmablesearchengine.google.com/controlpanel/all\n# my_cx &lt;- \"GET YOUR CUSTOM SEARCH ENGINE ID HERE\"\n\n# Define function to download and save movie poster\ndownload_food_images &lt;- function(i) {\n  \n  api_key &lt;- google_api_key\n  cx &lt;- my_cx\n  \n  # Build the API request URL\n  url &lt;- paste0(\n    \"https://www.googleapis.com/customsearch/v1?q=\", \n    URLencode(\n      paste0(\n        india_map$state_name[i], \n        \" state cuisine photo HD\"\n      )), \n      \"&cx=\", cx, \"&searchType=image&key=\", api_key,\n      \"&imgSize=large\",       # Prioritize larger images\n      \"&imgType=photo\"\n    )\n  \n  # Make the request\n  response &lt;- GET(url)\n  result &lt;- content(response, \"parsed\")\n  \n  # Get the URL of the first image result\n  image_url &lt;- result$items[[1]]$link\n  \n  im &lt;- magick::image_read(image_url) |&gt; \n    image_resize(\"x1000\")\n  \n  # set background as white\n  image_write(\n    image = im,\n    path = here::here(\"geocomputation\", \"images\",\n                      paste0(\"temp_food_india_\", i,\".png\")),\n    format = \"png\"\n    )\n}\n\nfor (i in 18:nrow(india_map)) {\n  download_food_images(i)\n}\n\n\n\n# Custom run the function for id 1, 2, 10, 20\ncustom_ids &lt;- c(1, 2, 10, 20)\n\n\nStep 2.1: The same Code improved with ChatGPT\n\n\nCode\n# Add a new column to store food names in the tibble\nindia_map &lt;- india_map |&gt; mutate(food_name = NA_character_)\n\n# Function to extract food item name from the search query result\nextract_food_name &lt;- function(items) {\n  if (length(items) &gt; 0) {\n    # Attempt to extract meaningful food names from the title or snippet\n    food_name &lt;- items[[1]]$title\n    return(food_name)\n  } else {\n    return(NA) # Return NA if no items are found\n  }\n}\n\n# Improved function to download and save food images\ndownload_food_images &lt;- function(i) {\n  \n  api_key &lt;- google_api_key\n  cx &lt;- my_cx\n  \n  # Build the API request URL with additional filters\n  url &lt;- paste0(\n    \"https://www.googleapis.com/customsearch/v1?q=\",\n    URLencode(paste0(india_map$state_name[i], \n                     \" traditional cuisine food photo\")),\n    \"&cx=\", cx,\n    \"&searchType=image\",\n    \"&key=\", api_key,\n    \"&imgSize=large\",       # Restrict to medium-sized images\n    \"&imgType=photo\",\n    \"&num=1\"                 # Fetch only one result\n  )\n  \n  # Make the request\n  response &lt;- GET(url)\n  if (response$status_code != 200) {\n    warning(\"Failed to fetch data for state: \", india_map$state_name[i])\n    return(NULL)\n  }\n  \n  # Parse the response\n  result &lt;- content(response, \"parsed\")\n  \n  # Extract the image URL\n  if (!is.null(result$items)) {\n    image_url &lt;- result$items[[1]]$link\n    food_name &lt;- extract_food_name(result$items)\n  } else {\n    warning(\"No results found for state: \", india_map$state_name[i])\n    return(NULL)\n  }\n  \n  # Validate and process the image\n  tryCatch({\n    im &lt;- magick::image_read(image_url) |&gt; \n      image_resize(\"x1000\") # Resize image\n    # Save the image\n    image_write(\n      image = im,\n      path = here(\"geocomputation\", \"images\", \n                  paste0(\"temp_food_india_\", i, \".png\")),\n      format = \"png\"\n    )\n    \n    # Add the food name to the tibble\n    india_map$food_name[i] &lt;- food_name\n    \n  }, error = function(e) {\n    warning(\"Failed to process image for state: \", india_map$state_name[i])\n  })\n}\n\n# Iterate through each state and download images\nfor (i in 1:nrow(india_map)) {\n  download_food_images(i)\n}\n\n\nStep 3: Set up Visualization Parameters\n\n\nCode\n# Font for titles\nfont_add_google(\"Rye\",\n  family = \"title_font\"\n) \n\n# Font for the caption\nfont_add_google(\"Voltaire\",\n  family = \"caption_font\"\n) \n\nfont_add_google(\"Saira Extra Condensed\",\n  family = \"caption_font2\"\n) \nshowtext_auto()\n\n# A base Colour\nbg_col &lt;- \"grey10\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey90\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"white\"\nseecolor::print_color(text_col)\n\n\n# Define Base Text Size\nbts &lt;- 90 \n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data:** Google & Census of India\", \n  \" |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n# Add text to plot-------------------------------------------------\nplot_title &lt;- \"Flavors of India:\\nA Culinary Map\"\n\n\nStep 4: Use ggpattern to make final map Customizing options here.\n\n\nCode\ng &lt;- ggplot(data = india_map) +\n  ggpattern::geom_sf_pattern(\n    mapping = aes(\n      pattern_filename = I(\n        paste0(\n          \"geocomputation/images/temp_food_india_\",\n          id, \".png\"\n          )\n        )\n    ),\n    pattern = \"image\",\n    pattern_type = \"expand\",\n    linewidth = 1.2,\n    colour = bg_col\n  ) +\n  # A place filler code to try iterations while arriving\n  # at the final plot\n  # geom_sf(\n  #   colour = bg_col,\n  #   linewidth = 0.5,\n  #   fill = \"grey60\"\n  # ) +\n  ggrepel::geom_label_repel(\n    mapping = aes(\n      label = state_name,\n      geometry = geometry\n    ),\n    stat = \"sf_coordinates\",\n    family = \"caption_font\",\n    colour = text_col,\n    fill = alpha(bg_col, 0.5),\n    size = bts / 5,\n    label.size = unit(0, \"mm\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = plot_title,\n    caption = plot_caption\n  ) +\n  ggthemes::theme_map(\n    base_size = bts,\n    base_family = \"title_font\"\n  ) +\n  theme(\n    # Overall plot\n    plot.margin = margin(0,-15,0,-15, \"mm\"),\n    \n    # Labels\n    plot.title = element_text(\n      colour = text_hil,\n      margin = margin(0,25,-50,0, \"mm\"),\n      size = bts * 2.5,\n      lineheight = 0.3,\n      hjust = 1\n    ),\n    plot.caption = element_textbox(\n      family = \"caption_font2\",\n      margin = margin(-40,0,0,20, \"mm\"),\n      hjust = 0,\n      size = 0.8 * bts,\n      colour = text_hil\n    ),\n    plot.background = element_rect(\n      fill = \"transparent\",\n      colour = \"transparent\"\n    )\n    \n  )\n\nggsave(\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"ggpattern_with_sf_india_cuisines.png\"\n  ),\n  plot = g,\n  width = 400,\n  height = 500,\n  units = \"mm\",\n  bg = bg_col\n)\n\n\nStep 5: Save thumbnail and clean up temporary files\n\n\nCode\n# Saving a thumbnail\n\nlibrary(magick)\n# Reducing Image Size - its 15 Mb plus\nimage_read(\n  here::here(\n    \"geocomputation\", \"images\",\n    \"ggpattern_with_sf_india_cuisines.png\"\n    )\n  ) |&gt; \n  image_resize(geometry = \"x400\")\n\n# Clean Up: Do no harm and leave the world an untouched place!\n# Remove temporary image files\nunlink(paste0(\"geocomputation/images/temp_food_india_\", 1:nrow(india_map), \".png\"))"
  },
  {
    "objectID": "geocomputation/geodata_package.html",
    "href": "geocomputation/geodata_package.html",
    "title": "Exploring the package {geodata}",
    "section": "",
    "text": "The {geodata} package (Hijmans et al. 2024) with {sf} (Pebesma and Bivand 2023) and {terra} (Hijmans 2024)\n\n\nCode\n# Data Import and Wrangling Tools\nlibrary(tidyverse)            # All things tidy\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\n\n# Package to explore\nlibrary(geodata)              # Geospatial Data\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**: {geodata} package  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\nThis code visualizes monthly average temperature data for Greenland using geospatial data and ggplot2 in R, leveraging key functions from the {geodata} package. The geodata::gadm() function is used to download Greenland’s administrative boundaries as vector data, which is processed into a simple feature object with sf::st_as_sf(). The geodata::worldclim_country() function retrieves average temperature climate data for Greenland. The climate data is aggregated for lower resolution using terra::aggregate(), cropped to Greenland’s boundaries with terra::crop(), and masked with terra::mask() to match the vector boundary. It is then reprojected to a North Pole Stereographic projection using terra::project(). A faceted ggplot ( Figure 1 ) is created to visualize temperature data across all 12 months, with color gradients representing temperature values, styled with a minimal theme.\n\n\nCode\n# Get Greenland's boundaries\ngreenland_vector &lt;- geodata::gadm(\n  country = \"Greenland\",\n  path = tempdir(),\n  resolution = 2\n) |&gt; \n  st_as_sf()\n\nvec1 &lt;- greenland_vector |&gt; \n  st_union() |&gt; \n  st_as_sf()\n\n# ggplot(greenland_vector) +\n#   geom_sf()\n\n# Get Average Temperature Climate Data for Greenland\ndf1 &lt;- worldclim_country(\n  country = \"Greenland\",\n  var = \"tavg\",\n  path = tempdir()\n)\n\n# Studying the layers: there are 12 - for the 12 months\ndf1\n\ndf1 |&gt; crs() |&gt; str_view()\n\n# Lower resolution for initial plots, and crop by Vector Map\ndf2 &lt;- df1 |&gt; \n  terra::aggregate(fact = 10, fun = mean) |&gt;\n  terra::crop(vec1) |&gt; \n  terra::mask(vec1)\n\n# Project into CRS: North Pole Stereographic\ndf3 &lt;- df2 |&gt; \n  project(\"EPSG:3413\", method = \"bilinear\")\n\nstrip_labels &lt;- month.name\nnames(strip_labels) &lt;- names(df2)\n\ng &lt;- ggplot() +\n  geom_spatraster(\n    data = df3\n  ) +\n  scale_fill_viridis_c(\n    na.value = \"transparent\",\n    labels = function(x) paste0(x, \"°C\"),\n  ) +\n  facet_wrap(\n    ~lyr,\n    labeller = labeller(lyr = strip_labels),\n    ncol = 3,\n    nrow = 4\n  ) +\n  coord_sf(\n    clip = \"off\"\n  ) +\n  labs(\n    title = \"Monthly Average Temperature in Greenland\",\n    fill = \"Average\\ntemperature\",\n    caption = plot_caption\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = bts * 3\n  ) +\n  theme(\n    axis.text = element_text(\n      size = bts, \n      margin = margin(0,0,0,0, \"pt\")\n    ),\n    axis.ticks.length = unit(0, \"pt\"),\n    strip.text = element_text(\n      margin = margin(0,0,0,0, \"pt\")\n    ),\n    panel.grid = element_line(\n      linewidth = 0.1,\n      linetype = 3,\n      colour = \"grey80\"\n    ),\n    legend.position = \"right\",\n    panel.spacing = unit(5, \"pt\"),\n    panel.background = element_rect(\n      fill = \"transparent\",\n      colour = \"transparent\"\n    ),\n    \n    # Legend Corrections\n    legend.title = element_text(\n      margin = margin(0,0,3,0, \"pt\"),\n      lineheight = 0.3,\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(0,0,0,2, \"pt\"),\n      size = 18\n    ),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    legend.key.width = unit(4, \"pt\"),\n    legend.key.height = unit(30, \"pt\"),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    plot.title = element_text(\n      size = bts * 4,\n      hjust = 0.5\n    ),\n    plot.title.position = \"plot\"\n  )\n  \n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \"geodata_package_1.png\"\n  ),\n  height = 1800,\n  width = 2000,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Monthly Average Temperatures Across Greenland: showcasing temperature gradients for each month using a North Pole Stereographic projection.\n\n\n\n\n\n\nThis code demonstrates the simulation of various sea level rise scenarios using elevation data and visualizes the resulting impact on global landmass through raster manipulation and plotting. It leverages the elevation_global() function to obtain global elevation raster data, with a resolution of 10 arc-seconds. The if_else() function is used to simulate sea level rise scenarios by adjusting elevation data based on thresholds (1m, 10m, 50m, 100m, and 200m). The manipulated elevation data is then stored as layers in a raster object created with rast() from the terra package.\nThe raster is reprojected into an aesthetically pleasing projection (ESRI:54030) using project() for better visualization. The final map is plotted with ggplot(), incorporating the geom_spatraster() layer to display raster data and facet_wrap() to present the different scenarios.\n\n\nCode\n# Getting blobale elevation raster data\nge_raw &lt;- elevation_global(\n  res = 10,\n  path = tempdir()\n)\n\n# Simulating Sea Leave Rise by different heights\nelev_tibble &lt;- tibble(\n  base = values(ge_raw),\n  rise_1 = if_else(base &lt; 1, NA, base),\n  rise_10 = if_else(base &lt; 10, NA, base),\n  rise_40 = if_else(base &lt; 50, NA, base),\n  rise_80 = if_else(base &lt; 100, NA, base),\n  rise_100 = if_else(base &lt; 200, NA, base)\n)\n\n# Make a blank raster of World Map size\nge1 &lt;- rast(\n  nrow = dim(ge_raw)[1],\n  ncol = dim(ge_raw)[2],\n  nlyrs = ncol(elev_tibble)\n)\n# Add values from the tibble to different layers of \n# the newly created raster\nvalues(ge1) &lt;- as.matrix(elev_tibble)\n\n# Reproject Raster into a nice projection \nge1 &lt;- ge1 |&gt; \n  project(\"ESRI:54030\")\n\n# Earlier Attempts that did not work\n# ge1 &lt;- ge_raw\n# sea_level_rise = 1       # In metres\n# values(ge1) &lt;- if_else(\n#   values(ge_raw) &lt; sea_level_rise,\n#   NA,\n#   values(ge_raw)\n#   )\n# \n# paste0(\"ge\", sea_level_rise) |&gt; \n#   assign(ge_raw)\n# \n\nstrip_labels &lt;- c(\n  \"Current Sea Level\",\n  paste0(\"Rise by \", \n         c(1, 10, 50, 100, 200), \n         \" metres\")\n)\nnames(strip_labels) &lt;- paste0(\"lyr.\", 1:6)\n  \ng &lt;- ggplot() +\n  geom_spatraster(\n    data = ge1\n  ) +\n  facet_wrap(\n    ~lyr, \n    ncol = 2,\n    labeller = labeller(lyr = strip_labels)\n    ) +\n  scale_fill_wiki_c(\n    na.value = \"lightblue\"\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"World Map: scenarios with rise in Sea Levels\",\n    subtitle = \"Simulating different levels of sea level rise, and effect of landmass using simple raster arithmetic\",\n    caption = plot_caption,\n    fill = \"Elevation above sea level (m)\"\n  ) +\n  theme_minimal(\n    base_size = 2 * bts,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    panel.spacing = unit(2, \"pt\"),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    panel.grid = element_blank(),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(5,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title = element_text(\n      margin = margin(15,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\"\n    ),\n    plot.subtitle = element_text(\n      margin = margin(5,0,0,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 1.5\n    ),\n    strip.text = element_text(\n      margin = margin(2,0,-1,0, \"pt\"),\n      face = \"bold\"\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.box.margin = margin(-10,0,3,0, \"pt\"),\n    legend.margin = margin(-10,0,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5,\n      size = bts\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \"geodata_package_2.png\"\n  ),\n  height = 1150,\n  width = 1000,\n  units = \"px\",\n  bg = \"lightblue\"\n)\n\n\n\n\n\nAn elevation map of the world plotted using geom_spatraster() which shows 6 facets - each with a different scenario of sea level rise with global warming - current levels, 1 m, 10 m, 50 m, 100 m and 200 m - drawn with simple raster arithmetic. The world is projected in Robinson Projection (ESRI:54030) to make is aesthetically pleasing.\n\n\n\n\n\nThis code extends the sea level rise simulation to the European region by refining the raster data and restricting it to the continent’s boundaries. It first retrieves global elevation data using elevation_global(), then defines a bounding box to exclude distant islands and ensure a focused analysis on mainland Europe.\nTo obtain vector data for European countries, ne_countries() from the rnaturalearth package is used, selecting only relevant attributes. Unlike the previous global analysis, this visualization applies the ETRS89 / LAEA Europe projection (EPSG:32633) using project() to maintain spatial accuracy for the European context. The final visualization integrates raster data using geom_spatraster() and overlays country borders (shown in white colour) with geom_sf(), providing a detailed view of how landmass is affected by rising sea levels.\n\n\nCode\n# Getting global elevation raster data\nge_raw &lt;- elevation_global(\n  res = 10,\n  path = tempdir()\n)\n\n# Create a bounding box to remove far off islands in Europe\nbounding_box &lt;- st_bbox(\n  c(xmin = -25, xmax = 45, ymin = 31, ymax = 70),\n  crs = \"EPSG:4326\"\n)\n\n# Get Vector Data on European Countries\neurope &lt;- rnaturalearth::ne_countries(\n  continent = \"Europe\",\n  returnclass = \"sf\",\n  scale = \"medium\"\n) |&gt; \n  select(name, iso_a3, geometry) |&gt; \n  filter(!(name %in% c(\"Russia\"))) |&gt; \n  st_crop(bounding_box)\n\nggplot(europe) +\n  geom_sf()\n\nwhole_europe &lt;- europe |&gt;\n  st_union() |&gt; \n  st_as_sf()\n\n# Check the map\nggplot(whole_europe) +\n  geom_sf()\n\n# Crop the global Elevation raster\nge_europe &lt;- ge_raw |&gt; \n  terra::crop(whole_europe) |&gt; \n  terra::mask(whole_europe)\n\nggplot() +\n  geom_spatraster(data = ge_europe)\n\n# Simulating Sea Leave Rise by different heights\nelev_tibble &lt;- tibble(\n  base = values(ge_europe),\n  rise_1 = if_else(base &lt; 1, NA, base),\n  rise_10 = if_else(base &lt; 10, NA, base),\n  rise_40 = if_else(base &lt; 50, NA, base),\n  rise_80 = if_else(base &lt; 100, NA, base),\n  rise_100 = if_else(base &lt; 200, NA, base)\n)\n\n# Make a blank raster of World Map size\nge1 &lt;- rast(\n  nrow = dim(ge_europe)[1],\n  ncol = dim(ge_europe)[2],\n  nlyrs = ncol(elev_tibble),\n  extent = ext(ge_europe),\n  resolution = res(ge_europe)\n)\n# Add values from the tibble to different layers of \n# the newly created raster\nvalues(ge1) &lt;- as.matrix(elev_tibble)\n\n# Test the ge1\n# ge1\n# ge_europe\n\n# Reproject Raster into ETRS89 / LAEA Europe Projection for Europe \nge_projected &lt;- ge1 |&gt; \n  project(\"EPSG:32633\")\n\n# Earlier Attempts that did not work\n# ge1 &lt;- ge_raw\n# sea_level_rise = 1       # In metres\n# values(ge1) &lt;- if_else(\n#   values(ge_raw) &lt; sea_level_rise,\n#   NA,\n#   values(ge_raw)\n#   )\n# \n# paste0(\"ge\", sea_level_rise) |&gt; \n#   assign(ge_raw)\n# \n\nstrip_labels &lt;- c(\n  \"Current Sea Level\",\n  paste0(\"Rise by \", \n         c(1, 10, 50, 100, 200), \n         \" metres\")\n)\nnames(strip_labels) &lt;- paste0(\"lyr.\", 1:6)\n  \ng &lt;- ggplot() +\n  geom_spatraster(\n    data = ge_projected\n  ) +\n  geom_sf(\n    data = europe,\n    colour = \"white\",\n    fill = \"transparent\",\n    linewidth = 0.1\n  ) +\n  facet_wrap(\n    ~lyr, \n    ncol = 2,\n    labeller = labeller(lyr = strip_labels)\n    ) +\n  scale_fill_wiki_c(\n    na.value = \"lightblue\"\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"Europe Map with rising in Sea Levels\",\n    subtitle = \"Simulating different levels of sea level rise, and effect of landmass using simple raster arithmetic\",\n    caption = plot_caption,\n    fill = \"Elevation above sea level (m)\"\n  ) +\n  theme_minimal(\n    base_size = 2 * bts,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    panel.spacing = unit(2, \"pt\"),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    panel.grid = element_blank(),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(5,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title = element_text(\n      margin = margin(15,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\"\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 1.5\n    ),\n    strip.text = element_text(\n      margin = margin(2,0,-9,0, \"pt\"),\n      face = \"bold\"\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.box.margin = margin(-10,0,3,0, \"pt\"),\n    legend.margin = margin(-10,0,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5,\n      size = bts\n    ),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \"geodata_package_3.png\"\n  ),\n  height = 1150,\n  width = 1000,\n  units = \"px\",\n  bg = \"lightblue\"\n)\n\n\n\n\n\nSimulating Sea Level Rise in Europe: This map visualizes the impact of rising sea levels on European landmass using raster-based elevation data. Different scenarios, ranging from current sea levels to rises of 1m, 10m, 50m, 100m, and 200m, are represented to illustrate potential changes in geography. The analysis is tailored to the European context with an accurate ETRS89 / LAEA projection. The existing borders of nations are shown in white.\n\n\n\n\n\nThis R script uses open-source land cover data from the {geodata} package to analyze and visualize cropland distribution across Haryana’s subdistricts (tehsils). The dataset, derived from the ESA WorldCover dataset at a 0.3-second resolution, represents the fraction of cropland in each cell. The analysis starts by downloading global cropland data using geodata::cropland(). The Haryana subdistrict boundary shapefile is read using {sf} via read_sf(), cleaned with {janitor}, and transformed to EPSG:4326. The cropland raster is cropped and masked to Haryana’s boundaries using {terra} functions crop() and mask(). Raster extraction (terra::extract()) is performed to compute the average cropland percentage per subdistrict. The results are merged into the spatial data (left_join()) and ranked. Visualization is done using {ggplot2}, where an inset bar chart ranks subdistricts by cropland percentage.\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nharyana_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"haryana_map\",\n    \"HARYANA_SUBDISTRICT_BDY.shp\"\n  )\n) |&gt; \n  janitor::clean_names() |&gt; \n  mutate(\n    across(\n      .cols = c(district, tehsil),\n      .fns = function(x){\n        str_replace_all(x, \"\\\\|\", \"I\") |&gt; \n          str_replace_all(\"&gt;\", \"A\") |&gt; \n          str_replace_all(\"@\", \"U\") |&gt; \n          str_to_title()\n      }\n    )\n  ) |&gt; \n  st_transform(\"EPSG:4326\") |&gt; \n  mutate(id = row_number()) |&gt; \n  relocate(id)\n\nharyana_vec_boundary &lt;- st_union(haryana_vec) |&gt; \n  st_as_sf()\n\nharyana_crop &lt;- globalcrop |&gt; \n  terra::crop(haryana_vec) |&gt; \n  terra::mask(haryana_vec)\n\n# Computing percentage area of each subdistrict that is Cropland\ndf1 &lt;- haryana_crop |&gt; \n  terra::extract(haryana_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(haryana_vec |&gt; st_drop_geometry() |&gt; \n              select(id, district, tehsil)) |&gt; \n  mutate(\n    rank = row_number(),\n    facet_var = if_else(rank &lt;= 39, \"1\", \"2\")\n  )\n\n# Add Ranks to display\nharyana_vec &lt;- haryana_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  mutate(\n    rank = fct(\n      as.character(rank),\n      levels = paste0(77:1)\n    )\n  ) |&gt; \n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = rank\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5)\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        tehsil\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = 0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100*crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  facet_wrap(~facet_var, nrow = 1, scales = \"free_y\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\n\n\nCode\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = haryana_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = haryana_vec,\n    colour = \"white\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = haryana_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = haryana_vec,\n    mapping = aes(label = rank),\n    size = 2,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"Cropland in different Sub-districts of Haryana (India)\",\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each subdivision that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_4.png\"\n  ),\n  height = 1300,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\nThis map visualizes the percentage of cropland across Haryana’s tehsils using high-resolution ESA WorldCover data. Each subdistrict is ranked by cropland coverage, with darker shades indicating higher agricultural presence. An inset chart provides a ranked comparison of tehsils, offering a clear insight into regional variations in cropland distribution. Data sourced from ESA WorldCover (CC BY 4.0).\n\n\n\n\n\nThe geodata::gadm() function enables users to fetch administrative boundary data for any country at different levels of granularity. In the code given below, gadm() retrieves boundary data for India at three levels: state (level 1), district (level 2), and sub-district (level 3), storing them as simple features (sf) objects after conversion using st_as_sf().\n\n\nCode\nindia1 &lt;- geodata::gadm(\n  country = \"India\",\n  level = 1,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names()\n\nindia2 &lt;- geodata::gadm(\n  country = \"India\",\n  level = 2,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names()\n\nindia3 &lt;- geodata::gadm(\n  country = \"India\",\n  level = 3,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names()\n\ng1 &lt;- india2 |&gt; \n  filter(name_1 == c(\"Karnataka\")) |&gt; \n  ggplot() +\n  geom_sf(\n    linewidth = 0.2,\n    colour = \"white\"\n  ) +\n  ggrepel::geom_text_repel(\n    aes(label = name_2, \n        geometry = geometry),\n    stat = \"sf_coordinates\",\n    force = 0.5,\n    force_pull = 10,\n    box.padding = 0\n  ) +\n  labs(\n    x = NULL, y = NULL, \n    title = \"Karnataka\"\n  ) +\n  theme(\n    panel.grid = element_line(\n      linewidth = 0.2\n    ),\n    plot.title = element_text(\n      hjust = 0.5, size = 24\n    )\n  )\n\ng2 &lt;- india2 |&gt; \n  filter(name_1 == c(\"Tamil Nadu\")) |&gt; \n  ggplot() +\n  geom_sf(\n    linewidth = 0.2,\n    colour = \"white\"\n  ) +\n  ggrepel::geom_text_repel(\n    aes(label = name_2, \n        geometry = geometry),\n    stat = \"sf_coordinates\",\n    force = 0.5,\n    force_pull = 10,\n    box.padding = 0\n  ) +\n  labs(\n    x = NULL, y = NULL, \n    title = \"Tamil Nadu\"\n  ) +\n  theme(\n    panel.grid = element_line(\n      linewidth = 0.2\n    ),\n    plot.title = element_text(\n      hjust = 0.5, size = 24\n    )\n  )\n\nlibrary(patchwork)\nggsave(\n  plot = (g1 + g2),\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"geodata_package_5.png\"),\n  height = 800,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nMaking Cropland Data for Karnataka and Tamil Nadu\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nstate_name &lt;- \"Karnataka\"\n\nstate_vec &lt;- india2 |&gt; \n  filter(name_1 == state_name) |&gt; \n  mutate(id = row_number())\n\nstate_vec_boundary &lt;- st_union(state_vec) |&gt; \n  st_as_sf()\n\nstate_crop &lt;- globalcrop |&gt; \n  terra::crop(state_vec) |&gt; \n  terra::mask(state_vec)\n\n# Computing percentage area of each district that is Cropland\ndf1 &lt;- state_crop |&gt; \n  terra::extract(state_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(\n    state_vec |&gt; \n      st_drop_geometry() |&gt; \n      select(id, name_2)\n  ) |&gt; \n  mutate(rank = row_number())\n\n# Add Ranks to display\nstate_vec &lt;- state_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = fct(as.character(rank),\n              levels = as.character(max(df1$rank):1))\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5),\n    position = position_identity()\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        name_2\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = -0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100 * crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = state_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = state_vec,\n    colour = \"white\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = state_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = state_vec,\n    mapping = aes(label = rank),\n    size = 6,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = paste0(\n      \"Cropland in different Districts of \",  \n      state_name, \n      \" (India)\"),\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each district that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_6.png\"\n  ),\n  height = 1400,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nstate_name &lt;- \"Tamil Nadu\"\n\nstate_vec &lt;- india2 |&gt; \n  filter(name_1 == state_name) |&gt; \n  mutate(id = row_number())\n\nstate_vec_boundary &lt;- st_union(state_vec) |&gt; \n  st_as_sf()\n\nstate_crop &lt;- globalcrop |&gt; \n  terra::crop(state_vec) |&gt; \n  terra::mask(state_vec)\n\n# Computing percentage area of each district that is Cropland\ndf1 &lt;- state_crop |&gt; \n  terra::extract(state_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(\n    state_vec |&gt; \n      st_drop_geometry() |&gt; \n      select(id, name_2)\n  ) |&gt; \n  mutate(rank = row_number())\n\n# Add Ranks to display\nstate_vec &lt;- state_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = fct(as.character(rank),\n              levels = as.character(max(df1$rank):1))\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5),\n    position = position_identity()\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        name_2\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = -0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100 * crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = state_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = state_vec,\n    colour = \"grey20\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = state_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = state_vec,\n    mapping = aes(label = rank),\n    size = 6,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = paste0(\n      \"Cropland in different Districts of \",  \n      state_name, \n      \" (India)\"),\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each district that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_7.png\"\n  ),\n  height = 1400,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "geocomputation/geodata_package.html#exploring-the-geodata-package",
    "href": "geocomputation/geodata_package.html#exploring-the-geodata-package",
    "title": "Exploring the package {geodata}",
    "section": "",
    "text": "The {geodata} package (Hijmans et al. 2024) with {sf} (Pebesma and Bivand 2023) and {terra} (Hijmans 2024)\n\n\nCode\n# Data Import and Wrangling Tools\nlibrary(tidyverse)            # All things tidy\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\n\n# Package to explore\nlibrary(geodata)              # Geospatial Data\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Saira Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**: {geodata} package  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\nThis code visualizes monthly average temperature data for Greenland using geospatial data and ggplot2 in R, leveraging key functions from the {geodata} package. The geodata::gadm() function is used to download Greenland’s administrative boundaries as vector data, which is processed into a simple feature object with sf::st_as_sf(). The geodata::worldclim_country() function retrieves average temperature climate data for Greenland. The climate data is aggregated for lower resolution using terra::aggregate(), cropped to Greenland’s boundaries with terra::crop(), and masked with terra::mask() to match the vector boundary. It is then reprojected to a North Pole Stereographic projection using terra::project(). A faceted ggplot ( Figure 1 ) is created to visualize temperature data across all 12 months, with color gradients representing temperature values, styled with a minimal theme.\n\n\nCode\n# Get Greenland's boundaries\ngreenland_vector &lt;- geodata::gadm(\n  country = \"Greenland\",\n  path = tempdir(),\n  resolution = 2\n) |&gt; \n  st_as_sf()\n\nvec1 &lt;- greenland_vector |&gt; \n  st_union() |&gt; \n  st_as_sf()\n\n# ggplot(greenland_vector) +\n#   geom_sf()\n\n# Get Average Temperature Climate Data for Greenland\ndf1 &lt;- worldclim_country(\n  country = \"Greenland\",\n  var = \"tavg\",\n  path = tempdir()\n)\n\n# Studying the layers: there are 12 - for the 12 months\ndf1\n\ndf1 |&gt; crs() |&gt; str_view()\n\n# Lower resolution for initial plots, and crop by Vector Map\ndf2 &lt;- df1 |&gt; \n  terra::aggregate(fact = 10, fun = mean) |&gt;\n  terra::crop(vec1) |&gt; \n  terra::mask(vec1)\n\n# Project into CRS: North Pole Stereographic\ndf3 &lt;- df2 |&gt; \n  project(\"EPSG:3413\", method = \"bilinear\")\n\nstrip_labels &lt;- month.name\nnames(strip_labels) &lt;- names(df2)\n\ng &lt;- ggplot() +\n  geom_spatraster(\n    data = df3\n  ) +\n  scale_fill_viridis_c(\n    na.value = \"transparent\",\n    labels = function(x) paste0(x, \"°C\"),\n  ) +\n  facet_wrap(\n    ~lyr,\n    labeller = labeller(lyr = strip_labels),\n    ncol = 3,\n    nrow = 4\n  ) +\n  coord_sf(\n    clip = \"off\"\n  ) +\n  labs(\n    title = \"Monthly Average Temperature in Greenland\",\n    fill = \"Average\\ntemperature\",\n    caption = plot_caption\n  ) +\n  theme_minimal(\n    base_family = \"body_font\",\n    base_size = bts * 3\n  ) +\n  theme(\n    axis.text = element_text(\n      size = bts, \n      margin = margin(0,0,0,0, \"pt\")\n    ),\n    axis.ticks.length = unit(0, \"pt\"),\n    strip.text = element_text(\n      margin = margin(0,0,0,0, \"pt\")\n    ),\n    panel.grid = element_line(\n      linewidth = 0.1,\n      linetype = 3,\n      colour = \"grey80\"\n    ),\n    legend.position = \"right\",\n    panel.spacing = unit(5, \"pt\"),\n    panel.background = element_rect(\n      fill = \"transparent\",\n      colour = \"transparent\"\n    ),\n    \n    # Legend Corrections\n    legend.title = element_text(\n      margin = margin(0,0,3,0, \"pt\"),\n      lineheight = 0.3,\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(0,0,0,2, \"pt\"),\n      size = 18\n    ),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    legend.key.width = unit(4, \"pt\"),\n    legend.key.height = unit(30, \"pt\"),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    plot.title = element_text(\n      size = bts * 4,\n      hjust = 0.5\n    ),\n    plot.title.position = \"plot\"\n  )\n  \n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \"geodata_package_1.png\"\n  ),\n  height = 1800,\n  width = 2000,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Monthly Average Temperatures Across Greenland: showcasing temperature gradients for each month using a North Pole Stereographic projection.\n\n\n\n\n\n\nThis code demonstrates the simulation of various sea level rise scenarios using elevation data and visualizes the resulting impact on global landmass through raster manipulation and plotting. It leverages the elevation_global() function to obtain global elevation raster data, with a resolution of 10 arc-seconds. The if_else() function is used to simulate sea level rise scenarios by adjusting elevation data based on thresholds (1m, 10m, 50m, 100m, and 200m). The manipulated elevation data is then stored as layers in a raster object created with rast() from the terra package.\nThe raster is reprojected into an aesthetically pleasing projection (ESRI:54030) using project() for better visualization. The final map is plotted with ggplot(), incorporating the geom_spatraster() layer to display raster data and facet_wrap() to present the different scenarios.\n\n\nCode\n# Getting blobale elevation raster data\nge_raw &lt;- elevation_global(\n  res = 10,\n  path = tempdir()\n)\n\n# Simulating Sea Leave Rise by different heights\nelev_tibble &lt;- tibble(\n  base = values(ge_raw),\n  rise_1 = if_else(base &lt; 1, NA, base),\n  rise_10 = if_else(base &lt; 10, NA, base),\n  rise_40 = if_else(base &lt; 50, NA, base),\n  rise_80 = if_else(base &lt; 100, NA, base),\n  rise_100 = if_else(base &lt; 200, NA, base)\n)\n\n# Make a blank raster of World Map size\nge1 &lt;- rast(\n  nrow = dim(ge_raw)[1],\n  ncol = dim(ge_raw)[2],\n  nlyrs = ncol(elev_tibble)\n)\n# Add values from the tibble to different layers of \n# the newly created raster\nvalues(ge1) &lt;- as.matrix(elev_tibble)\n\n# Reproject Raster into a nice projection \nge1 &lt;- ge1 |&gt; \n  project(\"ESRI:54030\")\n\n# Earlier Attempts that did not work\n# ge1 &lt;- ge_raw\n# sea_level_rise = 1       # In metres\n# values(ge1) &lt;- if_else(\n#   values(ge_raw) &lt; sea_level_rise,\n#   NA,\n#   values(ge_raw)\n#   )\n# \n# paste0(\"ge\", sea_level_rise) |&gt; \n#   assign(ge_raw)\n# \n\nstrip_labels &lt;- c(\n  \"Current Sea Level\",\n  paste0(\"Rise by \", \n         c(1, 10, 50, 100, 200), \n         \" metres\")\n)\nnames(strip_labels) &lt;- paste0(\"lyr.\", 1:6)\n  \ng &lt;- ggplot() +\n  geom_spatraster(\n    data = ge1\n  ) +\n  facet_wrap(\n    ~lyr, \n    ncol = 2,\n    labeller = labeller(lyr = strip_labels)\n    ) +\n  scale_fill_wiki_c(\n    na.value = \"lightblue\"\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"World Map: scenarios with rise in Sea Levels\",\n    subtitle = \"Simulating different levels of sea level rise, and effect of landmass using simple raster arithmetic\",\n    caption = plot_caption,\n    fill = \"Elevation above sea level (m)\"\n  ) +\n  theme_minimal(\n    base_size = 2 * bts,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    panel.spacing = unit(2, \"pt\"),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    panel.grid = element_blank(),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(5,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title = element_text(\n      margin = margin(15,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\"\n    ),\n    plot.subtitle = element_text(\n      margin = margin(5,0,0,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 1.5\n    ),\n    strip.text = element_text(\n      margin = margin(2,0,-1,0, \"pt\"),\n      face = \"bold\"\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.box.margin = margin(-10,0,3,0, \"pt\"),\n    legend.margin = margin(-10,0,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5,\n      size = bts\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \"geodata_package_2.png\"\n  ),\n  height = 1150,\n  width = 1000,\n  units = \"px\",\n  bg = \"lightblue\"\n)\n\n\n\n\n\nAn elevation map of the world plotted using geom_spatraster() which shows 6 facets - each with a different scenario of sea level rise with global warming - current levels, 1 m, 10 m, 50 m, 100 m and 200 m - drawn with simple raster arithmetic. The world is projected in Robinson Projection (ESRI:54030) to make is aesthetically pleasing.\n\n\n\n\n\nThis code extends the sea level rise simulation to the European region by refining the raster data and restricting it to the continent’s boundaries. It first retrieves global elevation data using elevation_global(), then defines a bounding box to exclude distant islands and ensure a focused analysis on mainland Europe.\nTo obtain vector data for European countries, ne_countries() from the rnaturalearth package is used, selecting only relevant attributes. Unlike the previous global analysis, this visualization applies the ETRS89 / LAEA Europe projection (EPSG:32633) using project() to maintain spatial accuracy for the European context. The final visualization integrates raster data using geom_spatraster() and overlays country borders (shown in white colour) with geom_sf(), providing a detailed view of how landmass is affected by rising sea levels.\n\n\nCode\n# Getting global elevation raster data\nge_raw &lt;- elevation_global(\n  res = 10,\n  path = tempdir()\n)\n\n# Create a bounding box to remove far off islands in Europe\nbounding_box &lt;- st_bbox(\n  c(xmin = -25, xmax = 45, ymin = 31, ymax = 70),\n  crs = \"EPSG:4326\"\n)\n\n# Get Vector Data on European Countries\neurope &lt;- rnaturalearth::ne_countries(\n  continent = \"Europe\",\n  returnclass = \"sf\",\n  scale = \"medium\"\n) |&gt; \n  select(name, iso_a3, geometry) |&gt; \n  filter(!(name %in% c(\"Russia\"))) |&gt; \n  st_crop(bounding_box)\n\nggplot(europe) +\n  geom_sf()\n\nwhole_europe &lt;- europe |&gt;\n  st_union() |&gt; \n  st_as_sf()\n\n# Check the map\nggplot(whole_europe) +\n  geom_sf()\n\n# Crop the global Elevation raster\nge_europe &lt;- ge_raw |&gt; \n  terra::crop(whole_europe) |&gt; \n  terra::mask(whole_europe)\n\nggplot() +\n  geom_spatraster(data = ge_europe)\n\n# Simulating Sea Leave Rise by different heights\nelev_tibble &lt;- tibble(\n  base = values(ge_europe),\n  rise_1 = if_else(base &lt; 1, NA, base),\n  rise_10 = if_else(base &lt; 10, NA, base),\n  rise_40 = if_else(base &lt; 50, NA, base),\n  rise_80 = if_else(base &lt; 100, NA, base),\n  rise_100 = if_else(base &lt; 200, NA, base)\n)\n\n# Make a blank raster of World Map size\nge1 &lt;- rast(\n  nrow = dim(ge_europe)[1],\n  ncol = dim(ge_europe)[2],\n  nlyrs = ncol(elev_tibble),\n  extent = ext(ge_europe),\n  resolution = res(ge_europe)\n)\n# Add values from the tibble to different layers of \n# the newly created raster\nvalues(ge1) &lt;- as.matrix(elev_tibble)\n\n# Test the ge1\n# ge1\n# ge_europe\n\n# Reproject Raster into ETRS89 / LAEA Europe Projection for Europe \nge_projected &lt;- ge1 |&gt; \n  project(\"EPSG:32633\")\n\n# Earlier Attempts that did not work\n# ge1 &lt;- ge_raw\n# sea_level_rise = 1       # In metres\n# values(ge1) &lt;- if_else(\n#   values(ge_raw) &lt; sea_level_rise,\n#   NA,\n#   values(ge_raw)\n#   )\n# \n# paste0(\"ge\", sea_level_rise) |&gt; \n#   assign(ge_raw)\n# \n\nstrip_labels &lt;- c(\n  \"Current Sea Level\",\n  paste0(\"Rise by \", \n         c(1, 10, 50, 100, 200), \n         \" metres\")\n)\nnames(strip_labels) &lt;- paste0(\"lyr.\", 1:6)\n  \ng &lt;- ggplot() +\n  geom_spatraster(\n    data = ge_projected\n  ) +\n  geom_sf(\n    data = europe,\n    colour = \"white\",\n    fill = \"transparent\",\n    linewidth = 0.1\n  ) +\n  facet_wrap(\n    ~lyr, \n    ncol = 2,\n    labeller = labeller(lyr = strip_labels)\n    ) +\n  scale_fill_wiki_c(\n    na.value = \"lightblue\"\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"Europe Map with rising in Sea Levels\",\n    subtitle = \"Simulating different levels of sea level rise, and effect of landmass using simple raster arithmetic\",\n    caption = plot_caption,\n    fill = \"Elevation above sea level (m)\"\n  ) +\n  theme_minimal(\n    base_size = 2 * bts,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    panel.spacing = unit(2, \"pt\"),\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    panel.grid = element_blank(),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(5,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title = element_text(\n      margin = margin(15,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\"\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 1.5\n    ),\n    strip.text = element_text(\n      margin = margin(2,0,-9,0, \"pt\"),\n      face = \"bold\"\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.box.margin = margin(-10,0,3,0, \"pt\"),\n    legend.margin = margin(-10,0,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5,\n      size = bts\n    ),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \"geodata_package_3.png\"\n  ),\n  height = 1150,\n  width = 1000,\n  units = \"px\",\n  bg = \"lightblue\"\n)\n\n\n\n\n\nSimulating Sea Level Rise in Europe: This map visualizes the impact of rising sea levels on European landmass using raster-based elevation data. Different scenarios, ranging from current sea levels to rises of 1m, 10m, 50m, 100m, and 200m, are represented to illustrate potential changes in geography. The analysis is tailored to the European context with an accurate ETRS89 / LAEA projection. The existing borders of nations are shown in white.\n\n\n\n\n\nThis R script uses open-source land cover data from the {geodata} package to analyze and visualize cropland distribution across Haryana’s subdistricts (tehsils). The dataset, derived from the ESA WorldCover dataset at a 0.3-second resolution, represents the fraction of cropland in each cell. The analysis starts by downloading global cropland data using geodata::cropland(). The Haryana subdistrict boundary shapefile is read using {sf} via read_sf(), cleaned with {janitor}, and transformed to EPSG:4326. The cropland raster is cropped and masked to Haryana’s boundaries using {terra} functions crop() and mask(). Raster extraction (terra::extract()) is performed to compute the average cropland percentage per subdistrict. The results are merged into the spatial data (left_join()) and ranked. Visualization is done using {ggplot2}, where an inset bar chart ranks subdistricts by cropland percentage.\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nharyana_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"haryana_map\",\n    \"HARYANA_SUBDISTRICT_BDY.shp\"\n  )\n) |&gt; \n  janitor::clean_names() |&gt; \n  mutate(\n    across(\n      .cols = c(district, tehsil),\n      .fns = function(x){\n        str_replace_all(x, \"\\\\|\", \"I\") |&gt; \n          str_replace_all(\"&gt;\", \"A\") |&gt; \n          str_replace_all(\"@\", \"U\") |&gt; \n          str_to_title()\n      }\n    )\n  ) |&gt; \n  st_transform(\"EPSG:4326\") |&gt; \n  mutate(id = row_number()) |&gt; \n  relocate(id)\n\nharyana_vec_boundary &lt;- st_union(haryana_vec) |&gt; \n  st_as_sf()\n\nharyana_crop &lt;- globalcrop |&gt; \n  terra::crop(haryana_vec) |&gt; \n  terra::mask(haryana_vec)\n\n# Computing percentage area of each subdistrict that is Cropland\ndf1 &lt;- haryana_crop |&gt; \n  terra::extract(haryana_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(haryana_vec |&gt; st_drop_geometry() |&gt; \n              select(id, district, tehsil)) |&gt; \n  mutate(\n    rank = row_number(),\n    facet_var = if_else(rank &lt;= 39, \"1\", \"2\")\n  )\n\n# Add Ranks to display\nharyana_vec &lt;- haryana_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  mutate(\n    rank = fct(\n      as.character(rank),\n      levels = paste0(77:1)\n    )\n  ) |&gt; \n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = rank\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5)\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        tehsil\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = 0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100*crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  facet_wrap(~facet_var, nrow = 1, scales = \"free_y\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\n\n\nCode\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = haryana_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = haryana_vec,\n    colour = \"white\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = haryana_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = haryana_vec,\n    mapping = aes(label = rank),\n    size = 2,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"Cropland in different Sub-districts of Haryana (India)\",\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each subdivision that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_4.png\"\n  ),\n  height = 1300,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\nThis map visualizes the percentage of cropland across Haryana’s tehsils using high-resolution ESA WorldCover data. Each subdistrict is ranked by cropland coverage, with darker shades indicating higher agricultural presence. An inset chart provides a ranked comparison of tehsils, offering a clear insight into regional variations in cropland distribution. Data sourced from ESA WorldCover (CC BY 4.0).\n\n\n\n\n\nThe geodata::gadm() function enables users to fetch administrative boundary data for any country at different levels of granularity. In the code given below, gadm() retrieves boundary data for India at three levels: state (level 1), district (level 2), and sub-district (level 3), storing them as simple features (sf) objects after conversion using st_as_sf().\n\n\nCode\nindia1 &lt;- geodata::gadm(\n  country = \"India\",\n  level = 1,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names()\n\nindia2 &lt;- geodata::gadm(\n  country = \"India\",\n  level = 2,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names()\n\nindia3 &lt;- geodata::gadm(\n  country = \"India\",\n  level = 3,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names()\n\ng1 &lt;- india2 |&gt; \n  filter(name_1 == c(\"Karnataka\")) |&gt; \n  ggplot() +\n  geom_sf(\n    linewidth = 0.2,\n    colour = \"white\"\n  ) +\n  ggrepel::geom_text_repel(\n    aes(label = name_2, \n        geometry = geometry),\n    stat = \"sf_coordinates\",\n    force = 0.5,\n    force_pull = 10,\n    box.padding = 0\n  ) +\n  labs(\n    x = NULL, y = NULL, \n    title = \"Karnataka\"\n  ) +\n  theme(\n    panel.grid = element_line(\n      linewidth = 0.2\n    ),\n    plot.title = element_text(\n      hjust = 0.5, size = 24\n    )\n  )\n\ng2 &lt;- india2 |&gt; \n  filter(name_1 == c(\"Tamil Nadu\")) |&gt; \n  ggplot() +\n  geom_sf(\n    linewidth = 0.2,\n    colour = \"white\"\n  ) +\n  ggrepel::geom_text_repel(\n    aes(label = name_2, \n        geometry = geometry),\n    stat = \"sf_coordinates\",\n    force = 0.5,\n    force_pull = 10,\n    box.padding = 0\n  ) +\n  labs(\n    x = NULL, y = NULL, \n    title = \"Tamil Nadu\"\n  ) +\n  theme(\n    panel.grid = element_line(\n      linewidth = 0.2\n    ),\n    plot.title = element_text(\n      hjust = 0.5, size = 24\n    )\n  )\n\nlibrary(patchwork)\nggsave(\n  plot = (g1 + g2),\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"geodata_package_5.png\"),\n  height = 800,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nMaking Cropland Data for Karnataka and Tamil Nadu\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nstate_name &lt;- \"Karnataka\"\n\nstate_vec &lt;- india2 |&gt; \n  filter(name_1 == state_name) |&gt; \n  mutate(id = row_number())\n\nstate_vec_boundary &lt;- st_union(state_vec) |&gt; \n  st_as_sf()\n\nstate_crop &lt;- globalcrop |&gt; \n  terra::crop(state_vec) |&gt; \n  terra::mask(state_vec)\n\n# Computing percentage area of each district that is Cropland\ndf1 &lt;- state_crop |&gt; \n  terra::extract(state_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(\n    state_vec |&gt; \n      st_drop_geometry() |&gt; \n      select(id, name_2)\n  ) |&gt; \n  mutate(rank = row_number())\n\n# Add Ranks to display\nstate_vec &lt;- state_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = fct(as.character(rank),\n              levels = as.character(max(df1$rank):1))\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5),\n    position = position_identity()\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        name_2\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = -0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100 * crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = state_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = state_vec,\n    colour = \"white\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = state_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = state_vec,\n    mapping = aes(label = rank),\n    size = 6,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = paste0(\n      \"Cropland in different Districts of \",  \n      state_name, \n      \" (India)\"),\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each district that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_6.png\"\n  ),\n  height = 1400,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nstate_name &lt;- \"Tamil Nadu\"\n\nstate_vec &lt;- india2 |&gt; \n  filter(name_1 == state_name) |&gt; \n  mutate(id = row_number())\n\nstate_vec_boundary &lt;- st_union(state_vec) |&gt; \n  st_as_sf()\n\nstate_crop &lt;- globalcrop |&gt; \n  terra::crop(state_vec) |&gt; \n  terra::mask(state_vec)\n\n# Computing percentage area of each district that is Cropland\ndf1 &lt;- state_crop |&gt; \n  terra::extract(state_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(\n    state_vec |&gt; \n      st_drop_geometry() |&gt; \n      select(id, name_2)\n  ) |&gt; \n  mutate(rank = row_number())\n\n# Add Ranks to display\nstate_vec &lt;- state_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = fct(as.character(rank),\n              levels = as.character(max(df1$rank):1))\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5),\n    position = position_identity()\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        name_2\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = -0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100 * crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = state_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = state_vec,\n    colour = \"grey20\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = state_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = state_vec,\n    mapping = aes(label = rank),\n    size = 6,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = paste0(\n      \"Cropland in different Districts of \",  \n      state_name, \n      \" (India)\"),\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each district that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_7.png\"\n  ),\n  height = 1400,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "geocomputation/geodata_package.html#exploring-crop-data-from-geodata",
    "href": "geocomputation/geodata_package.html#exploring-crop-data-from-geodata",
    "title": "Exploring the package {geodata}",
    "section": "Exploring Crop data from {geodata}",
    "text": "Exploring Crop data from {geodata}\nThis R script uses open-source land cover data from the {geodata} package to analyze and visualize cropland distribution across Haryana’s subdistricts (tehsils). The dataset, derived from the ESA WorldCover dataset at a 0.3-second resolution, represents the fraction of cropland in each cell. The analysis starts by downloading global cropland data using geodata::cropland(). The Haryana subdistrict boundary shapefile is read using {sf} via read_sf(), cleaned with {janitor}, and transformed to EPSG:4326. The cropland raster is cropped and masked to Haryana’s boundaries using {terra} functions crop() and mask(). Raster extraction (terra::extract()) is performed to compute the average cropland percentage per subdistrict. The results are merged into the spatial data (left_join()) and ranked. Visualization is done using {ggplot2}, where an inset bar chart ranks subdistricts by cropland percentage.\n\n\nCode\nglobalcrop &lt;- geodata::cropland(\n  source = \"worldcover\",\n  path = tempdir()\n)\n\nharyana_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"haryana_map\",\n    \"HARYANA_SUBDISTRICT_BDY.shp\"\n  )\n) |&gt; \n  janitor::clean_names() |&gt; \n  mutate(\n    across(\n      .cols = c(district, tehsil),\n      .fns = function(x){\n        str_replace_all(x, \"\\\\|\", \"I\") |&gt; \n          str_replace_all(\"&gt;\", \"A\") |&gt; \n          str_replace_all(\"@\", \"U\") |&gt; \n          str_to_title()\n      }\n    )\n  ) |&gt; \n  st_transform(\"EPSG:4326\") |&gt; \n  mutate(id = row_number()) |&gt; \n  relocate(id)\n\nharyana_vec_boundary &lt;- st_union(haryana_vec) |&gt; \n  st_as_sf()\n\nharyana_crop &lt;- globalcrop |&gt; \n  terra::crop(haryana_vec) |&gt; \n  terra::mask(haryana_vec)\n\n# Computing percentage area of each subdistrict that is Cropland\ndf1 &lt;- haryana_crop |&gt; \n  terra::extract(haryana_vec) |&gt; \n  as_tibble() |&gt; \n  group_by(ID) |&gt; \n  summarise(crop_perc = mean(cropland)) |&gt; \n  arrange(desc(crop_perc)) |&gt; \n  janitor::clean_names() |&gt; \n  left_join(haryana_vec |&gt; st_drop_geometry() |&gt; \n              select(id, district, tehsil)) |&gt; \n  mutate(\n    rank = row_number(),\n    facet_var = if_else(rank &lt;= 39, \"1\", \"2\")\n  )\n\n# Add Ranks to display\nharyana_vec &lt;- haryana_vec |&gt; \n  left_join(df1)\n\n\ng_inset &lt;- df1 |&gt;\n  mutate(\n    rank = fct(\n      as.character(rank),\n      levels = paste0(77:1)\n    )\n  ) |&gt; \n  ggplot(\n    mapping = aes(\n      x = crop_perc, \n      y = rank\n    )\n  ) +\n  geom_col(\n    width = 0.6,\n    fill = alpha(\"grey20\", 0.5)\n  ) +\n  geom_text(\n    mapping = aes(\n      label = paste0(\n        tehsil\n      ),\n      x = 0\n    ),\n    nudge_x = -0.05,\n    hjust = 1,\n    size = 4,\n    lineheight = 0.3,\n    family = \"body_font\",\n    colour = \"grey20\"\n  ) +\n  geom_label(\n    mapping = aes(label = rank, x = 0.02),\n    family = \"body_font\",\n    size = 4,\n    label.size = unit(0.1, \"pt\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  geom_text(\n    mapping = aes(label = paste0(\n      round(100*crop_perc, 1), \"%\")),\n    family = \"body_font\",\n    size = 4,\n    hjust = 1,\n    nudge_x = -0.03,\n    colour = \"white\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  facet_wrap(~facet_var, nrow = 1, scales = \"free_y\") +\n  labs(\n    x = NULL, y = NULL\n  ) +\n  scale_x_continuous(\n    labels = label_percent(),\n    expand = expansion(c(0.3, 0)),\n    breaks = c(0, seq(0.1, 0.9, 0.2))\n  ) +\n  theme(\n    axis.text.y = element_blank(),\n    strip.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\n\n\nCode\ng_base &lt;- ggplot() +\n  geom_spatraster(\n    data = haryana_crop\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blue-Yellow\",\n    direction = -1,\n    na.value = \"transparent\",\n    trans = \"exp\"\n  ) +\n  geom_sf(\n    data = haryana_vec,\n    colour = \"white\",\n    fill = \"transparent\"\n  ) +\n  geom_sf(\n    data = haryana_vec_boundary,\n    colour = \"grey10\",\n    linewidth = 0.5,\n    fill = \"transparent\"\n  ) +\n  geom_sf_label(\n    data = haryana_vec,\n    mapping = aes(label = rank),\n    size = 2,\n    colour = \"grey10\",\n    fill = alpha(\"white\", 0.9),\n    label.size = NA,\n    label.r = unit(0.1, \"lines\"),\n    label.padding = unit(0.1, \"lines\")\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"Cropland in different Sib-districts of Haryana (India)\",\n    subtitle = \"Using data from ESA WorldCover, showing percentage area of each subdivision that is cropland.\",\n    caption = plot_caption,\n    fill = \"Percentage area in each pixel that is cropland\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal(\n    base_size = bts * 1.5,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    text = element_text(\n      colour = \"grey20\",\n      lineheight = 0.3\n    ),\n    plot.margin = margin(0,0,0,0, \"pt\"),\n    legend.position = \"inside\",\n    legend.position.inside = c(1, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.justification = c(1, 1),\n    panel.grid = element_line(\n      colour = \"grey50\",\n      linetype = 3,\n      linewidth = 0.2\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(35,0,5,0, \"pt\"),\n      size = bts\n    ),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(10,0,0,0, \"pt\"),\n      hjust = 0.5,\n      face = \"bold\",\n      size = bts * 3\n    ),\n    plot.subtitle = element_text(\n      margin = margin(3,0,1,0, \"pt\"),\n      hjust = 0.5,\n      size = bts * 2\n    ),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(35, \"pt\"),\n    legend.box.margin = margin(10,5,3,0, \"pt\"),\n    legend.margin = margin(10,5,0,0, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\"),\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\"),\n      hjust = 0.5\n    ),\n    axis.text.y = element_text(\n      margin = margin(0,0,0,180, \"pt\")\n    ),\n    axis.ticks = element_blank(),\n    axis.ticks.length = unit(0, \"pt\")\n  )\n\nlibrary(patchwork)\ng &lt;- g_base +\n  inset_element(\n    p = g_inset,\n    left = -0.1, right = 0.47,\n    bottom = 0, top = 0.91,\n    align_to = \"full\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\", \n    \"geodata_package_4.png\"\n  ),\n  height = 1300,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\nThis map visualizes the percentage of cropland across Haryana’s tehsils using high-resolution ESA WorldCover data. Each subdistrict is ranked by cropland coverage, with darker shades indicating higher agricultural presence. An inset chart provides a ranked comparison of tehsils, offering a clear insight into regional variations in cropland distribution. Data sourced from ESA WorldCover (CC BY 4.0)."
  },
  {
    "objectID": "geocomputation/climateR_package.html",
    "href": "geocomputation/climateR_package.html",
    "title": "Exploring the package {climateR}",
    "section": "",
    "text": "Exploring {climateR} (by Mike Johnson) with {sf} (Pebesma and Bivand 2023) and {terra} (Hijmans 2024)\n\n\nCode\n# Install {cliamteR} package\n# remotes::install_github(\"mikejohnson51/AOI\") # suggested!\n# remotes::install_github(\"mikejohnson51/climateR\")\n\n# Data Import and Wrangling Tools\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\nlibrary(tidyverse)            # All things tidy\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\n\n# Package to explore\nlibrary(climateR)             # Climate Data\nlibrary(AOI)                  # Get area of interest\n\n# Making tables in R\nlibrary(gt)                   # Beautiful Tables\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Asap Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**: {climateR} package  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)"
  },
  {
    "objectID": "geocomputation/climateR_package.html#exploring-the-geodata-package",
    "href": "geocomputation/climateR_package.html#exploring-the-geodata-package",
    "title": "Exploring the package {cliamteR}",
    "section": "",
    "text": "The {geodata} package (Hijmans et al. 2024) with {sf} (Pebesma and Bivand 2023) and {terra} (Hijmans 2024)\n\n\nCode\n# Install {cliamteR} package\n# remotes::install_github(\"mikejohnson51/AOI\") # suggested!\n# remotes::install_github(\"mikejohnson51/climateR\")\n\n# Data Import and Wrangling Tools\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\nlibrary(tidyverse)            # All things tidy\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\n\n# Package to explore\nlibrary(climateR)             # Climate Data\nlibrary(AOI)                  # Get area of interest\n\n# Making tables in R\nlibrary(gt)                   # Beautiful Tables\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Asap Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**: {geodata} package  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)"
  },
  {
    "objectID": "geocomputation/climateR_package.html#getterraclim",
    "href": "geocomputation/climateR_package.html#getterraclim",
    "title": "Exploring the package {climateR}",
    "section": "getTerraClim()",
    "text": "getTerraClim()\nThe getTerraClim() function in the {climateR} package provides access to TerraClimate data, a high-resolution dataset that offers monthly climate and water balance variables from 1958 onward. These variables include key climate indicators such as precipitation, temperature, soil moisture, wind speed, and evaporation metrics.\n\n\nCode\nterraClim_vars &lt;- tibble::tibble(\n  Variable = c(\"aet\", \"def\", \"PDSI\", \"pet\", \"ppt\", \"q\", \"soil\", \"srad\", \n               \"swe\", \"tmax\", \"tmin\", \"vap\", \"vpd\", \"ws\"),\n  Units = c(\"mm\", \"mm\", \"unitless\", \"mm\", \"mm\", \"mm\", \"mm\", \"W/m^2\", \n            \"mm\", \"degC\", \"degC\", \"kPa\", \"kPa\", \"m/s\"),\n  Description = c(\"Water evaporation amount\", \n                  \"Potential evaporation minus actual evaporation\",\n                  \"Palmer Drought Severity Index\",\n                  \"Potential evaporation amount\",\n                  \"Precipitation amount\",\n                  \"Runoff amount\",\n                  \"Soil moisture content\",\n                  \"Downwelling shortwave flux in air\",\n                  \"Liquid water content of surface snow\",\n                  \"Maximum air temperature\",\n                  \"Minimum air temperature\",\n                  \"Water vapor partial pressure in air\",\n                  \"Vapor pressure deficit\",\n                  \"Wind speed\")\n)\n\nterraClim_vars |&gt; \n  gt::gt() |&gt; \n  gtExtras::gt_theme_538()\n\n\n\n\nTable 1: Summary of Climate and Hydrological Variables in getTerraClim()\n\n\n\n\n\n\n\n\n\nVariable\nUnits\nDescription\n\n\n\n\naet\nmm\nWater evaporation amount\n\n\ndef\nmm\nPotential evaporation minus actual evaporation\n\n\nPDSI\nunitless\nPalmer Drought Severity Index\n\n\npet\nmm\nPotential evaporation amount\n\n\nppt\nmm\nPrecipitation amount\n\n\nq\nmm\nRunoff amount\n\n\nsoil\nmm\nSoil moisture content\n\n\nsrad\nW/m^2\nDownwelling shortwave flux in air\n\n\nswe\nmm\nLiquid water content of surface snow\n\n\ntmax\ndegC\nMaximum air temperature\n\n\ntmin\ndegC\nMinimum air temperature\n\n\nvap\nkPa\nWater vapor partial pressure in air\n\n\nvpd\nkPa\nVapor pressure deficit\n\n\nws\nm/s\nWind speed"
  },
  {
    "objectID": "geocomputation/climateR_package.html#british-isles-monthly-rainfall-data",
    "href": "geocomputation/climateR_package.html#british-isles-monthly-rainfall-data",
    "title": "Exploring the package {climateR}",
    "section": "British Isles: Monthly Rainfall Data",
    "text": "British Isles: Monthly Rainfall Data\nThis code generates a faceted map of monthly rainfall in the British Isles from January 2018 to December 2022. It begins by defining the area of interest using aoi_get() and then retrieves precipitation data via getTerraClim(). The region is refined using ne_countries() and processed with st_union(), st_as_sf(), and st_crop() to match the raster data’s extent. The precipitation raster is cropped and masked using terra::crop() and terra::mask(). Monthly labels are extracted with str_remove() and format(). The plot is created using ggplot() with geom_spatraster() for the raster data and geom_sf() for country borders. Color scaling is handled by paletteer::scale_fill_paletteer_c(), and faceting is applied with facet_wrap(). The final visualization is styled using theme_map(), and the plot is saved with ggsave().\n\n\nCode\n# Try for a smaller area\n\nuk_vec &lt;- aoi_get(country = c(\"United Kingdom\", \"Ireland\"))\n\nuk_climate_raw &lt;- getTerraClim(\n  uk_vec,\n  varname = \"ppt\",\n  startDate = \"2018-01-01\",\n  endDate = \"2022-12-31\"\n)\n\nuk_vec_detail &lt;- rnaturalearth::ne_countries(\n  country = c(\"United Kingdom\", \"Ireland\"),\n  scale = \"medium\",\n  returnclass = \"sf\"\n) |&gt; \n  select(geometry) |&gt; \n  st_union() |&gt; \n  st_as_sf() |&gt; \n  st_crop(\n    st_bbox(\n      c(\n        ymin = 49.8,\n        ymax = 59.5,\n        xmin = -10.3,\n        xmax = 2\n      ),\n      crs = st_crs(\"EPSG:4326\")\n    )\n  ) |&gt; \n  st_transform(st_crs(uk_climate_raw$ppt))\n\nggplot(uk_vec_detail) +\n  geom_sf()\n\nuk_rast &lt;- uk_climate_raw$ppt |&gt; \n  terra::crop(uk_vec_detail) |&gt; \n  terra::mask(uk_vec_detail)\n\n\nstrip_labels &lt;- uk_rast |&gt; \n  names() |&gt; \n  str_remove(\"ppt_\") |&gt; \n  str_remove(\"_total\") |&gt; \n  as_date() |&gt; \n  format(\"%B\\n%Y\")\n\nnames(strip_labels) &lt;- uk_rast |&gt; \n  names()\n\n\ng &lt;- ggplot() +\n  geom_spatraster(\n    data = uk_rast[[c(1:60)]]\n  ) +\n  geom_sf(\n    data = uk_vec_detail,\n    fill = \"transparent\",\n    linewidth = 0.25,\n    colour = \"grey20\"\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blues 3\",\n    direction = -1,\n    na.value = \"transparent\",\n    limits = c(0, 450),\n    oob = scales::squish\n  ) +\n  facet_wrap(\n    ~lyr,\n    labeller = labeller(lyr = strip_labels),\n    nrow = 5,\n    ncol = 12\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"British Isles: Rainfall Pattern\",\n    fill = \"Monthly Precipitation (mm)\"\n  ) +\n  ggthemes::theme_map(\n    base_size = 40,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    strip.text = element_text(\n      hjust = 0,\n      margin = margin(6,0,-10,0,\"pt\"),\n      size = 48,\n      lineheight = 0.3\n    ),\n    strip.background = element_blank(),\n    plot.title = element_text(\n      margin = margin(0,0,10,0, \"pt\"),\n      hjust = 0.5,\n      size = 120\n    ),\n    panel.background = element_rect(\n      fill = \"transparent\",\n      colour = \"transparent\"\n    ),\n    legend.key.height = unit(10, \"pt\"),\n    legend.key.width = unit(100, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      size = 80,\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(2,0,0,0, \"mm\")\n    ),\n    plot.margin = margin(10,0,10,0, \"pt\"),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    legend.justification = c(0.5, 0)\n  )\n\nggsave(\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"climateR_package_1.png\"\n  ),\n  plot = g,\n  height = 4500,\n  width = 6000,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: This faceted visualization illustrates monthly precipitation trends across the British Isles from January 2018 to December 2022. Each panel represents a different month, showcasing variations in rainfall intensity using a gradient color scale. Data is sourced from TerraClimate and spatially refined for accuracy."
  },
  {
    "objectID": "geocomputation/climateR_package.html#exploring-the-climater-package",
    "href": "geocomputation/climateR_package.html#exploring-the-climater-package",
    "title": "Exploring the package {climateR}",
    "section": "",
    "text": "Exploring {climateR} (by Mike Johnson) with {sf} (Pebesma and Bivand 2023) and {terra} (Hijmans 2024)\n\n\nCode\n# Install {cliamteR} package\n# remotes::install_github(\"mikejohnson51/AOI\") # suggested!\n# remotes::install_github(\"mikejohnson51/climateR\")\n\n# Data Import and Wrangling Tools\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\nlibrary(tidyverse)            # All things tidy\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\n\n# Package to explore\nlibrary(climateR)             # Climate Data\nlibrary(AOI)                  # Get area of interest\n\n# Making tables in R\nlibrary(gt)                   # Beautiful Tables\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Asap Condensed\", \"body_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey20\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**: {climateR} package  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)"
  },
  {
    "objectID": "geocomputation/climateR_package.html#india-drought-severity-trends-2010---2023",
    "href": "geocomputation/climateR_package.html#india-drought-severity-trends-2010---2023",
    "title": "Exploring the package {climateR}",
    "section": "India: Drought Severity Trends (2010 - 2023)",
    "text": "India: Drought Severity Trends (2010 - 2023)\nThe Palmer Drought Severity Index (PDSI) is a widely used metric for measuring long-term drought conditions, based on temperature, precipitation, and soil moisture balance. It provides a standardized scale where negative values indicate drought (with -4 or lower signifying extreme drought) and positive values represent wet conditions.\nThe analysis shown in Figure 2 uses the TerraClimate dataset from the Climatology Lab, a high-resolution global dataset that offers monthly climate and hydrological variables at a ~4 km resolution. The dataset is accessed via the climateR package, which facilitates retrieval of climate data from TerraClimate. The geographic boundaries for India are obtained using Survey of India, and spatial data operations are conducted with sf and terra. The final visualization employs ggplot2 adn tidyterra to create a faceted graph displaying PDSI trends from 2010 to 2024, offering insights into regional drought patterns over time.\n\n\nCode\n# Get a nice map of India from Survey of India (simplified to\n# save on computing time)\nindia_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\",\n    \"India_Country_Boundary.shp\"\n  )\n) |&gt; \n  # Simplify to save computing time\n  st_simplify(dTolerance = 3000) |&gt; \n  # Keep on bigger szed polygons and multiploygons\n  filter(!st_is_empty(geometry)) |&gt; \n  arrange(desc(Area)) |&gt; \n  slice(1:2) |&gt; \n  select(-Area) |&gt; \n  st_transform(\"EPSG:4326\")\n\n# Quick check\nindia_vec |&gt; \n  ggplot() +\n  geom_sf()\n\n# Minor manual correction: Increase bounding box of India\n# as the top of north is slightly getting cropped\n# Get the current bounding box of India\nindia_bbox &lt;- st_bbox(india_vec)\n\n# Increase the northern boundary (ymax) by 2 degrees\nindia_bbox[\"ymax\"] &lt;- india_bbox[\"ymax\"] + 2\n\n# Convert the updated bounding box to an sf object\nindia_bbox_sf &lt;- st_as_sfc(india_bbox, crs = st_crs(india_vec))\n\n# Crop india_vec to match the expanded bounding box\nindia_vec &lt;- st_crop(india_vec, india_bbox_sf)\n\n# Remove temporary objects\nrm(india_bbox, india_bbox_sf)\n\n# Download the TerraClimate dataset on PDSI from \n# https://www.climatologylab.org/terraclimate.html\n# india_rast_raw &lt;- getTerraClim(\n#   india_vec,\n#   varname = \"PDSI\",\n#   startDate = \"2010-01-01\",\n#   endDate = \"2023-12-01\"\n# )\n# Use Downloaded Data\nindia_rast_raw &lt;- rast(\"india_rast.tif\")\n\n# Match CRS of both: prefer to change CRS of vector\n# Code for using directly downloaded data\n# india_vec2 &lt;- india_vec |&gt; \n#   st_transform(crs(india_rast_raw$PDSI))\n# Code for using downloaded data\nindia_vec2 &lt;- india_vec |&gt; \n  st_transform(crs(india_rast_raw))\n\n# Crop and Maskt he Raster to show only the data within \n# India's Administrative Borders\n# india_rast &lt;- india_rast_raw$PDSI |&gt; \n#   aggregate(fact = 4) |&gt; \n#   terra::crop(india_vec2) |&gt; \n#   terra::mask(india_vec2)\n\n# Code for using downloaded data\nindia_rast &lt;- india_rast_raw |&gt; \n  aggregate(fact = 4) |&gt; \n  terra::crop(india_vec2) |&gt; \n  terra::mask(india_vec2)\n\n# Clean Names for the Panel Strip Text: Month and Year\nstrip_labels &lt;- india_rast |&gt; \n  names() |&gt; \n  str_remove(\"PDSI_\") |&gt; \n  str_remove(\"_total\") |&gt; \n  as_date() |&gt; \n  format(\"%b\\n%Y\")\n\nnames(strip_labels) &lt;- india_rast |&gt; \n  names()\n\nlength(strip_labels)\n\n# Temporarily save india_rast to save download time\n# Check its range of values\n# writeRaster(\n#   india_rast,\n#   filename = \"india_rast.tif\"\n# )\n\n# india_rast |&gt; \n#   values() |&gt; \n#   range(na.rm = T)\n\n# A dummy tibble for writing labels along with maps\ndf_labels &lt;- tibble(strip_label = strip_labels) |&gt; \n  mutate(\n    strip_label = str_replace_all(strip_label, \"\\n\", \" \"),\n    month = rep(1:12, 14),\n    month_label = month(month, label = TRUE, abbr = TRUE),\n    year_label  = as.character(rep(2010:2023, each = 12)),\n    lyr = names(strip_labels)\n  ) |&gt; \n  mutate(\n    month_label = if_else(year_label == \"2010\", month_label, \"\"),\n    year_label = if_else(month == 1, year_label, \"\")\n  )\n\n# Some testing code to create facets with text only in few of them\n# g1 &lt;- ggplot(\n#   data = df_labels\n# ) +\n#   geom_text(\n#     data = df_labels |&gt; filter(str_detect(lyr, \"2010\")),\n#     mapping = aes(\n#       label = month_label,\n#       x = 82.5, y = 39\n#     ),\n#     size = 20,\n#     family = \"body_font\"\n#   ) +\n#   geom_text(\n#     data = df_labels |&gt; filter(month == 1),\n#     mapping = aes(\n#       label = year_label,\n#       x = 64, y = 22\n#     ),\n#     size = 20,\n#     family = \"body_font\"\n#   ) +\n#   coord_sf(\n#     default_crs = \"EPSG:4326\",\n#     clip = \"off\",\n#     xlim = c(68, 97),\n#     ylim = c(7, 37)\n#   ) +\n#   facet_wrap(\n#     ~lyr,\n#     ncol = 12\n#   ) +\n#   theme_minimal() +\n#   theme(\n#     strip.text = element_blank(),\n#     axis.text = element_blank(),\n#     axis.title = element_blank(),\n#     panel.grid = element_blank()\n#   )\n# \n# ggsave(\n#   filename = here::here(\n#     \"geocomputation\", \"images\",\n#     \"climateR_package_temp.png\"\n#   ),\n#   plot = g1,\n#   height = 2500 * 4.1,\n#   width = 6000,\n#   units = \"px\",\n#   bg = \"white\",\n#   limitsize = FALSE\n# )\n# \n# ggplot() +\n#   geom_spatraster(\n#     data = india_rast[[1]]\n#   ) +\n#   coord_sf(\n#     default_crs = \"EPSG:4326\",\n#     clip = \"off\",\n#     xlim = c(68, 97),\n#     ylim = c(7, 37)\n#   )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = india_rast\n  ) +\n  geom_sf(\n    data = india_vec2,\n    fill = \"transparent\",\n    linewidth = 0.25,\n    colour = \"grey20\"\n  ) +\n  \n  # Strip Labels along the months at top\n  geom_text(\n    data = df_labels |&gt; filter(str_detect(lyr, \"2010\")),\n    mapping = aes(\n      label = month_label,\n      x = 82.5, y = 45\n    ),\n    size = 50,\n    family = \"body_font\"\n  ) +\n  \n  # Strip labels for Year at the left side\n  geom_text(\n    data = df_labels |&gt; filter(month == 1),\n    mapping = aes(\n      label = year_label,\n      x = 52, y = 22\n    ),\n    size = 50,\n    family = \"body_font\"\n  ) +\n  coord_sf(\n    default_crs = \"EPSG:4326\",\n    clip = \"off\",\n    xlim = c(68, 97),\n    ylim = c(7, 37)\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"ggthemes::Orange-Blue-White Diverging\",\n    direction = 1,\n    na.value = \"transparent\",\n    limits = c(-10, 10),\n    oob = scales::squish\n  ) +\n  facet_wrap(\n    ~lyr,\n    labeller = labeller(lyr = strip_labels),\n    ncol = 12\n  ) +\n  labs(\n    title = \"India: Drought Severity (2010 - 2023)\",\n    subtitle = str_wrap(\"Palmer Drought Severity Index (PDSI) measures long-term drought and wetness conditions based on temperature, precipitation, and soil moisture balance. Negative values indicate drought severity, while positive values signify wetter-than-normal conditions.\", 130),\n    fill = \"Palmer Drought Severity Index (PDSI)\",\n    caption = plot_caption\n  ) +\n  ggthemes::theme_map(\n    base_size = 40,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    # strip.text = element_text(\n    #   hjust = 0.7,\n    #   margin = margin(3,0,-20,0,\"pt\"),\n    #   size = 48,\n    #   lineheight = 0.3\n    # ),\n    strip.text = element_blank(),\n    strip.background = element_blank(),\n    plot.title.position = \"plot\",\n    plot.title = element_text(\n      margin = margin(0,0,10,0, \"pt\"),\n      hjust = 0.5,\n      size = 210\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,50,0, \"pt\"),\n      hjust = 0.5,\n      size = 80,\n      lineheight = 0.3\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(20,0,0,0, \"pt\"),\n      size = 80\n    ),\n    panel.background = element_rect(\n      fill = \"transparent\",\n      colour = \"transparent\"\n    ),\n    legend.key.height = unit(10, \"pt\"),\n    legend.key.width = unit(100, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      size = 80,\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(2,0,0,0, \"mm\"),\n      size = 60\n    ),\n    plot.margin = margin(10,5,10,90, \"pt\"),\n    legend.margin =  margin(-20,0,0,0, \"pt\"),\n    legend.box.margin = margin(-20,0,0,0, \"pt\"),\n    legend.justification = c(0.5, 0)\n  )\n\nggsave(\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"climateR_package_2.png\"\n  ),\n  plot = g2,\n  height = 9000,\n  width = 6200,\n  units = \"px\",\n  bg = \"white\",\n  limitsize = FALSE\n)\n\n\n\n\n\n\n\n\nFigure 2: This faceted visualization displays the monthly PDSI values across India from 2010 to 2024. Each horizontal row represents an year, while each column represents a month, highlighting spatial variations in drought and wetness conditions. Negative values (shades of red) indicate drought severity, while positive values (shades of blue) reflect wetter-than-normal conditions. Data sourced from TerraClimate via the Climatology Lab."
  },
  {
    "objectID": "geocomputation/climateR_package.html#precipitation-data-graphic-for-india.",
    "href": "geocomputation/climateR_package.html#precipitation-data-graphic-for-india.",
    "title": "Exploring the package {climateR}",
    "section": "Precipitation data graphic for India.",
    "text": "Precipitation data graphic for India.\n\n\nCode\n# Get a nice map of India from Survey of India (simplified to\n# save on computing time)\nindia_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\",\n    \"India_Country_Boundary.shp\"\n  )\n) |&gt; \n  # Simplify to save computing time\n  st_simplify(dTolerance = 3000) |&gt; \n  # Keep on bigger szed polygons and multiploygons\n  filter(!st_is_empty(geometry)) |&gt; \n  arrange(desc(Area)) |&gt; \n  slice(1:2) |&gt; \n  select(-Area) |&gt; \n  st_transform(\"EPSG:4326\")\n\n# Quick check\nindia_vec |&gt; \n  ggplot() +\n  geom_sf()\n#--------------------------------------------------------------\n# Minor manual correction: Increase bounding box of India\n# as the top of north is slightly getting cropped\n# Get the current bounding box of India\nindia_bbox &lt;- st_bbox(india_vec)\n\n# Increase the northern boundary (ymax) by 2 degrees\nindia_bbox[\"ymax\"] &lt;- india_bbox[\"ymax\"] + 2\n\n# Convert the updated bounding box to an sf object\nindia_bbox_sf &lt;- st_as_sfc(india_bbox, crs = st_crs(india_vec))\n\n# Crop india_vec to match the expanded bounding box\nindia_vec &lt;- st_crop(india_vec, india_bbox_sf)\n\n# Remove temporary objects\nrm(india_bbox, india_bbox_sf)\n#-------------------------------------------------------------\n\n# Download the TerraClimate dataset on PDSI from \n# https://www.climatologylab.org/terraclimate.html\nindia_rast_raw &lt;- getTerraClim(\n  india_vec,\n  varname = \"ppt\",\n  startDate = \"2018-01-01\",\n  endDate = \"2023-12-01\"\n)\n\n# Match CRS of both: prefer to change CRS of vector\nindia_vec2 &lt;- india_vec |&gt; \n  st_transform(crs(india_rast_raw$ppt))\n\n# Crop and Maskt he Raster to show only the data within \n# India's Administrative Borders\nindia_rast &lt;- india_rast_raw$ppt |&gt; \n  aggregate(fact = 4) |&gt; \n  terra::crop(india_vec2) |&gt; \n  terra::mask(india_vec2)\n\n# Clean Names for the Panel Strip Text: Month and Year\nstrip_labels &lt;- india_rast |&gt; \n  names() |&gt; \n  str_remove(\"ppt_\") |&gt; \n  str_remove(\"_total\") |&gt; \n  as_date() |&gt; \n  format(\"%b\\n%Y\")\n\nnames(strip_labels) &lt;- india_rast |&gt; \n  names()\n\nlength(strip_labels)\n\n# Temporarily save india_rast to save download time\n# Check its range of values\nwriteRaster(\n  india_rast,\n  filename = \"india_ppt_rast.tif\",\n  overwrite = TRUE\n)\n\nindia_rast |&gt;\n  values() |&gt;\n  range(na.rm = T)\n\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = india_rast\n  ) +\n  geom_sf(\n    data = india_vec2,\n    fill = \"transparent\",\n    linewidth = 0.25,\n    colour = \"grey20\"\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Blues 3\",\n    direction = -1,\n    na.value = \"transparent\",\n    limits = c(0, 700),\n    breaks = seq(0, 600, 200),\n    oob = scales::squish\n  ) +\n  facet_wrap(\n    ~lyr,\n    labeller = labeller(lyr = strip_labels),\n    ncol = 12\n  ) +\n  coord_sf(clip = \"off\") +\n  labs(\n    title = \"India: Rainfall Patterns (2018 - 2023)\",\n    subtitle = str_wrap(\"Monthly rainfall data for India, from TerraClimate dataset, fetched as a Raster using {climateR}\", 130),\n    fill = \"Precipitation (mm)\",\n    caption = plot_caption\n  ) +\n  ggthemes::theme_map(\n    base_size = 40,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    strip.text = element_text(\n      hjust = 0.7,\n      margin = margin(3,0,-20,0,\"pt\"),\n      size = 48,\n      lineheight = 0.3\n    ),\n    strip.background = element_blank(),\n    plot.title = element_text(\n      margin = margin(0,0,10,0, \"pt\"),\n      hjust = 0.5,\n      size = 160\n    ),\n    plot.subtitle = element_text(\n      margin = margin(0,0,10,0, \"pt\"),\n      hjust = 0.5,\n      size = 70,\n      lineheight = 0.3\n    ),\n    plot.caption = element_textbox(\n      hjust = 0.5,\n      margin = margin(30,0,0,0, \"pt\"),\n      size = 60\n    ),\n    panel.background = element_rect(\n      fill = \"transparent\",\n      colour = \"transparent\"\n    ),\n    legend.key.height = unit(10, \"pt\"),\n    legend.key.width = unit(100, \"pt\"),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"mm\"),\n      size = 80,\n      hjust = 0.5\n    ),\n    legend.text = element_text(\n      margin = margin(2,0,0,0, \"mm\"),\n      size = 60\n    ),\n    plot.margin = margin(10,5,5,5, \"pt\"),\n    legend.margin =  margin(-20,0,0,0, \"pt\"),\n    legend.box.margin = margin(-20,0,0,0, \"pt\"),\n    legend.justification = c(0.5, 0)\n  )\n\nggsave(\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"climateR_package_3.png\"\n  ),\n  plot = g2,\n  height = 3700,\n  width = 4000,\n  units = \"px\",\n  bg = \"white\",\n  limitsize = FALSE\n)\n\n\n\n\n\nThis faceted visualization illustrates monthly precipitation trends across the India from January 2018 to December 2023. Each panel represents a different month, showcasing variations in rainfall intensity using a gradient color scale. Data is sourced from TerraClimate and spatially refined for accuracy."
  },
  {
    "objectID": "geocomputation/hillshader_package.html",
    "href": "geocomputation/hillshader_package.html",
    "title": "Showing elevation in Maps (1) : {hillshader}",
    "section": "",
    "text": "The hillshader package (Roudier 2024) is an R tool designed to create shaded relief maps using ray-tracing techniques.t serves as a wrapper around the rayshader (Morgan-Wall 2024) and raster (Hijmans 2024) packages, facilitating the generation of hillshade relief maps and their export to spatial files.\nThe primary function, hillshader(), allows for the creation of hillshade maps as RasterLayer objects. Users can customize the shading process by specifying different shader functions, such as ray_shade and ambient_shade, and adjust parameters like sun angle and altitude to achieve desired visual effects. Additionally, the package offers functions like add_shadow_2d, matrix_to_raster, and write_raster to enhance integration with rayshader pipelines and GIS workflows.\n\n\nCode\n# Data Import and Wrangling Tools\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\nlibrary(tidyverse)            # All things tidy\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\nlibrary(patchwork)            # Composing Plots\n\n# Package to explore\nlibrary(rayshader)            # 2D / 3D map visualizations\nlibrary(raster)               # Handling rasters\nlibrary(hillshader)           # Shaded reliefs in R\n\n# Making tables in R\nlibrary(gt)                   # Beautiful Tables\n\nbts = 36 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Tools**: {hillshader} *#rstats* \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\n\n\nCode\nmaungawhau_hr\n\nhs &lt;- hillshader(maungawhau_hr)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = rast(maungawhau_hr)) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"An Elevation Raster\",\n    subtitle = \"Maungawhau, a volcano in Auckland, New Zealand\",\n    fill = \"Elevation (metres)\"\n  ) +\n  coord_sf(expand = F, clip = \"off\") +\n  theme(\n    panel.grid = element_blank(),\n    legend.key.width = unit(5, \"pt\"),\n    plot.margin = margin(0,0,0,5, \"pt\"),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    axis.text = element_text(size = bts/2)\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = rast(hs)) +\n  paletteer::scale_fill_paletteer_c(\"ggthemes::Gray\", -1) +\n  labs(\n    title = \"Basic Hillshader raster\",\n    subtitle = \"Default behaviours of hillshader()\"\n  ) +\n  coord_sf(expand = F, clip = \"off\") +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    plot.margin = margin(0,5,0,0, \"pt\"),\n    axis.text = element_text(size = bts/2)\n  )\n\ng &lt;- g1 + g2 +\n  plot_annotation(\n    title = \"{hillshader}: A basic example\",\n    caption = plot_caption,\n    theme = theme(\n      plot.title = element_text(\n        hjust = 0.5,\n        family = \"title_font\"\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5,\n        family = \"title_font\"\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"hillshader_package_1.png\"\n  ),\n  height = 1200,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nCode\nhimachal_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\",\n    \"India_State_Boundary.shp\"\n  )\n) |&gt; \n  filter(State_Name == \"Himachal Pradesh\") |&gt; \n  st_transform(\"EPSG:4326\")\n\n# ggplot(himachal_vec) +\n#   geom_sf()\n# \n# st_bbox(himachal_vec)\n\nhimachal_rast &lt;- elevatr::get_elev_raster(\n  locations = himachal_vec,\n  z = 7\n) |&gt; \n  rast() |&gt; \n  terra::crop(himachal_vec) |&gt; \n  terra::mask(himachal_vec)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = himachal_rast) +\n  geom_sf(data = himachal_vec, fill = NA) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Himachal Pradesh (India)\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0,0),\n    legend.justification = c(0,0),\n    legend.key.height = unit(10, \"pt\"),\n    legend.title.position = \"top\",\n    legend.direction = \"horizontal\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    )\n  )\n\nplot_himachal &lt;- function(sunangle = 315, sunaltitude = 0){\n  hs &lt;- himachal_rast |&gt; \n    raster() |&gt; \n    hillshader(\n      c(\"ray_shade\", \"ambient_shade\"),\n      sunangle = sunangle,\n      sunaltitude = sunaltitude\n    )\n\n  ggplot() +\n    geom_spatraster(data = rast(hs)) +\n    geom_sf(data = himachal_vec, fill = NA) +\n    paletteer::scale_fill_paletteer_c(\n      \"ggthemes::Classic Gray\", \n      direction = 1,\n      na.value = \"transparent\",\n      trans = \"log2\"\n    ) +\n    labs(\n      title = paste0(\"sunangle: \", sunangle, \n                     \"  ; sunaltitude: \",\n                     sunaltitude)\n    ) +\n    coord_sf(expand = F, clip = \"off\") +\n    theme(\n      legend.position = \"none\",\n      panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n      ),\n      plot.margin = margin(0,5,0,0, \"pt\"),\n      axis.text = element_text(size = bts/2),\n      plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n      plot.subtitle = element_text(\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n}\n\ng2 &lt;- plot_himachal(sunangle = 315, sunaltitude = 0)\n\ng3 &lt;- plot_himachal(sunangle = 90, sunaltitude = 30)\n\ng4 &lt;- plot_himachal(sunangle = 315, sunaltitude = 30)\n\ng5 &lt;- plot_himachal(sunangle = 90, sunaltitude = 60)\n\ng6 &lt;- plot_himachal(sunangle = 315, sunaltitude = 60)\n\ng &lt;- wrap_plots(g1, g2, g3, g4, g5, g6) +\n  plot_layout(\n    ncol = 2,\n    nrow = 3\n  ) +\n  plot_annotation(\n    title = \"Combinations of sun-angle & sun-altitude in {hillshader}\",\n    caption = plot_caption,\n    theme = theme(\n      plot.title = element_text(\n        family = \"title_font\",\n        size = bts * 3,\n        hjust = 0.5,\n        lineheight = 0.3,\n        margin = margin(20,0,0,0, \"pt\")\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"hillshader_package_2.png\"\n  ),\n  height = 4800,\n  width = 3600,\n  units = \"px\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "geocomputation/hillshader_package.html#exploring-the-hillshader-package",
    "href": "geocomputation/hillshader_package.html#exploring-the-hillshader-package",
    "title": "Showing elevation in Maps (1) : {hillshader}",
    "section": "",
    "text": "The hillshader package (Roudier 2024) is an R tool designed to create shaded relief maps using ray-tracing techniques.t serves as a wrapper around the rayshader (Morgan-Wall 2024) and raster (Hijmans 2024) packages, facilitating the generation of hillshade relief maps and their export to spatial files.\nThe primary function, hillshader(), allows for the creation of hillshade maps as RasterLayer objects. Users can customize the shading process by specifying different shader functions, such as ray_shade and ambient_shade, and adjust parameters like sun angle and altitude to achieve desired visual effects. Additionally, the package offers functions like add_shadow_2d, matrix_to_raster, and write_raster to enhance integration with rayshader pipelines and GIS workflows.\n\n\nCode\n# Data Import and Wrangling Tools\nlibrary(sf)                   # Handling simple features in R\nlibrary(terra)                # Handling rasters in R\nlibrary(tidyterra)            # Rasters with ggplot2\nlibrary(tidyverse)            # All things tidy\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\nlibrary(patchwork)            # Composing Plots\n\n# Package to explore\nlibrary(rayshader)            # 2D / 3D map visualizations\nlibrary(raster)               # Handling rasters\nlibrary(hillshader)           # Shaded reliefs in R\n\n# Making tables in R\nlibrary(gt)                   # Beautiful Tables\n\nbts = 36 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Tools**: {hillshader} *#rstats* \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\n\n\nCode\nmaungawhau_hr\n\nhs &lt;- hillshader(maungawhau_hr)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = rast(maungawhau_hr)) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"An Elevation Raster\",\n    subtitle = \"Maungawhau, a volcano in Auckland, New Zealand\",\n    fill = \"Elevation (metres)\"\n  ) +\n  coord_sf(expand = F, clip = \"off\") +\n  theme(\n    panel.grid = element_blank(),\n    legend.key.width = unit(5, \"pt\"),\n    plot.margin = margin(0,0,0,5, \"pt\"),\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    axis.text = element_text(size = bts/2)\n  )\n\ng2 &lt;- ggplot() +\n  geom_spatraster(data = rast(hs)) +\n  paletteer::scale_fill_paletteer_c(\"ggthemes::Gray\", -1) +\n  labs(\n    title = \"Basic Hillshader raster\",\n    subtitle = \"Default behaviours of hillshader()\"\n  ) +\n  coord_sf(expand = F, clip = \"off\") +\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    plot.margin = margin(0,5,0,0, \"pt\"),\n    axis.text = element_text(size = bts/2)\n  )\n\ng &lt;- g1 + g2 +\n  plot_annotation(\n    title = \"{hillshader}: A basic example\",\n    caption = plot_caption,\n    theme = theme(\n      plot.title = element_text(\n        hjust = 0.5,\n        family = \"title_font\"\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5,\n        family = \"title_font\"\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"hillshader_package_1.png\"\n  ),\n  height = 1200,\n  width = 1800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nCode\nhimachal_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\",\n    \"India_State_Boundary.shp\"\n  )\n) |&gt; \n  filter(State_Name == \"Himachal Pradesh\") |&gt; \n  st_transform(\"EPSG:4326\")\n\n# ggplot(himachal_vec) +\n#   geom_sf()\n# \n# st_bbox(himachal_vec)\n\nhimachal_rast &lt;- elevatr::get_elev_raster(\n  locations = himachal_vec,\n  z = 7\n) |&gt; \n  rast() |&gt; \n  terra::crop(himachal_vec) |&gt; \n  terra::mask(himachal_vec)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = himachal_rast) +\n  geom_sf(data = himachal_vec, fill = NA) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Himachal Pradesh (India)\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0,0),\n    legend.justification = c(0,0),\n    legend.key.height = unit(10, \"pt\"),\n    legend.title.position = \"top\",\n    legend.direction = \"horizontal\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    )\n  )\n\nplot_himachal &lt;- function(sunangle = 315, sunaltitude = 0){\n  hs &lt;- himachal_rast |&gt; \n    raster() |&gt; \n    hillshader(\n      c(\"ray_shade\", \"ambient_shade\"),\n      sunangle = sunangle,\n      sunaltitude = sunaltitude\n    )\n\n  ggplot() +\n    geom_spatraster(data = rast(hs)) +\n    geom_sf(data = himachal_vec, fill = NA) +\n    paletteer::scale_fill_paletteer_c(\n      \"ggthemes::Classic Gray\", \n      direction = 1,\n      na.value = \"transparent\",\n      trans = \"log2\"\n    ) +\n    labs(\n      title = paste0(\"sunangle: \", sunangle, \n                     \"  ; sunaltitude: \",\n                     sunaltitude)\n    ) +\n    coord_sf(expand = F, clip = \"off\") +\n    theme(\n      legend.position = \"none\",\n      panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n      ),\n      plot.margin = margin(0,5,0,0, \"pt\"),\n      axis.text = element_text(size = bts/2),\n      plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n      plot.subtitle = element_text(\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n}\n\ng2 &lt;- plot_himachal(sunangle = 315, sunaltitude = 0)\n\ng3 &lt;- plot_himachal(sunangle = 90, sunaltitude = 30)\n\ng4 &lt;- plot_himachal(sunangle = 315, sunaltitude = 30)\n\ng5 &lt;- plot_himachal(sunangle = 90, sunaltitude = 60)\n\ng6 &lt;- plot_himachal(sunangle = 315, sunaltitude = 60)\n\ng &lt;- wrap_plots(g1, g2, g3, g4, g5, g6) +\n  plot_layout(\n    ncol = 2,\n    nrow = 3\n  ) +\n  plot_annotation(\n    title = \"Combinations of sun-angle & sun-altitude in {hillshader}\",\n    caption = plot_caption,\n    theme = theme(\n      plot.title = element_text(\n        family = \"title_font\",\n        size = bts * 3,\n        hjust = 0.5,\n        lineheight = 0.3,\n        margin = margin(20,0,0,0, \"pt\")\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"hillshader_package_2.png\"\n  ),\n  height = 4800,\n  width = 3600,\n  units = \"px\",\n  bg = \"white\"\n)"
  },
  {
    "objectID": "geocomputation/hillshader_package.html#another-example-for-a-smaller-area---sikkim-india",
    "href": "geocomputation/hillshader_package.html#another-example-for-a-smaller-area---sikkim-india",
    "title": "Showing elevation in Maps (1) : {hillshader}",
    "section": "Another example for a smaller area - Sikkim (India)",
    "text": "Another example for a smaller area - Sikkim (India)\nThe analysis uses the hillshader package to generate five different hillshade maps of Sikkim, India, by varying the sunangle and sunaltitude parameters. The base map is created by extracting elevation data using elevatr::get_elev_raster() and masking it with the Sikkim state boundary from a shapefile loaded with sf::read_sf(). The function plot_sikkim() applies hillshader() with ray-traced shading techniques (ray_shade and ambient_shade) and visualizes the results using ggplot2::geom_spatraster() for a grayscale effect. Different combinations of sunlight direction (sunangle) and height (sunaltitude) alter the relief perception. The six maps, including an elevation reference, are arranged with patchwork::wrap_plots(), demonstrating how terrain visualization changes under varying lighting conditions.\n\n\nCode\nsikkim_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\",\n    \"India_State_Boundary.shp\"\n  )\n) |&gt; \n  filter(State_Name == \"Sikkim\") |&gt; \n  st_transform(\"EPSG:4326\")\n\nggplot(sikkim_vec) +\n  geom_sf()\n\nst_bbox(sikkim_vec)\n\nsikkim_rast &lt;- elevatr::get_elev_raster(\n  locations = sikkim_vec,\n  z = 7\n) |&gt; \n  rast() |&gt; \n  terra::crop(sikkim_vec) |&gt; \n  terra::mask(sikkim_vec)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = sikkim_rast) +\n  geom_sf(data = sikkim_vec, fill = NA) +\n  scale_fill_wiki_c() +\n  labs(\n    title = \"Sikkim (India)\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0,1),\n    legend.justification = c(0,1),\n    legend.key.height = unit(10, \"pt\"),\n    legend.key.width = unit(30, \"pt\"),\n    legend.title.position = \"top\",\n    legend.direction = \"horizontal\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nplot_sikkim &lt;- function(sunangle = 315, sunaltitude = 0){\n  hs &lt;- sikkim_rast |&gt; \n    raster() |&gt; \n    hillshader(\n      c(\"ray_shade\", \"ambient_shade\"),\n      sunangle = sunangle,\n      sunaltitude = sunaltitude\n    )\n\n  ggplot() +\n    geom_spatraster(data = rast(hs)) +\n    geom_sf(data = sikkim_vec, fill = NA) +\n    paletteer::scale_fill_paletteer_c(\n      \"ggthemes::Classic Gray\", \n      direction = 1,\n      na.value = \"transparent\",\n      trans = \"log2\"\n    ) +\n    labs(\n      title = paste0(\"sunangle: \", sunangle, \n                     \"  ; sunaltitude: \",\n                     sunaltitude)\n    ) +\n    coord_sf(expand = F, clip = \"off\") +\n    theme(\n      legend.position = \"none\",\n      panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n      ),\n      plot.margin = margin(0,5,0,0, \"pt\"),\n      axis.text = element_text(size = bts/2),\n      plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n      plot.subtitle = element_text(\n        margin = margin(0,0,0,0, \"pt\")\n      )\n    )\n}\n\ng2 &lt;- plot_sikkim(sunangle = 315, sunaltitude = 0)\n\ng3 &lt;- plot_sikkim(sunangle = 90, sunaltitude = 30)\n\ng4 &lt;- plot_sikkim(sunangle = 315, sunaltitude = 30)\n\ng5 &lt;- plot_sikkim(sunangle = 90, sunaltitude = 60)\n\ng6 &lt;- plot_sikkim(sunangle = 315, sunaltitude = 60)\n\ng &lt;- wrap_plots(g1, g3, g5, g2, g4, g6) +\n  plot_layout(\n    ncol = 3,\n    nrow = 2\n  ) +\n  plot_annotation(\n    title = \"Combinations of sun-angle & sun-altitude in {hillshader}\",\n    caption = plot_caption,\n    theme = theme(\n      plot.title = element_text(\n        family = \"title_font\",\n        size = bts * 4,\n        hjust = 0.5,\n        lineheight = 0.3,\n        margin = margin(20,0,0,0, \"pt\")\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5,\n        size = bts * 1.5\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"hillshader_package_3.png\"\n  ),\n  height = 5000,\n  width = 4800,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\nThis visualization showcases the impact of varying sun angles and altitudes on hillshade maps of Sikkim, India, using the {hillshader} package. The top-left map represents the original elevation data, while the remaining five maps illustrate different shading effects based on changes in sunangle (direction of sunlight) and sunaltitude (height of the sun above the horizon). By adjusting these parameters, the perception of terrain depth and structure changes, highlighting how light sources influence the visualization of topography."
  },
  {
    "objectID": "geocomputation/whitebox_terra.html",
    "href": "geocomputation/whitebox_terra.html",
    "title": "Showing elevation in Maps (2) : {whitebox} & {terra}",
    "section": "",
    "text": "In this project, we apply hillshade techniques to visualize the topography of Sikkim, India, using digital elevation models (DEMs). Hillshading, a method that simulates shadows cast by terrain, enhances the three-dimensional appearance of elevation data, making it valuable for geospatial analysis through resources like the USGS. This work follows Dr. Dominic Royé’s guide on generating hillshade effects using R, as outlined in Dominic Royé’s Blog.\nWe employ R’s geospatial packages, including terra for raster processing, rayshader for 3D rendering, and elevatr for retrieving elevation data from sources such as NASA’s SRTM. These techniques effectively highlight Sikkim’s complex Himalayan terrain, essential for environmental monitoring, disaster risk assessment, and ecological studies. The approach can also be extended to land-use planning and hydrological modeling.\nCode\n# Data wrangling & visualization\nlibrary(tidyverse)  # Data manipulation & visualization\n\n# Spatial data handling\nlibrary(sf)         # Import, export, and manipulate vector data\nlibrary(terra)      # Import, export, and manipulate raster data\nlibrary(elevatr)    # Access elevation data from APIs\n\n# Geospatial processing\nlibrary(whitebox)   # WhiteboxTools for geospatial analysis\n\n# ggplot2 extensions\nlibrary(tidyterra)  # Helper functions for using terra with ggplot2\nlibrary(ggnewscale) # Support multiple scales in ggplot2\nlibrary(ggblend)    # Enable color blending in ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(colorspace)           # Lighten and Darken colours\nlibrary(patchwork)            # Composing Plots\n\nbts = 18 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Some basic caption stuff\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Tools**: {elevatr} {terra} {tidyterra} in *#rstats* \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)"
  },
  {
    "objectID": "geocomputation/whitebox_terra.html#trying-the-technique-for-sikkim-india",
    "href": "geocomputation/whitebox_terra.html#trying-the-technique-for-sikkim-india",
    "title": "Showing elevation in Maps (2) : {whitebox} & {terra}",
    "section": "Trying the technique for Sikkim (India)",
    "text": "Trying the technique for Sikkim (India)\nThe following code extracts and visualizes geographical features of Sikkim using OpenStreetMap data. The osmdata package is used to fetch water bodies (lakes, ponds) and road networks within the Sikkim state boundary. First, the administrative boundary of Sikkim is read from a shapefile using sf and transformed to EPSG:4326. Then, opq() queries OpenStreetMap for water features (natural = water) and roads (highway key). The top 20 largest lakes are selected based on area, and major roads are filtered. Finally, ggplot2 is used to plot the Sikkim boundary along with lakes.\n\n\nCode\nlibrary(osmdata)        # Fetching lakes data\n\n# Get sikkim administrative boundary data\nsikkim_vec &lt;- read_sf(\n  here::here(\n    \"data\", \"india_map\",\n    \"India_State_Boundary.shp\"\n  )\n) |&gt; \n  filter(State_Name == \"Sikkim\") |&gt; \n  st_transform(\"EPSG:4326\")\n\n# Add lakes, ponds and water bodies\nsikkim_lakes_raw &lt;- opq(bbox = st_bbox(sikkim_vec)) |&gt;\n  add_osm_feature(\n    key = \"natural\",\n    value = c(\"water\")\n  ) |&gt;\n  osmdata_sf()\n\nsikkim_lakes &lt;- bind_rows(\n  sikkim_lakes_raw$osm_polygons,\n  sikkim_lakes_raw$osm_multipolygons\n) |&gt; \n  select(osm_id, geometry) |&gt; \n  st_crop(sikkim_vec) |&gt; \n  mutate(\n    area = st_area(geometry)\n  ) |&gt;\n  slice_max(order_by = area, n = 20)\n\n# Getting roads\nsikkim_roads_raw &lt;- opq(bbox = st_bbox(sikkim_vec)) |&gt;\n  add_osm_feature(\n    key = \"highway\", \n    value = c(\"motorway\", \"trunk\",\n              \"primary\", \"secondary\")\n  ) |&gt;\n  osmdata_sf()\nobject.size(sikkim_roads_raw) |&gt; print(units = \"Mb\")\n\nlevels_roads &lt;- c(\"secondary\", \"primary\", \"trunk\")\n\nsikkim_roads &lt;- sikkim_roads_raw$osm_lines |&gt; \n  select(osm_id, highway, geometry) |&gt; \n  mutate(highway = fct(highway, levels = levels_roads)) |&gt; \n  st_intersection(sikkim_vec)\n\nggplot() +\n  geom_sf(data = sikkim_vec, fill = NA) +\n  geom_sf(data = sikkim_lakes)\n\n\n\nElevation Raster Map\nThe following code visualizes the elevation data of Sikkim, India using the {ggplot2} and {terra} packages. It first plots the vector boundary of Sikkim using {sf} and then retrieves a Digital Elevation Model (DEM) using {elevatr}’s get_elev_raster(). The raster data is then converted to a {terra} object, cropped, and masked to match the Sikkim boundary. Finally, a ggplot2 map is created using geom_spatraster() to visualize elevation with a hypsometric color scale.\n\n\nCode\n# Test plot the sf object: a vector\nggplot(sikkim_vec) +\n  geom_sf(fill = NA) +\n  labs(title = \"Sikkim (India)\")\n\n# Get DEM: Digital Elevation Model of Sikkim from {elevatr}\nsikkim_rast &lt;- elevatr::get_elev_raster(\n  locations = sikkim_vec,\n  z = 9\n) |&gt; \n  terra::rast() |&gt; \n  terra::crop(sikkim_vec) |&gt; \n  terra::mask(sikkim_vec)\n\ng1 &lt;- ggplot() +\n  geom_spatraster(data = sikkim_rast) +\n  geom_sf(data = sikkim_vec, fill = NA) +\n  scale_fill_hypso_c(\n    labels = scales::label_number(\n      scale_cut = cut_short_scale()\n    )\n  ) +\n  labs(\n    title = \"Sikkim (India): Elevation Raster\",\n    subtitle = \"Simple shows elevation through colours. No 3-D or aesthetically impactful representation.\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0,1),\n    legend.justification = c(0,1),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(15, \"pt\"),\n    legend.title.position = \"top\",\n    legend.direction = \"horizontal\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g1,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_1.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\nGrayscale Hillshade with Terrain Data\nThe following code demonstrates how to create a hillshade effect using the terra package for terrain analysis and ggplot2 for visualization. First, it calculates the slope and aspect of a raster dataset, representing terrain elevation. The terra::terrain() function is utilized to estimate both the slope and aspect in radians. Using a specified sun angle and direction, the hillshade effect is generated with the shade() function, providing a grayscale representation of the terrain. Finally, the hillshade is visualized with ggplot2, employing the geom_spatraster() function from the tidyterra package and a grayscale palette from the paletteer package. The plot is saved using ggsave() from the here package for organized file paths.\n\n\nCode\n# Estimate the Slope of the terrain using terra::terrain\nslope1 &lt;- terrain(sikkim_rast, v = \"slope\", unit = \"radians\")\n# Estimate the Aspect or Orientation using terra::terrain\naspect1 &lt;- terrain(sikkim_rast, v = \"aspect\", unit = \"radians\")\n\n# With a certain Sun-Angle and Sun-Direction\nsunangle = 30\nsundirection = 315\n\n# Calculate the hillshade effect with a certain degree of elevation\nsikkim_shade_single &lt;- shade(\n  slope = slope1, \n  aspect = aspect1,\n  angle = sunangle,\n  direction = sundirection,\n  normalize = TRUE\n)\n\n# Final Hill-shade Plot\ng2 &lt;- ggplot() +\n  geom_spatraster(\n    data = sikkim_shade_single\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Light Grays\",\n    na.value = \"transparent\",\n    direction = 1\n  ) +\n  labs(\n    title = \"Hillshade: Uni-directional (in grayscale)\",\n    subtitle = \"Gray-scale aspect and slope for each region as a raster, but this misses elevation completely.\",\n    fill = \"Elevation (metres)\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g2,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_2.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\nUni-directional Shadow: with a Coloured raster map\nThe following code generates a map overlaying a hillshade raster with an elevation raster for Sikkim. The hillshade raster, stored in sikkim_shade_single, is plotted first using geom_spatraster() from the terra package. It is styled using a grayscale palette from paletteer::scale_fill_paletteer_c(). A new fill scale is introduced with ggnewscale::new_scale_fill() before overlaying the elevation raster, sikkim_rast, with scale_fill_hypso_c() for elevation-based coloring. The outer boundary of Sikkim is added using geom_sf().\n\n\nCode\ng3 &lt;- ggplot() +\n  \n  # The shadows part of the raster map\n  geom_spatraster(\n    data = sikkim_shade_single\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Light Grays\",\n    na.value = \"transparent\",\n    direction = 1\n  ) +\n  \n  # New fill scale\n  ggnewscale::new_scale_fill() +\n  \n  # The elevation digital raster\n  geom_spatraster(\n    data = sikkim_rast,\n    alpha = 0.7\n  ) +\n  scale_fill_hypso_c() +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA\n  ) +\n  \n  labs(\n    title = \"Hillshade (Uni-directional) with elevation Raster\",\n    subtitle = \"Shade and Aspect gray-scale raster, with unidirectional shadown, overlaid with translucent elevation coloured raster.\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g3,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_3.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\nMulti-Directional Hillshade with Elevation Raster\nThe following code generates a multi-directional hillshade effect for a raster dataset using the shade() function in the terra package. It applies shading from four different directions (270°, 15°, 60°, and 330°) to enhance topographic visualization. The outputs are combined into a single raster using rast() and summed up to create a composite hillshade. The ggplot2 package is then used to visualize the raster layers, with paletteer providing grayscale shading and ggnewscale enabling a second fill scale for an overlaid elevation raster. The sf package is used to add the outer boundary of Sikkim.\n\n\nCode\n# Multiple directions to shade() function\nsikkim_shade_multi &lt;- map(\n  c(270, 15, 60, 330), \n  function(directions) {\n    shade(\n      slope1, \n      aspect1,\n      angle = 45,\n      direction = directions,\n      normalize = TRUE\n      )\n    }\n  )\n\n# Create a multi-dimensional raster and reduce it by summing up\nsikkim_shade_multi &lt;- rast(sikkim_shade_multi) |&gt; sum()\n\ng4 &lt;- ggplot() +\n  \n  geom_spatraster(\n    data = sikkim_shade_multi\n  ) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Light Grays\",\n    na.value = \"transparent\",\n    direction = 1\n  ) +\n  # New fill scale\n  ggnewscale::new_scale_fill() +\n  \n  # The elevation digital raster\n  geom_spatraster(\n    data = sikkim_rast,\n    alpha = 0.7\n  ) +\n  scale_fill_hypso_c() +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA\n  ) +\n  \n  labs(\n    title = \"Multi-Directional Hillshade (with elevation raster)\",\n    subtitle = \"The shade, with multidirectional slope and aspect, overlaid with translucent elevation raster. Aethetically pleasing.\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g4,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_4.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\nBlending Shades and Elevation Raster using {ggblend}\nThe following code creates a visually appealing map of Sikkim by blending a multidirectional hillshade raster with an elevation raster using {ggblend}. The geom_raster() function is used twice—first to plot the hillshade (sikkim_shade_multi) using a light gray palette from {paletteer}, and then to overlay a semi-transparent digital elevation model (sikkim_rast) with scale_fill_hypso_c(). The {ggnewscale} package allows a new fill scale for the second raster layer. The vector boundary of Sikkim is added using geom_sf(), and the final composition is styled using {ggplot2}’s theme().\n\n\nCode\ntemp_tibble &lt;- sikkim_rast |&gt; as_tibble(xy = T)\nnames(temp_tibble) &lt;- c(\"x\", \"y\", \"alt\")\n\ng5 &lt;- ggplot() +\n\n  (\n    list(  \n      # The shadows part of the raster map\n      geom_raster(\n        data = sikkim_shade_multi |&gt; as.tibble(xy = T),\n        aes(x, y, fill = sum)\n      ),\n      paletteer::scale_fill_paletteer_c(\n        \"grDevices::Light Grays\",\n        na.value = \"transparent\",\n        direction = 1\n      ),\n      \n      # New fill scale\n      ggnewscale::new_scale_fill(),\n      \n      # The elevation digital raster\n      geom_raster(\n        data = temp_tibble,\n        aes(x, y, fill = alt),\n        alpha = 0.7\n      ),\n      scale_fill_hypso_c()\n    ) |&gt; blend(\"multiply\")\n  ) +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA\n  ) +\n  coord_sf() +\n  \n  labs(\n    title = \"Blend shades and elevation raster: {ggblend}\",\n    subtitle = \"The shade, with multidirectional slope and aspect, overlaid with translucent elevation raster. Aethetically pleasing.\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g5,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_5.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\nCreating a Blended Raster Map with Highways in Sikkim\nThe following code generates a visually appealing map of Sikkim by blending multiple raster layers and overlaying highway data. It uses ggplot2 for plotting, paletteer for color scales, and ggnewscale to introduce multiple fill scales. The base raster consists of a multi-directional shaded relief layer (sikkim_shade_multi) and an elevation raster (sikkim_rast), which are blended using the blend(\"multiply\") function. The map also incorporates sf data layers for the Sikkim boundary (sikkim_vec) and major highways (sikkim_roads), with varying linewidths and alpha values set using scale_linewidth_manual() and scale_alpha_manual().\n\n\nCode\ng6 &lt;- ggplot() +\n\n  # A list for blended raster colours\n  (\n    list(  \n      # The shadows part of the raster map\n      geom_raster(\n        data = sikkim_shade_multi |&gt; as.tibble(xy = T),\n        aes(x, y, fill = sum)\n      ),\n      paletteer::scale_fill_paletteer_c(\n        \"grDevices::Light Grays\",\n        na.value = \"white\",\n        direction = 1\n      ),\n      \n      # New fill scale\n      ggnewscale::new_scale_fill(),\n      \n      # The elevation digital raster\n      geom_raster(\n        data = sikkim_rast |&gt; as.tibble(xy = T),\n        aes(x, y, fill = file32e432a33603),\n        alpha = 0.7\n      ),\n      scale_fill_hypso_c()\n    ) |&gt; blend(\"multiply\")\n  ) +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA,\n    colour = \"grey50\"\n  ) +\n  coord_sf() +\n  geom_sf(\n    data = sikkim_roads,\n    mapping = aes(\n      linewidth = highway,\n      alpha = highway\n    )\n  ) +\n  scale_linewidth_manual(\n    values = c(0.2, 0.3, 0.4)\n  ) +\n  scale_alpha_manual(\n    values = c(0.3, 0.5, 0.7)\n  ) +\n  labs(\n    title = \"Adding highways to blended rasters\",\n    subtitle = \"Adding major highways, roads, with the blended, multi-directional shaded raster. Aethetically pleasing.\",\n    x = NULL, y = NULL\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g6,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_6.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 6\n\n\n\n\n\nCreating a Multi-Panel Shaded Relief Map Layout\nThe following code uses the {patchwork} package to arrange multiple ggplot2 plots into a structured layout. It combines six plots (g1 to g6) using wrap_plots(), setting a 2-column by 3-row grid with plot_layout(). The {ggblend} and {terra} packages are referenced in the title to indicate the process of creating blended multidirectional shaded relief maps. The plot_annotation() function adds a title, subtitle, and caption, while theme() customizes text styles and margins.\n\n\nCode\nlibrary(patchwork)\n\ng &lt;- wrap_plots(g1, g2, g3, g4, g5, g6) +\n  plot_layout(\n    ncol = 2,\n    nrow = 3\n  ) +\n  plot_annotation(\n    title = \"Shaded relief maps: {terra} & {ggblend}\",\n    subtitle = \"Different stages in producing a blended multidirectional shaded relief map of hilly areas in R.\",\n    caption = plot_caption,\n    tag_levels = \"I\",\n    theme = theme(\n      plot.title = element_text(\n        margin = margin(20,0,5,0, \"pt\"),\n        size = bts * 6\n      ),\n      plot.subtitle = element_text(\n        margin = margin(0,0,0,0, \"pt\"),\n        size = bts * 3\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5,\n        size = bts * 2,\n        margin = margin(15,0,10,0, \"pt\")\n      )\n    )\n  ) &\n  theme(\n    plot.margin = margin(0,40,0,40, \"pt\"),\n    plot.tag = element_text(\n      size = bts * 4,\n      face = \"bold\",\n      margin = margin(0,30,-40,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_7.png\"\n  ),\n  height = 1200 * 3.2,\n  width = 1200 * 2.5,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 7: A composite plot of the (I) the elevation raster of the height above sea level for the state of Sikkim (India). (II) A grey-scale hillshade graph showing the spect and slope, irrespective of the elevation. (III) The same map, but in a uni-directional shadow, now merged with translucent elevation raster. (IV) With a multi-drectional shade. (V) With a blended (using ggblend) colours from the grayscale shaded relief and coloured elevation raster. And, (VI) the blended raster with overlaid highways and roads."
  },
  {
    "objectID": "geocomputation/whitebox_terra.html#an-alternative-for-shaded-relief-maps-whitebox",
    "href": "geocomputation/whitebox_terra.html#an-alternative-for-shaded-relief-maps-whitebox",
    "title": "Showing elevation in Maps (2) : {whitebox} & {terra}",
    "section": "An alternative for shaded relief maps: {whitebox}",
    "text": "An alternative for shaded relief maps: {whitebox}\nThis R script utilizes the {whitebox} package to generate a hillshade raster from a Digital Elevation Model (DEM) of Sikkim, India. Hillshade is a technique that simulates the illumination of a surface by a light source to accentuate terrain features, enhancing the visualization of topographic relief. The script begins by saving the DEM (sikkim_rast) as a TIFF file, as WhiteboxTools operates on TIFF inputs. It then initializes WhiteboxTools and applies the wbt_hillshade() function, specifying parameters such as azimuth (direction of the light source) and altitude (angle of the light source above the horizon) to control the illumination’s direction and angle. The resulting hillshade raster is subsequently masked using the vector boundaries of Sikkim (sikkim_vec) to limit the visualization to the area of interest. Finally, the script employs {ggplot2} to overlay the hillshade and elevation data, creating a composite map that effectively highlights the terrain’s features.\n\n\nCode\n# Install the package {whitebox}\n# install.packages(\"whitebox\")\n\n# Load the library {whitebox}\nlibrary(whitebox)\n\n# Download the 'WhiteboxTools' binary if needed.\n# install_whitebox()\n\n\n# Since Whitebox tools operate on .tiff files, save the raster\n# as a tiff file first.\n\nterra::writeRaster(\n  x = sikkim_rast, \n  filename = here::here(\"geocomputation\", \"temp_sikkim.tiff\"),\n  overwrite = T\n)\n\n# Launch Whitebox\nwbt_init()\n\nwhitebox::wbt_hillshade(\n  dem = here::here(\"geocomputation\", \"temp_sikkim.tiff\"),\n  output = here::here(\"geocomputation\", \"temp_sikkim1.tiff\"),\n  azimuth = 315,\n  altitude = 20\n)\n\nsikkim_wbt &lt;- rast(\n  here::here(\"geocomputation\", \"temp_sikkim1.tiff\")\n) |&gt; \n  terra::mask(sikkim_vec)\n\ng8 &lt;- ggplot() +\n  \n  # WhiteBox Uni-directional Shadow\n  geom_spatraster(data = sikkim_wbt) +\n  paletteer::scale_fill_paletteer_c(\n    \"grDevices::Light Grays\",\n    na.value = \"transparent\",\n    direction = 1\n  ) +\n  \n  # New fill scale\n  ggnewscale::new_scale_fill() +\n  \n  # The elevation digital raster\n  geom_spatraster(\n    data = sikkim_rast,\n    alpha = 0.7\n  ) +\n  scale_fill_hypso_c() +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA\n  ) +\n  \n  labs(\n    title = \"Uni-Directional Hillshade {whitebox}\",\n    subtitle = \"Control over directions of shadow using arguments altitude and azimuth.\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g8,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_8.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 8\n\n\n\n\nHypsometrically tinted hill-shade\nThe provided R code utilizes the wbt_hypsometrically_tinted_hillshade function from the whitebox package to generate a hypsometrically tinted hillshade image of Sikkim, India. This function creates a color-shaded relief image from an input Digital Elevation Model (DEM) by combining hillshading with hypsometric tinting, which applies colors based on elevation ranges to enhance terrain visualization.\n\n\nCode\nwhitebox::wbt_hypsometrically_tinted_hillshade(\n  dem = here::here(\"geocomputation\", \"temp_sikkim.tiff\"),\n  output = here::here(\"geocomputation\", \"temp_sikkim1.tiff\")\n)\n\nsikkim_wbt &lt;- rast(\n  here::here(\"geocomputation\", \"temp_sikkim1.tiff\")\n) |&gt; \n  terra::mask(sikkim_vec)\n\ng9 &lt;- ggplot() +\n  \n  geom_spatraster_rgb(data = sikkim_wbt) +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA\n  ) +\n  labs(\n    title = \"Hypsometrically tinted hillshade {whitebox}\",\n    subtitle = \"Use in-built colours from geom_spatraster_rgb() without any user specified scale_fill_*()\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g9,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_9.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 9\n\n\n\n\n\nMultidirectional hillshade\nThe provided R code utilizes the whitebox package to generate a multidirectional hillshade raster from a Digital Elevation Model (DEM) of Sikkim, India. The wbt_multidirectional_hillshade function calculates shading by considering illumination from multiple directions, resulting in a more detailed and realistic depiction of the terrain compared to traditional single-direction hillshade methods. In this code, the DEM is processed to produce a hillshade raster, which is then masked using the vector boundaries of Sikkim.\n\n\nCode\nwhitebox::wbt_multidirectional_hillshade(\n  dem = here::here(\"geocomputation\", \"temp_sikkim.tiff\"),\n  output = here::here(\"geocomputation\", \"temp_sikkim1.tiff\"),\n  altitude = 30\n)\n\nsikkim_wbt &lt;- rast(\n  here::here(\"geocomputation\", \"temp_sikkim1.tiff\")\n) |&gt; \n  terra::mask(sikkim_vec)\n\nggsave(\n  plot = g10,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_10.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 10\n\n\n\n\n\nBlended Shades\n\n\nCode\ng12 &lt;- ggplot() +\n  \n  # Start the blending\n  (\n    list(\n      # WhiteBox Multidirectional Shadow\n      geom_spatraster(data = sikkim_wbt),\n      \n      paletteer::scale_fill_paletteer_c(\n        \"grDevices::Light Grays\",\n        na.value = \"transparent\",\n        direction = 1\n      ),\n      \n      # New fill scale\n      ggnewscale::new_scale_fill(),\n      \n      # The elevation digital raster\n      geom_spatraster(\n        data = sikkim_rast,\n        alpha = 0.7\n      ),\n      scale_fill_hypso_c()\n    ) |&gt; blend(\"multiply\")\n  ) +\n  \n  # Outer boundary map of Sikkim\n  geom_sf(\n    data = sikkim_vec,\n    fill = NA\n  ) +\n  \n  labs(\n    title = \"{ggblend} & Multi-Directional {whitebox}\",\n    subtitle = \"Using combination of {whitebox} multidirectional hillshade and {ggblend}.\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n        size = bts * 2,\n        margin = margin(15,0,2,0, \"pt\")\n      ),\n    plot.subtitle = element_text(\n        size = bts,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n    panel.grid = element_line(\n        linewidth = 0.2,\n        linetype = 3\n    ),\n    legend.title = element_text(\n      margin = margin(0,0,2,0, \"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g12,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_12.png\"\n  ),\n  height = 1200,\n  width = 1200,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 11\n\n\n\nCompiling the Plots\n\n\nCode\nlibrary(patchwork)\n\ng1 &lt;- g1 +\n  theme(\n    legend.position = \"bottom\",\n      legend.direction = \"horizontal\",\n      legend.key.height = unit(10, \"pt\"),\n      legend.key.width = unit(120, \"pt\"),\n      legend.title.position = \"top\",\n      legend.text = element_text(\n        size = 3 * bts,\n        margin = margin(2,0,0,0, \"pt\")\n        ),\n      legend.title = element_text(\n        size = 3 * bts,\n        margin = margin(0,0,5,0, \"pt\"),\n        hjust = 0.5\n      )\n  )\ng11 &lt;- wrap_plots(g1, g3, g4, g5, g9, g8, g10, g12) +\n  plot_layout(\n    ncol = 4,\n    nrow = 2,\n    guides = \"collect\"\n  ) +\n  plot_annotation(\n    title = \"Shaded relief maps: {terra} vs. {whitebox}\\nwith & without {ggblend}\",\n    subtitle = str_wrap(\"Comparing the outcomes of {terra} generated shaded maps vs. the {whitebox} generated maps. The first row shows the base elevation raster and {terra} outputs (uni-directional, multi-directional and blended multi-directional), while second row shows the {whitebox} outputs (An RGB hypso-tinted raster, uni-directional, multi-directional and blended multidirectional.)\", 95),\n    caption = plot_caption,\n    tag_levels = \"I\",\n    theme = theme(\n      plot.title = element_text(\n        margin = margin(50,0,10,0, \"pt\"),\n        size = bts * 10,\n        lineheight = 0.3\n      ),\n      plot.subtitle = element_text(\n        margin = margin(0,0,20,0, \"pt\"),\n        size = bts * 4.5\n      ),\n      plot.caption = element_textbox(\n        hjust = 0.5,\n        size = bts * 2,\n        margin = margin(15,0,10,0, \"pt\")\n      ),\n      legend.position = \"bottom\"\n    )\n  ) &\n  theme(\n    plot.margin = margin(0,5,10,5, \"pt\"),\n    plot.tag = element_text(\n      size = bts * 4,\n      face = \"bold\",\n      margin = margin(0,-30,-10,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g11,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"whitebox_terra_11.png\"\n  ),\n  height = 1200 * 4.45,\n  width = 1200 * 3.85,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\nFinal Compilation Plot - Comparing {terra} & {whitebox}\n\n\n\n\n\n\nFigure 12: Final Compilation plot - comparing the two techniques"
  },
  {
    "objectID": "geocomputation/osm_packages.html",
    "href": "geocomputation/osm_packages.html",
    "title": "Different Packages to access Open Street Maps in R",
    "section": "",
    "text": "Code\n# Data wrangling & visualization\nlibrary(tidyverse)  # Data manipulation & visualization\n\n# Spatial data handling\nlibrary(sf)         # Import, export, and manipulate vector data\nlibrary(terra)      # Import, export, and manipulate raster data\n\n# ggplot2 extensions\nlibrary(tidyterra)  # Helper functions for using terra with ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(patchwork)            # Composing Plots\n\nbts = 42 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**:  Open Street Maps through {osmextract}, {geodata} and {elevatr}\",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\nCode\nlibrary(gt)\n\nosm_packages &lt;- tibble::tibble(\n  `Package Name` = c(\n    \"[osmdata](https://github.com/ropensci/osmdata)\",\n    \"[osmapiR](https://github.com/ropensci/osmapiR)\",\n    \"[osmextract](https://github.com/ropensci/osmextract)\",\n    \"[geofabrik](https://cran.r-project.org/package=geofabrik)\"\n  ),\n  `Description` = c(\n    \"Provides an R interface to the Overpass API for querying OSM data.\",\n    \"R interface to the OpenStreetMap API v0.6 for fetching and saving raw geodata.\",\n    \"Downloads, converts, and imports bulk OSM data (.pbf files).\",\n    \"Downloads OSM data from Geofabrik’s regional extracts.\"\n  ),\n  `Advantages` = c(\n    \"Ideal for extracting specific features; flexible Overpass API queries.\",\n    \"Allows fetching, editing, and saving OSM data, including metadata and GPS traces.\",\n    \"Efficiently handles large-scale OSM extracts; supports bulk processing.\",\n    \"Easy access to pre-processed regional OSM extracts; simplifies data handling.\"\n  ),\n  `Disadvantages` = c(\n    \"Rate-limited API; not suited for large datasets.\",\n    \"Not designed for bulk OSM data retrieval; more useful for metadata analysis.\",\n    \"Requires handling large .pbf files; needs external dependencies for conversion.\",\n    \"Limited to available regional extracts; lacks fine-grained filtering.\"\n  )\n)\n\nosm_packages |&gt; \n  gt() |&gt; \n  gtExtras::gt_theme_nytimes() |&gt; \n  fmt_markdown(columns = `Package Name`) |&gt; \n  tab_header(\n    title = \"Comparison of R Packages for Accessing OpenStreetMap Data\"\n  ) |&gt; \n  tab_footnote(\n    footnote = md(\"**Data sources:** OpenStreetMap, Overpass API, Geofabrik, and various R package repositories.\")\n  ) |&gt; \n  tab_style(\n    style = cell_text(font = \"monospace\", weight = \"bold\"),\n    locations = cells_body(\n      columns = `Package Name`\n    )\n  )\n\n\n\n\nTable 1: Comparison of various R packages that facilitate access to OpenStreetMap (OSM) data. Each package serves different purposes, ranging from querying small datasets via the Overpass API to downloading large-scale extracts for bulk processing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparison of R Packages for Accessing OpenStreetMap Data\n\n\nPackage Name\nDescription\nAdvantages\nDisadvantages\n\n\n\n\nosmdata\nProvides an R interface to the Overpass API for querying OSM data.\nIdeal for extracting specific features; flexible Overpass API queries.\nRate-limited API; not suited for large datasets.\n\n\nosmapiR\nR interface to the OpenStreetMap API v0.6 for fetching and saving raw geodata.\nAllows fetching, editing, and saving OSM data, including metadata and GPS traces.\nNot designed for bulk OSM data retrieval; more useful for metadata analysis.\n\n\nosmextract\nDownloads, converts, and imports bulk OSM data (.pbf files).\nEfficiently handles large-scale OSM extracts; supports bulk processing.\nRequires handling large .pbf files; needs external dependencies for conversion.\n\n\ngeofabrik\nDownloads OSM data from Geofabrik’s regional extracts.\nEasy access to pre-processed regional OSM extracts; simplifies data handling.\nLimited to available regional extracts; lacks fine-grained filtering.\n\n\n\nData sources: OpenStreetMap, Overpass API, Geofabrik, and various R package repositories."
  },
  {
    "objectID": "geocomputation/osm_packages.html#introduction",
    "href": "geocomputation/osm_packages.html#introduction",
    "title": "Different Packages to access Open Street Maps in R",
    "section": "",
    "text": "Code\n# Data wrangling & visualization\nlibrary(tidyverse)  # Data manipulation & visualization\n\n# Spatial data handling\nlibrary(sf)         # Import, export, and manipulate vector data\nlibrary(terra)      # Import, export, and manipulate raster data\n\n# ggplot2 extensions\nlibrary(tidyterra)  # Helper functions for using terra with ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(patchwork)            # Composing Plots\n\nbts = 42 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Data**:  Open Street Maps through {osmextract}, {geodata} and {elevatr}\",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\nCode\nlibrary(gt)\n\nosm_packages &lt;- tibble::tibble(\n  `Package Name` = c(\n    \"[osmdata](https://github.com/ropensci/osmdata)\",\n    \"[osmapiR](https://github.com/ropensci/osmapiR)\",\n    \"[osmextract](https://github.com/ropensci/osmextract)\",\n    \"[geofabrik](https://cran.r-project.org/package=geofabrik)\"\n  ),\n  `Description` = c(\n    \"Provides an R interface to the Overpass API for querying OSM data.\",\n    \"R interface to the OpenStreetMap API v0.6 for fetching and saving raw geodata.\",\n    \"Downloads, converts, and imports bulk OSM data (.pbf files).\",\n    \"Downloads OSM data from Geofabrik’s regional extracts.\"\n  ),\n  `Advantages` = c(\n    \"Ideal for extracting specific features; flexible Overpass API queries.\",\n    \"Allows fetching, editing, and saving OSM data, including metadata and GPS traces.\",\n    \"Efficiently handles large-scale OSM extracts; supports bulk processing.\",\n    \"Easy access to pre-processed regional OSM extracts; simplifies data handling.\"\n  ),\n  `Disadvantages` = c(\n    \"Rate-limited API; not suited for large datasets.\",\n    \"Not designed for bulk OSM data retrieval; more useful for metadata analysis.\",\n    \"Requires handling large .pbf files; needs external dependencies for conversion.\",\n    \"Limited to available regional extracts; lacks fine-grained filtering.\"\n  )\n)\n\nosm_packages |&gt; \n  gt() |&gt; \n  gtExtras::gt_theme_nytimes() |&gt; \n  fmt_markdown(columns = `Package Name`) |&gt; \n  tab_header(\n    title = \"Comparison of R Packages for Accessing OpenStreetMap Data\"\n  ) |&gt; \n  tab_footnote(\n    footnote = md(\"**Data sources:** OpenStreetMap, Overpass API, Geofabrik, and various R package repositories.\")\n  ) |&gt; \n  tab_style(\n    style = cell_text(font = \"monospace\", weight = \"bold\"),\n    locations = cells_body(\n      columns = `Package Name`\n    )\n  )\n\n\n\n\nTable 1: Comparison of various R packages that facilitate access to OpenStreetMap (OSM) data. Each package serves different purposes, ranging from querying small datasets via the Overpass API to downloading large-scale extracts for bulk processing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparison of R Packages for Accessing OpenStreetMap Data\n\n\nPackage Name\nDescription\nAdvantages\nDisadvantages\n\n\n\n\nosmdata\nProvides an R interface to the Overpass API for querying OSM data.\nIdeal for extracting specific features; flexible Overpass API queries.\nRate-limited API; not suited for large datasets.\n\n\nosmapiR\nR interface to the OpenStreetMap API v0.6 for fetching and saving raw geodata.\nAllows fetching, editing, and saving OSM data, including metadata and GPS traces.\nNot designed for bulk OSM data retrieval; more useful for metadata analysis.\n\n\nosmextract\nDownloads, converts, and imports bulk OSM data (.pbf files).\nEfficiently handles large-scale OSM extracts; supports bulk processing.\nRequires handling large .pbf files; needs external dependencies for conversion.\n\n\ngeofabrik\nDownloads OSM data from Geofabrik’s regional extracts.\nEasy access to pre-processed regional OSM extracts; simplifies data handling.\nLimited to available regional extracts; lacks fine-grained filtering.\n\n\n\nData sources: OpenStreetMap, Overpass API, Geofabrik, and various R package repositories."
  },
  {
    "objectID": "geocomputation/osm_packages.html#osmextract",
    "href": "geocomputation/osm_packages.html#osmextract",
    "title": "Different Packages to access Open Street Maps in R",
    "section": "osmextract",
    "text": "osmextract\nThe {osmextract} package in R provides an efficient way to download and extract OpenStreetMap (OSM) data in a structured format. It allows users to retrieve spatial data such as points, lines, and polygons for specific geographic regions, making it useful for mapping, geospatial analysis, and urban studies. The package integrates well with {sf} to handle spatial objects and supports various file formats for seamless data extraction.\nIn the code provided, {osmextract} is used to fetch OSM data for Haryana in three layers: points, lines, and polygons. The {sf} package is used to manage and manipulate spatial vector data, converting extracted data into simple features. {geodata} helps in retrieving administrative boundaries from the GADM database.\n\n\nCode\n# Load necessary libraries\nlibrary(osmextract)\nlibrary(sf)\n\n# Download and extract the data\n# Points\npoints_haryana &lt;- oe_get(\n  place = \"Haryana\",\n  layer = \"points\"\n)\n\n# Lines\nlines_haryana &lt;- oe_get(\n  place = \"Haryana\",\n  layer = \"lines\"\n)\n\n# Polygons\npolygons_haryana &lt;- oe_get(\n  place = \"Haryana\",\n  layer = \"multipolygons\"\n)\n\n# Get Haryana Map from GADM / {geodata} with geodata::gadm()\n# District Wise Map\nharyana_map &lt;- geodata::gadm(\n  country = \"India\",\n  level = 2,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names() |&gt; \n  filter(name_1 == \"Haryana\") |&gt; \n  rename(district = name_2) |&gt; \n  select(district, geometry)\n\n# Overall Boundary Map\nharyana_boundary &lt;- geodata::gadm(\n  country = \"India\",\n  level = 1,\n  path = tempdir()\n) |&gt; \n  st_as_sf() |&gt; \n  janitor::clean_names() |&gt; \n  filter(name_1 == \"Haryana\") |&gt; \n  select(geometry)\n\n\n\nCanals of Haryana\nIn this analysis, additional packages are used to enhance data extraction, processing, and visualization. The {elevatr} package is utilized to retrieve elevation raster data for Haryana. The {stringr} package is employed to extract numeric values from text-based attributes, such as canal width from OSM tags. The {tidyterra} package is indirectly referenced through geom_spatraster(), facilitating the inclusion of raster elevation data. Additionally, {sf} remains central for spatial vector data processing, and {geodata} continues to provide administrative boundaries from the GADM database. The final map effectively presents Haryana’s irrigation canal network overlaid on an elevation raster with clear administrative boundaries.\n\n\nCode\nst_crs(points_haryana)\n\n# Background raster for Haryana\n# world_cbhsr_rast &lt;- rnaturalearth::ne_download(\n#   scale = 50,\n#   type = \"HYP_50M_SR\",\n#   category = \"raster\"\n# )\n\nraster_haryana &lt;- elevatr::get_elev_raster(\n  locations = haryana_boundary,\n  z = 9\n) |&gt; \n  terra::rast() |&gt; \n  terra::crop(haryana_boundary) |&gt; \n  terra::mask(haryana_boundary)\n\ncanals_haryana &lt;- lines_haryana |&gt; \n  filter(waterway == \"canal\") |&gt; \n  select(osm_id, name, other_tags, geometry) |&gt; \n  mutate(width = str_extract(\n    other_tags, '(?&lt;=\\\\\"width\\\\\"=&gt;\\\\\")\\\\d+(?=\\\\\")'),\n    width = parse_number(width)\n  ) |&gt; \n  st_intersection(haryana_boundary)\n\ng &lt;- ggplot() +\n  geom_spatraster(\n    data = raster_haryana\n  ) +\n  scale_fill_gradient(\n    high = \"grey0\", \n    low = \"grey90\",\n    na.value = \"transparent\",\n    trans = \"log2\",\n    breaks = c(200, 400, 600, 1000)\n    ) +\n  geom_sf(\n    data = haryana_map,\n    fill = NA,\n    colour = \"white\"\n  ) +\n  geom_sf(\n    data = haryana_boundary,\n    colour = \"grey20\",\n    fill = NA,\n    linewidth = 0.7\n  ) +\n  geom_sf(\n    data = canals_haryana,\n    # mapping = aes(linewidth = length),\n    colour = \"blue\"\n  ) +\n  # scale_linewidth_continuous(\n  #   range = c(0.1, 4)\n  # )\n  labs(\n    title = \"Irrigation Canal Network in Haryana (India)\",\n    subtitle = \"Administrative Maps from GADM through {geodata},\\nand elevation raster from {elevatr}\",\n    fill = \"Elevation (above sea level) (metres)\"\n  ) +\n  theme(\n    legend.position = \"inside\",\n    panel.grid = element_line(\n      linewidth = 0.1\n    ),\n    legend.position.inside = c(0, 0),\n    legend.justification = c(0, 0),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    legend.margin = margin(0,0,0,0, \"pt\"),\n    legend.box.margin = margin(0,0,0,0, \"pt\"),\n    legend.key.height = unit(5, \"pt\"),\n    legend.key.width = unit(40, \"pt\"),\n    legend.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,2,0,\"pt\")\n    ),\n    legend.text = element_text(\n      margin = margin(1,0,0,0, \"pt\")\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n    \"osm_packages_1.png\"\n  ),\n  height = 2400,\n  width = 1800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Haryana’s irrigation canal network overlaid on an elevation raster with clear administrative boundaries.\n\n\n\n\n\nHealth Facilities\n\n\nCode\n# Health Care Facilties (as points)\npoints_haryana |&gt; \n  as_tibble() |&gt; \n  filter(str_detect(other_tags, \"health|hospital|pharmacy|clinic\")) |&gt; \n  ggplot() +\n  geom_sf(\n    aes(geometry = geometry)\n  )\n\n#\nnames(lines_haryana)"
  },
  {
    "objectID": "geocomputation/rnaturalearth_package.html",
    "href": "geocomputation/rnaturalearth_package.html",
    "title": "Exploring the package {rnaturalearth} in R",
    "section": "",
    "text": "Code\n# Data wrangling & visualization\nlibrary(tidyverse)  # Data manipulation & visualization\n\n# Spatial data handling\nlibrary(sf)         # Import, export, and manipulate vector data\nlibrary(terra)      # Import, export, and manipulate raster data\n\n# ggplot2 extensions\nlibrary(tidyterra)  # Helper functions for using terra with ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(patchwork)            # Composing Plots\n\n# Package to explore\nlibrary(rnaturalearth)        # Open Source Geographic data\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Tools**: {rnaturalearth}  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\n\n\nCode\nworld1 &lt;- rnaturalearth::ne_countries(\n  scale = \"medium\",\n  returnclass = \"sf\"\n)\n\ng &lt;- ggplot(world1) +\n  geom_sf(\n    fill = alpha(\"grey\", 0.8), colour = \"grey30\",\n    linewidth = 0.1\n  ) +\n  coord_sf(\n    crs = \"ESRI:54030\"\n  ) +\n  labs(\n    title = \"Basic world map with ne_countries()\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5\n    ),\n    panel.grid = element_line(\n      linewidth = 0.05, \n      colour = \"grey20\",\n      linetype = 2\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_1.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Basic World map with ne_countries()\n\n\n\n\n\n\n\n\nCode\nworld1 &lt;- rnaturalearth::ne_coastline(\n  scale = \"medium\",\n  returnclass = \"sf\"\n)\n\ng &lt;- ggplot(world1) +\n  geom_sf(\n    fill = alpha(\"grey\", 0.8), colour = \"grey30\",\n    linewidth = 0.1\n  ) +\n  coord_sf(\n    crs = \"ESRI:54030\"\n  ) +\n  labs(\n    title = \"Basic Coastline map with ne_coastline()\",\n    subtitle = \"Multi-linestring class of {sf} objects\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5\n    ),\n    panel.grid = element_line(\n      linewidth = 0.05, \n      colour = \"grey20\",\n      linetype = 2\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_2.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\nEntire world water bodies as 1 (or 2, for Caspian Sea) multipolygons. Useful for plotting flight paths, when we don’t want oceans to be transparent in Azimuthal Equal Area projections.\n\n\nCode\n# Link: https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/physical/ne_110m_ocean.zip\n\nworld_oceans &lt;- ne_download(\n  scale = 50,\n  type = \"ocean\",\n  category = \"physical\",\n  returnclass = \"sf\"\n)\n\ng &lt;- ggplot(world_oceans) +\n  geom_sf(\n    fill = alpha(\"grey\", 0.5),\n    linewidth = 0.1\n  ) +\n  coord_sf(crs = \"ESRI:54030\") +\n  labs(\n    title = \"World Oceans\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5,\n      size = 18\n    ),\n    panel.grid = element_line(\n      linewidth = 0.05, \n      colour = \"grey20\",\n      linetype = 2\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_3.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nCode\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_geographic_lines.zip\n\nworld_map &lt;- ne_countries(\n  scale = 110,\n  returnclass = \"sf\"\n) |&gt; \n  select(name, geometry)\n\nworld_lines &lt;- ne_download(\n  scale = 50,\n  type = \"geographic_lines\",\n  returnclass = \"sf\",\n  category = \"physical\"\n) |&gt; \n  select(name) |&gt; \n  mutate(\n    high_var = name == \"International Date Line\"\n  )\n\ng &lt;- ggplot() +\n  geom_sf(\n    data = world_map,\n    fill = alpha(\"grey\", 0.5),\n    linewidth = 0.1\n  ) +\n  geom_sf(\n    data = world_lines,\n    mapping = aes(\n      linewidth = high_var,\n      alpha = high_var\n    ),\n    colour = \"darkred\",\n    linetype = 1,\n    lineend = \"round\"\n  ) +\n  scale_alpha_manual(values = c(0.4, 0.8)) +\n  scale_linewidth_manual(values = c(0.2, 0.4)) +\n  coord_sf(\n    crs = paste0(\n        \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n        180, \n        \" +lat_0=\", \n        0)\n    ) +\n  labs(\n    title = \"International Date Line\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5,\n      size = 18\n    ),\n    panel.grid = element_blank(),\n    legend.position = \"none\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_4.png\"\n  ),\n  height = 500,\n  width = 500,\n  units = \"px\"\n)\n\n\n\n\n\n\nIn this case, we are downloading the 50m Cross Blended Hypsometric Tints with Shaded Relief dataset, which combines elevation-based color shading with hillshade effects to enhance terrain visualization. This dataset is ideal for creating aesthetically pleasing and informative background maps in ggplot2 with tidyterra, providing a smooth, global-scale representation of landforms.\n\n\nCode\n# Link to data: https://www.naturalearthdata.com/downloads/50m-raster-data/50m-cross-blend-hypso\n\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/raster/HYP_50M_SR.zip\n\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/raster/HYP_50M_SR_W.zip\n\nworld_cbhsr_rast &lt;- ne_download(\n  scale = 50,\n  type = \"HYP_50M_SR_W\",\n  category = \"raster\"\n)\n\ntemp_rast &lt;- world_cbhsr_rast |&gt; \n  aggregate(fact = 2) |&gt; \n  project(\"ESRI:54030\")\ng &lt;- ggplot() +\n  geom_spatraster_rgb(\n    data = temp_rast,\n    maxcell = 5e6\n  ) +\n  labs(\n    title = \"World Map as a SpatRaster:\\n50m Cross Blended Hypsometric Tints with Shaded Relief and Water\"\n  ) \n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_5.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\nChanging the CRS to Azimuthal Equal Area Projection around Equator and IDL cross-point.\n\n\nCode\ntemp_crs &lt;- paste0(\n  \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n  180,          # Longitude\n  \" +lat_0=\", \n  0             # Latitude\n)\n\ntemp_rast &lt;- world_cbhsr_rast |&gt; \n  terra::aggregate(fact = 10) |&gt; \n  terra::project(temp_crs)\n\ng &lt;- ggplot() +\n  geom_spatraster_rgb(\n    data = temp_rast\n  ) +\n  geom_sf(\n    data = world_lines,\n    mapping = aes(\n      linewidth = high_var,\n      alpha = high_var\n    ),\n    colour = \"darkred\",\n    linetype = 1,\n    lineend = \"round\"\n  ) +\n  scale_alpha_manual(values = c(0.4, 0.8)) +\n  scale_linewidth_manual(values = c(0.2, 0.4)) +\n  coord_sf(\n    crs = \n    ) +\n  labs(\n    title = \"International Date Line\\nwith background Raster Map\"\n  ) +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5, size = 12\n    ),\n    panel.grid = element_blank(),\n    legend.position = \"none\"\n  )\n\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_6.png\"\n  ),\n  height = 500,\n  width = 500,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nCode\n# Basic World Maps (repeat of previous code)\nworld_map &lt;- ne_countries(\n  scale = 110,\n  returnclass = \"sf\"\n) |&gt; \n  select(name, geometry)\n\nworld_lines &lt;- ne_download(\n  scale = 50,\n  type = \"geographic_lines\",\n  returnclass = \"sf\",\n  category = \"physical\"\n) |&gt; \n  select(name) |&gt; \n  mutate(\n    high_var = name == \"International Date Line\"\n  )\n\nworld_oceans &lt;- ne_download(\n  scale = 50,\n  type = \"ocean\",\n  category = \"physical\",\n  returnclass = \"sf\"\n) \n\n# Number of flight path points to treat as intermediate between \n# Singapore and New York City\nnum_points &lt;- 20\n\nflight1 &lt;- tibble::tibble(\n  name = c(\"Singapore Changi Airport\", \n           \"New York JFK Airport\"),\n  longitude = c(103.994003, -73.7781),\n  latitude = c(1.364420, 40.6413)\n)\n\nflight2 &lt;- flight1 |&gt; \n  st_as_sf(\n    coords = c(\"longitude\", \"latitude\"),\n    crs = \"EPSG:4326\"\n  )\n\nflight_path &lt;- geosphere::gcIntermediate(\n  p1 = c(flight1$longitude[1], flight1$latitude[1]),\n  p2 = c(flight1$longitude[2], flight1$latitude[2]),\n  n = num_points,\n  addStartEnd = TRUE\n) |&gt; \n  as_tibble()\n\nflight_path_sf &lt;- flight_path |&gt;\n  st_as_sf(\n    coords = c(\"lon\", \"lat\"),\n    crs = \"EPSG:4326\"\n  ) |&gt; \n  st_combine() |&gt; \n  st_cast(\"LINESTRING\")\n\n\n# Points to plot\nplot_points &lt;- c(1, num_points %/% 3, \n                 2*num_points %/% 3, num_points)\n\nfor (i in plot_points){\n  \n  temp_crs &lt;- paste0(\n    \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n    flight_path$lon[i],          # Longitude\n    \" +lat_0=\", \n    flight_path$lat[i]            # Latitude\n  )\n  \n  temp_rast &lt;- world_cbhsr_rast |&gt; \n    terra::aggregate(fact = 10) |&gt; \n    terra::project(temp_crs)\n  \npaste0(\"g\", i) |&gt; \n  assign(\n    ggplot() +\n      geom_spatraster_rgb(\n        data = temp_rast\n      ) +\n      # geom_sf(\n      #   data = world_map,\n      #   fill = \"#e0ca22\",\n      #   colour = NA,\n      #   linewidth = 0.01\n      # ) +\n      # geom_sf(\n      #   data = world_oceans,\n      #   fill = \"skyblue\",\n      #   colour = NA\n      # ) +\n      geom_sf(\n        data = flight_path_sf, \n        colour = \"red\",\n        linewidth = 0.3\n        ) +\n      geom_sf(\n        data = flight2,\n        size = 1,\n        colour = \"darkred\"\n      ) +\n      coord_sf(\n        crs = temp_crs\n      ) +\n      theme(\n        plot.title = element_textbox(\n          hjust = 0.5, \n          halign = 0.5\n        ),\n        panel.grid = element_line(\n          linewidth = 0.05, \n          colour = \"grey80\",\n          linetype = 1\n        )\n      )\n  )\n  \n}\n\ng &lt;- g1 + g6 + g12 + g20 +\n  plot_annotation(\n    title = \"Static Flight Path: Singapore to New York City\",\n    theme = theme(\n      plot.title = element_text(\n        size = 2 * 12,\n        margin = margin(5,0,0,0, \"pt\")\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_7.png\"\n  ),\n  height = 1000,\n  width = 1000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nCode\nworld_agg_rast &lt;- world_cbhsr_rast |&gt; \n    terra::aggregate(fact = 10)\n\n\n# Number of flight path points to treat as intermediate between \n# Singapore and New York City\nnum_points &lt;- 20\n\nflight1 &lt;- tibble::tibble(\n  name = c(\"Singapore Changi Airport\", \n           \"New York JFK Airport\"),\n  longitude = c(103.994003, -73.7781),\n  latitude = c(1.364420, 40.6413)\n)\n\nflight2 &lt;- flight1 |&gt; \n  st_as_sf(\n    coords = c(\"longitude\", \"latitude\"),\n    crs = \"EPSG:4326\"\n  )\n\nflight_path &lt;- geosphere::gcIntermediate(\n  p1 = c(flight1$longitude[1], flight1$latitude[1]),\n  p2 = c(flight1$longitude[2], flight1$latitude[2]),\n  n = num_points,\n  addStartEnd = TRUE\n) |&gt; \n  as_tibble()\n\nflight_path_sf &lt;- flight_path |&gt;\n  st_as_sf(\n    coords = c(\"lon\", \"lat\"),\n    crs = \"EPSG:4326\"\n  ) |&gt; \n  st_combine() |&gt; \n  st_cast(\"LINESTRING\")\n\nlibrary(magick)\nlibrary(animation)\n\ni = 10\n\nanimation::saveGIF(\n  \n  expr = for (i in 1:nrow(flight_path)) {\n    temp_crs &lt;- paste0(\n      \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n      flight_path$lon[i],          # Longitude\n      \" +lat_0=\", \n      flight_path$lat[i]            # Latitude\n    )\n  \n    temp_rast &lt;- world_agg_rast |&gt; \n      terra::project(temp_crs)\n  \n    ggplot() +\n      geom_spatraster_rgb(\n        data = temp_rast,\n        maxcell = 5e+4\n      ) +\n      geom_sf(\n        data = flight_path_sf, \n        colour = \"red\",\n        linewidth = 0.3\n        ) +\n      geom_sf(\n        data = flight2,\n        size = 0.6,\n        colour = \"darkred\"\n      ) +\n      geom_sf(\n        data = flight_path |&gt; \n                  slice(i) |&gt; \n                  st_as_sf(coords = c(\"lon\", \"lat\"),\n                           crs = \"EPSG:4326\"),\n        size = 1,\n        colour = \"grey20\"\n      ) +\n      coord_sf(\n        crs = temp_crs\n      )\n  },\n  movie.name = here::here(\n    \"geocomputation\", \"images\",\n    \"rnaturalearth_package_1.gif\"\n  ),\n  ani.height = 500,\n  ani.width = 500,\n  ani.loop = TRUE,\n  interval = 1\n)\n\n\n\n\n\n\n\nCode\n# Get border map of Uttarakhand\nuk_state = ne_states(country = \"India\", returnclass = \"sf\") |&gt; \n  select(iso_3166_2, name, geometry) |&gt; \n  filter(name == \"Uttarakhand\")\n\n\n# Get Rivers of Uttarakhand\n# https://www.naturalearthdata.com/downloads/50m-physical-vectors/\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_rivers_lake_centerlines.zip\nuk_rivers &lt;- ne_download(\n  scale = 10,\n  type = \"rivers_lake_centerlines\",\n  category = \"physical\",\n  returnclass = \"sf\"\n) |&gt; \n  st_intersection(uk_state)\n\n# Get Lakes of Uttarakhand\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_lakes.zip\nuk_lakes &lt;- ne_download(\n  scale = 50,\n  type = \"lakes\",\n  category = \"physical\",\n  returnclass = \"sf\"\n)\n\nuk_lakes |&gt; \n  ggplot() +\n  geom_sf()\n\nuk_rivers |&gt; \n  ggplot() +\n  geom_sf()\n\nuk_state |&gt; \n  ggplot() +\n  geom_sf()"
  },
  {
    "objectID": "geocomputation/rnaturalearth_package.html#introduction",
    "href": "geocomputation/rnaturalearth_package.html#introduction",
    "title": "Exploring the package {rnaturalearth} in R",
    "section": "",
    "text": "Code\n# Data wrangling & visualization\nlibrary(tidyverse)  # Data manipulation & visualization\n\n# Spatial data handling\nlibrary(sf)         # Import, export, and manipulate vector data\nlibrary(terra)      # Import, export, and manipulate raster data\n\n# ggplot2 extensions\nlibrary(tidyterra)  # Helper functions for using terra with ggplot2\n\n# Final plot tools\nlibrary(scales)               # Nice Scales for ggplot2\nlibrary(fontawesome)          # Icons display in ggplot2\nlibrary(ggtext)               # Markdown text in ggplot2\nlibrary(showtext)             # Display fonts in ggplot2\nlibrary(patchwork)            # Composing Plots\n\n# Package to explore\nlibrary(rnaturalearth)        # Open Source Geographic data\n\nbts = 12 # Base Text Size\nsysfonts::font_add_google(\"Roboto Condensed\", \"body_font\")\nsysfonts::font_add_google(\"Oswald\", \"title_font\")\nshowtext::showtext_auto()\n# A base Colour\nbg_col &lt;- \"white\"\nseecolor::print_color(bg_col)\n\n# Colour for highlighted text\ntext_hil &lt;- \"grey30\"\nseecolor::print_color(text_hil)\n\n# Colour for the text\ntext_col &lt;- \"grey20\"\nseecolor::print_color(text_col)\n\ntheme_set(\n  theme_minimal(\n    base_size = bts,\n    base_family = \"body_font\"\n  ) +\n    theme(\n      text = element_text(\n        colour = \"grey30\",\n        lineheight = 0.3,\n        margin = margin(0,0,0,0, \"pt\")\n      ),\n      plot.title = element_text(\n        hjust = 0.5\n      ),\n      plot.subtitle = element_text(\n        hjust = 0.5\n      )\n    )\n)\n\n# Caption stuff for the plot\nsysfonts::font_add(\n  family = \"Font Awesome 6 Brands\",\n  regular = here::here(\"docs\", \"Font Awesome 6 Brands-Regular-400.otf\")\n)\ngithub &lt;- \"&#xf09b\"\ngithub_username &lt;- \"aditya-dahiya\"\nxtwitter &lt;- \"&#xe61b\"\nxtwitter_username &lt;- \"@adityadahiyaias\"\nsocial_caption_1 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{github};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{github_username}  &lt;/span&gt;\")\nsocial_caption_2 &lt;- glue::glue(\"&lt;span style='font-family:\\\"Font Awesome 6 Brands\\\";'&gt;{xtwitter};&lt;/span&gt; &lt;span style='color: {text_hil}'&gt;{xtwitter_username}&lt;/span&gt;\")\nplot_caption &lt;- paste0(\n  \"**Tools**: {rnaturalearth}  \",\n  \"  |  **Code:** \", \n  social_caption_1, \n  \" |  **Graphics:** \", \n  social_caption_2\n  )\nrm(github, github_username, xtwitter, \n   xtwitter_username, social_caption_1, \n   social_caption_2)\n\n\n\n\n\n\nCode\nworld1 &lt;- rnaturalearth::ne_countries(\n  scale = \"medium\",\n  returnclass = \"sf\"\n)\n\ng &lt;- ggplot(world1) +\n  geom_sf(\n    fill = alpha(\"grey\", 0.8), colour = \"grey30\",\n    linewidth = 0.1\n  ) +\n  coord_sf(\n    crs = \"ESRI:54030\"\n  ) +\n  labs(\n    title = \"Basic world map with ne_countries()\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5\n    ),\n    panel.grid = element_line(\n      linewidth = 0.05, \n      colour = \"grey20\",\n      linetype = 2\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_1.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Basic World map with ne_countries()\n\n\n\n\n\n\n\n\nCode\nworld1 &lt;- rnaturalearth::ne_coastline(\n  scale = \"medium\",\n  returnclass = \"sf\"\n)\n\ng &lt;- ggplot(world1) +\n  geom_sf(\n    fill = alpha(\"grey\", 0.8), colour = \"grey30\",\n    linewidth = 0.1\n  ) +\n  coord_sf(\n    crs = \"ESRI:54030\"\n  ) +\n  labs(\n    title = \"Basic Coastline map with ne_coastline()\",\n    subtitle = \"Multi-linestring class of {sf} objects\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5\n    ),\n    panel.grid = element_line(\n      linewidth = 0.05, \n      colour = \"grey20\",\n      linetype = 2\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_2.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\nEntire world water bodies as 1 (or 2, for Caspian Sea) multipolygons. Useful for plotting flight paths, when we don’t want oceans to be transparent in Azimuthal Equal Area projections.\n\n\nCode\n# Link: https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/physical/ne_110m_ocean.zip\n\nworld_oceans &lt;- ne_download(\n  scale = 50,\n  type = \"ocean\",\n  category = \"physical\",\n  returnclass = \"sf\"\n)\n\ng &lt;- ggplot(world_oceans) +\n  geom_sf(\n    fill = alpha(\"grey\", 0.5),\n    linewidth = 0.1\n  ) +\n  coord_sf(crs = \"ESRI:54030\") +\n  labs(\n    title = \"World Oceans\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5,\n      size = 18\n    ),\n    panel.grid = element_line(\n      linewidth = 0.05, \n      colour = \"grey20\",\n      linetype = 2\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_3.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nCode\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_geographic_lines.zip\n\nworld_map &lt;- ne_countries(\n  scale = 110,\n  returnclass = \"sf\"\n) |&gt; \n  select(name, geometry)\n\nworld_lines &lt;- ne_download(\n  scale = 50,\n  type = \"geographic_lines\",\n  returnclass = \"sf\",\n  category = \"physical\"\n) |&gt; \n  select(name) |&gt; \n  mutate(\n    high_var = name == \"International Date Line\"\n  )\n\ng &lt;- ggplot() +\n  geom_sf(\n    data = world_map,\n    fill = alpha(\"grey\", 0.5),\n    linewidth = 0.1\n  ) +\n  geom_sf(\n    data = world_lines,\n    mapping = aes(\n      linewidth = high_var,\n      alpha = high_var\n    ),\n    colour = \"darkred\",\n    linetype = 1,\n    lineend = \"round\"\n  ) +\n  scale_alpha_manual(values = c(0.4, 0.8)) +\n  scale_linewidth_manual(values = c(0.2, 0.4)) +\n  coord_sf(\n    crs = paste0(\n        \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n        180, \n        \" +lat_0=\", \n        0)\n    ) +\n  labs(\n    title = \"International Date Line\"\n  ) +\n  theme(\n    plot.title = element_textbox(\n      hjust = 0.5, \n      halign = 0.5,\n      size = 18\n    ),\n    panel.grid = element_blank(),\n    legend.position = \"none\"\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_4.png\"\n  ),\n  height = 500,\n  width = 500,\n  units = \"px\"\n)\n\n\n\n\n\n\nIn this case, we are downloading the 50m Cross Blended Hypsometric Tints with Shaded Relief dataset, which combines elevation-based color shading with hillshade effects to enhance terrain visualization. This dataset is ideal for creating aesthetically pleasing and informative background maps in ggplot2 with tidyterra, providing a smooth, global-scale representation of landforms.\n\n\nCode\n# Link to data: https://www.naturalearthdata.com/downloads/50m-raster-data/50m-cross-blend-hypso\n\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/raster/HYP_50M_SR.zip\n\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/raster/HYP_50M_SR_W.zip\n\nworld_cbhsr_rast &lt;- ne_download(\n  scale = 50,\n  type = \"HYP_50M_SR_W\",\n  category = \"raster\"\n)\n\ntemp_rast &lt;- world_cbhsr_rast |&gt; \n  aggregate(fact = 2) |&gt; \n  project(\"ESRI:54030\")\ng &lt;- ggplot() +\n  geom_spatraster_rgb(\n    data = temp_rast,\n    maxcell = 5e6\n  ) +\n  labs(\n    title = \"World Map as a SpatRaster:\\n50m Cross Blended Hypsometric Tints with Shaded Relief and Water\"\n  ) \n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_5.png\"\n  ),\n  height = 500,\n  width = 800,\n  units = \"px\"\n)\n\n\n\n\n\n\nChanging the CRS to Azimuthal Equal Area Projection around Equator and IDL cross-point.\n\n\nCode\ntemp_crs &lt;- paste0(\n  \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n  180,          # Longitude\n  \" +lat_0=\", \n  0             # Latitude\n)\n\ntemp_rast &lt;- world_cbhsr_rast |&gt; \n  terra::aggregate(fact = 10) |&gt; \n  terra::project(temp_crs)\n\ng &lt;- ggplot() +\n  geom_spatraster_rgb(\n    data = temp_rast\n  ) +\n  geom_sf(\n    data = world_lines,\n    mapping = aes(\n      linewidth = high_var,\n      alpha = high_var\n    ),\n    colour = \"darkred\",\n    linetype = 1,\n    lineend = \"round\"\n  ) +\n  scale_alpha_manual(values = c(0.4, 0.8)) +\n  scale_linewidth_manual(values = c(0.2, 0.4)) +\n  coord_sf(\n    crs = \n    ) +\n  labs(\n    title = \"International Date Line\\nwith background Raster Map\"\n  ) +\n  theme(\n    plot.title = element_text(\n      hjust = 0.5, size = 12\n    ),\n    panel.grid = element_blank(),\n    legend.position = \"none\"\n  )\n\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_6.png\"\n  ),\n  height = 500,\n  width = 500,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nCode\n# Basic World Maps (repeat of previous code)\nworld_map &lt;- ne_countries(\n  scale = 110,\n  returnclass = \"sf\"\n) |&gt; \n  select(name, geometry)\n\nworld_lines &lt;- ne_download(\n  scale = 50,\n  type = \"geographic_lines\",\n  returnclass = \"sf\",\n  category = \"physical\"\n) |&gt; \n  select(name) |&gt; \n  mutate(\n    high_var = name == \"International Date Line\"\n  )\n\nworld_oceans &lt;- ne_download(\n  scale = 50,\n  type = \"ocean\",\n  category = \"physical\",\n  returnclass = \"sf\"\n) \n\n# Number of flight path points to treat as intermediate between \n# Singapore and New York City\nnum_points &lt;- 20\n\nflight1 &lt;- tibble::tibble(\n  name = c(\"Singapore Changi Airport\", \n           \"New York JFK Airport\"),\n  longitude = c(103.994003, -73.7781),\n  latitude = c(1.364420, 40.6413)\n)\n\nflight2 &lt;- flight1 |&gt; \n  st_as_sf(\n    coords = c(\"longitude\", \"latitude\"),\n    crs = \"EPSG:4326\"\n  )\n\nflight_path &lt;- geosphere::gcIntermediate(\n  p1 = c(flight1$longitude[1], flight1$latitude[1]),\n  p2 = c(flight1$longitude[2], flight1$latitude[2]),\n  n = num_points,\n  addStartEnd = TRUE\n) |&gt; \n  as_tibble()\n\nflight_path_sf &lt;- flight_path |&gt;\n  st_as_sf(\n    coords = c(\"lon\", \"lat\"),\n    crs = \"EPSG:4326\"\n  ) |&gt; \n  st_combine() |&gt; \n  st_cast(\"LINESTRING\")\n\n\n# Points to plot\nplot_points &lt;- c(1, num_points %/% 3, \n                 2*num_points %/% 3, num_points)\n\nfor (i in plot_points){\n  \n  temp_crs &lt;- paste0(\n    \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n    flight_path$lon[i],          # Longitude\n    \" +lat_0=\", \n    flight_path$lat[i]            # Latitude\n  )\n  \n  temp_rast &lt;- world_cbhsr_rast |&gt; \n    terra::aggregate(fact = 10) |&gt; \n    terra::project(temp_crs)\n  \npaste0(\"g\", i) |&gt; \n  assign(\n    ggplot() +\n      geom_spatraster_rgb(\n        data = temp_rast\n      ) +\n      # geom_sf(\n      #   data = world_map,\n      #   fill = \"#e0ca22\",\n      #   colour = NA,\n      #   linewidth = 0.01\n      # ) +\n      # geom_sf(\n      #   data = world_oceans,\n      #   fill = \"skyblue\",\n      #   colour = NA\n      # ) +\n      geom_sf(\n        data = flight_path_sf, \n        colour = \"red\",\n        linewidth = 0.3\n        ) +\n      geom_sf(\n        data = flight2,\n        size = 1,\n        colour = \"darkred\"\n      ) +\n      coord_sf(\n        crs = temp_crs\n      ) +\n      theme(\n        plot.title = element_textbox(\n          hjust = 0.5, \n          halign = 0.5\n        ),\n        panel.grid = element_line(\n          linewidth = 0.05, \n          colour = \"grey80\",\n          linetype = 1\n        )\n      )\n  )\n  \n}\n\ng &lt;- g1 + g6 + g12 + g20 +\n  plot_annotation(\n    title = \"Static Flight Path: Singapore to New York City\",\n    theme = theme(\n      plot.title = element_text(\n        size = 2 * 12,\n        margin = margin(5,0,0,0, \"pt\")\n      )\n    )\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\n    \"geocomputation\", \"images\",\n     \"rnaturalearth_package_7.png\"\n  ),\n  height = 1000,\n  width = 1000,\n  units = \"px\"\n)\n\n\n\n\n\n\n\n\nCode\nworld_agg_rast &lt;- world_cbhsr_rast |&gt; \n    terra::aggregate(fact = 10)\n\n\n# Number of flight path points to treat as intermediate between \n# Singapore and New York City\nnum_points &lt;- 20\n\nflight1 &lt;- tibble::tibble(\n  name = c(\"Singapore Changi Airport\", \n           \"New York JFK Airport\"),\n  longitude = c(103.994003, -73.7781),\n  latitude = c(1.364420, 40.6413)\n)\n\nflight2 &lt;- flight1 |&gt; \n  st_as_sf(\n    coords = c(\"longitude\", \"latitude\"),\n    crs = \"EPSG:4326\"\n  )\n\nflight_path &lt;- geosphere::gcIntermediate(\n  p1 = c(flight1$longitude[1], flight1$latitude[1]),\n  p2 = c(flight1$longitude[2], flight1$latitude[2]),\n  n = num_points,\n  addStartEnd = TRUE\n) |&gt; \n  as_tibble()\n\nflight_path_sf &lt;- flight_path |&gt;\n  st_as_sf(\n    coords = c(\"lon\", \"lat\"),\n    crs = \"EPSG:4326\"\n  ) |&gt; \n  st_combine() |&gt; \n  st_cast(\"LINESTRING\")\n\nlibrary(magick)\nlibrary(animation)\n\ni = 10\n\nanimation::saveGIF(\n  \n  expr = for (i in 1:nrow(flight_path)) {\n    temp_crs &lt;- paste0(\n      \"+proj=laea +x_0=0 +y_0=0 +lon_0=\", \n      flight_path$lon[i],          # Longitude\n      \" +lat_0=\", \n      flight_path$lat[i]            # Latitude\n    )\n  \n    temp_rast &lt;- world_agg_rast |&gt; \n      terra::project(temp_crs)\n  \n    ggplot() +\n      geom_spatraster_rgb(\n        data = temp_rast,\n        maxcell = 5e+4\n      ) +\n      geom_sf(\n        data = flight_path_sf, \n        colour = \"red\",\n        linewidth = 0.3\n        ) +\n      geom_sf(\n        data = flight2,\n        size = 0.6,\n        colour = \"darkred\"\n      ) +\n      geom_sf(\n        data = flight_path |&gt; \n                  slice(i) |&gt; \n                  st_as_sf(coords = c(\"lon\", \"lat\"),\n                           crs = \"EPSG:4326\"),\n        size = 1,\n        colour = \"grey20\"\n      ) +\n      coord_sf(\n        crs = temp_crs\n      )\n  },\n  movie.name = here::here(\n    \"geocomputation\", \"images\",\n    \"rnaturalearth_package_1.gif\"\n  ),\n  ani.height = 500,\n  ani.width = 500,\n  ani.loop = TRUE,\n  interval = 1\n)\n\n\n\n\n\n\n\nCode\n# Get border map of Uttarakhand\nuk_state = ne_states(country = \"India\", returnclass = \"sf\") |&gt; \n  select(iso_3166_2, name, geometry) |&gt; \n  filter(name == \"Uttarakhand\")\n\n\n# Get Rivers of Uttarakhand\n# https://www.naturalearthdata.com/downloads/50m-physical-vectors/\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_rivers_lake_centerlines.zip\nuk_rivers &lt;- ne_download(\n  scale = 10,\n  type = \"rivers_lake_centerlines\",\n  category = \"physical\",\n  returnclass = \"sf\"\n) |&gt; \n  st_intersection(uk_state)\n\n# Get Lakes of Uttarakhand\n# https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_lakes.zip\nuk_lakes &lt;- ne_download(\n  scale = 50,\n  type = \"lakes\",\n  category = \"physical\",\n  returnclass = \"sf\"\n)\n\nuk_lakes |&gt; \n  ggplot() +\n  geom_sf()\n\nuk_rivers |&gt; \n  ggplot() +\n  geom_sf()\n\nuk_state |&gt; \n  ggplot() +\n  geom_sf()"
  }
]