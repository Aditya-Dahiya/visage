[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visualizing Information and Spatial Analysis with ggplot2 Extensions",
    "section": "",
    "text": "Welcome to V.I.S.A.G.E., a resource for extending ggplot2 and the tidyverse to create stunning visualizations, perform geo-computation, and analyze complex data. Built using R and RStudio, this site demonstrates how packages like sf, various ggplot2 extensions, and other tools in the tidyverse enhance data manipulation and visualization. Explore dynamic graphs, interactive maps, and reproducible workflows built with Quarto to see how modern tools can turn data into insights."
  },
  {
    "objectID": "geocomputation.html",
    "href": "geocomputation.html",
    "title": "Geo-Computation",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\nComputing shortest routes in the sea that avoid land\n\n\nUsing data from Killer Whales encounters in Salish Sea to plot routes of their recorded encounters, and showing those routes that dont intersect land - i.e., removing erroneous data.\n\n\n\n\n\n\n\nOct 17, 2024\n\n\nDriving Directions using Open Street Maps Routing Service\n\n\n \n\n\n\n\n\n\n\nOct 16, 2024\n\n\nCreating Maps in R with ggplot2 having background Raster Images using ggmap\n\n\nLearning how to create maps in R using the {ggmap} package, integrating custom raster base maps with {ggplot2} for geospatial data visualization. This page covers the setup, API authentication, and plotting functions to map data effectively.\n\n\n\n\n\n\n\nOct 15, 2024\n\n\nStarting Document\n\n\n \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Welcome to my little corner of the internet! I’m Dr. Aditya Dahiya, your friendly neighborhood data enthusiast. With an MBBS from AIIMS, New Delhi and a Master of Public Health from Harvard University, I’ve always had a penchant for diving deep into the intricacies of data—and what better way to do that than with ggplot2, its myriad extensions and other open-source packages.\nWhen I’m not navigating the labyrinth of Haryana’s bureaucracy (don’t worry, I have a map!), I channel my experiences as a Fulbright Fellow into making data visualization a captivating storytelling tool. Think of me as your data-wrangling, file-taming, bureaucracy-battling guide with a slightly skewed sense of humor. Need more bureaucratic banter or data insights? Connect with me on LinkedIn or shoot me an email — I promise it won’t be as formal as a government memo!"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About Me",
    "section": "Education",
    "text": "Education\nHarvard University | Boston, MA | MPH in Global Health | Aug 2021 - May 2022\nAll India Institute of Medical Sciences | New Delhi, India | M.B.B.S. | Aug 2005-Dec 2010"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About Me",
    "section": "Experience",
    "text": "Experience\nIndian Administrative Service | Director | Aug 2011 - present\nNeuro-Radiology, AIIMS New Delhi | Junior Resident Doctor | Jan 2011 - Aug 2011"
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html",
    "href": "geocomputation/ggmap_rasters.html",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "",
    "text": "On this page, we’ll explore how to create visually appealing maps in R using the ggmap package (ggmap?), a popular extension of ggplot2 designed for easy integration of raster map tiles from online mapping services. Let us see how to set up the required tools and generate maps with custom base layers, using both ggmap and functions like get_stadiamap().\nggmap is an extension of the ggplot2 package that enables users to overlay data on geographic maps. It retrieves raster map tiles from sources such as Google Maps, Stamen Maps, and Stadia Maps, making it easier to create maps and integrate geospatial data visualization with familiar ggplot2 workflows.\nCode\nlibrary(tidyverse)\nlibrary(ggmap)\nlibrary(sf)\n\nsysfonts::font_add_google(\"Saira Condensed\", \"caption_font\")\nsysfonts::font_add_google(\"Saira\", \"body_font\")\nshowtext::showtext_auto()\nAbout the Sample Dataset: The lnd dataset, part of the spData package (Bivand, Nowosad, and Lovelace 2024) in R, contains polygons representing the large administrative boroughs of London. This dataset includes attributes such as the borough name (NAME), official code (GSS_CODE), land area in hectares (HECTARES), and geometry data in the sfc_MULTIPOLYGON format. You can explore the dataset’s source here.\nCode\n# Data on The boroughs of London\nspData::lnd |&gt; \n  ggplot(\n    aes(\n      fill = NAME,\n      label = NAME,\n      size = HECTARES\n    )\n  ) +\n  geom_sf(\n    alpha = 0.75\n  ) +\n  geom_sf_text(\n    check_overlap = TRUE,\n    family = \"caption_font\"\n  ) +\n  coord_sf() +\n  theme_grey() +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\nFigure 1: A basic map of the boroughs of London drawn with geom_sf() and data from {spData} plotted using {ggplot2} and geom_sf()"
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#getting-started-with-ggmap",
    "href": "geocomputation/ggmap_rasters.html#getting-started-with-ggmap",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Getting Started with ggmap",
    "text": "Getting Started with ggmap\nBefore creating maps, you’ll need to install the ggmap package, which is available through CRAN.\ninstall.packages(\"ggmap\")\nTo ensure that you can access map tiles from Stadia Maps, you will need an API key. This key allows you to authenticate and use their map services within your R scripts.\nSetting Up API Key Authentication: To access Stadia Maps, follow these steps:\n\nSign up for a free Stadia Maps account and generate an API key.\nSave the API key securely in your environment using the register_stadiamaps() function.\n\nregister_stadiamaps(\"YOUR-API-KEY-HERE\", write = TRUE)\nBy saving the key in your .Renviron file, you ensure it will automatically load in new R sessions, avoiding the need to hard code it into your script."
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#retrieving-a-base-map-with-get_stadiamap",
    "href": "geocomputation/ggmap_rasters.html#retrieving-a-base-map-with-get_stadiamap",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Retrieving a Base-map with get_stadiamap()",
    "text": "Retrieving a Base-map with get_stadiamap()\nOnce your API key is set, you can start generating maps using functions such as get_stadiamap() etc. This function allows you to fetch base maps by specifying the bounding box coordinates of your area of interest. The function will return a ggmap object that you can further customize using ggplot2 syntax."
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#exploring-various-ggmap-functions",
    "href": "geocomputation/ggmap_rasters.html#exploring-various-ggmap-functions",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Exploring various ggmap Functions",
    "text": "Exploring various ggmap Functions\n\nBase functions: get_stadiamap() & ggmap()\nFetches map tiles from Stadia Maps and Stamen Design, after choosing the design from Map Style Library, for a specified bounding box or region and zoom level, and displays them using ggmap(). The various map styles available under the get_stadiamap(maptype = \"your-map-type-here\") argument are: —\n\n\n\n\n\n\n\nMap Type\nDescription\n\n\n\n\nstamen_terrain\nA detailed terrain map highlighting elevation and natural features like hills and rivers.\n\n\nstamen_toner\nA bold, high-contrast map design with stark black-and-white features, ideal for print or urban areas.\n\n\nstamen_toner_lite\nA lighter version of the toner map, providing clearer backgrounds with less emphasis on contrast.\n\n\nstamen_watercolor\nA unique, artistic map style that looks like a watercolor painting, perfect for creative visualizations.\n\n\nstamen_terrain_background\nA terrain map focusing only on the background without labels, useful for overlaying custom data.\n\n\nstamen_toner_background\nA simplified toner map background without labels, ideal for adding data layers on top.\n\n\nstamen_terrain_lines\nTerrain map with added contour lines to emphasize elevation changes.\n\n\nstamen_terrain_labels\nTerrain map that includes place labels, enhancing context for geographic features.\n\n\nstamen_toner_lines\nToner map with a focus on roads and paths, outlined clearly against the background.\n\n\nstamen_toner_labels\nA toner map style with added labels for places, roads, and other key features.\n\n\n\nNote: It is very important is to add the inherit.aes = FALSE argument in geom_sf() if overlaying sf objects on the the {ggmap} raster tiles.\nThe R code below demonstrates how to overlay spatial geometries from sf objects onto raster base maps using ggmap and geom_sf(). The get_stadiamap() function from Stadia Maps is used to fetch raster tiles (specifically with the stamen_toner_lines style) for the London area, which are then transformed into EPSG:3857 (Web Mercator) using a custom function ggmap_bbox() (credits: andyteuchner on stackoverflow post) to ensure the map tiles align correctly with the CRS of the spatial data. The London Boroughs dataset (spData::lnd) is similarly projected to EPSG:3857, and the boroughs are visualized with semi-transparent polygons and labeled with their names using geom_sf() and geom_sf_text(). This approach ensures the raster background and vector geometries are properly aligned.\n\n\nCode\n# Obtain the bounding box of London Boroughs\nlondon_bbox &lt;- sf::st_bbox(spData::lnd)\n\n# A bounding box in the format c(lowerleftlon, lowerleftlat, upperrightlon, upperrightlat)\nlondon_bbox &lt;- c(\n  left = london_bbox$xmin,\n  right = london_bbox$xmax,\n  bottom = london_bbox$ymin,\n  top = london_bbox$ymax\n)\nnames(london_bbox) &lt;- c(\"left\", \"right\", \"bottom\", \"top\")\n\n\n# Getting the map tiles\nlondon_base1 &lt;- get_stadiamap(\n  bbox = london_bbox,\n  zoom = 10,\n  maptype = \"stamen_toner_lines\"\n)\n\nst_crs(london_base1)\n# As we can see the raster images have no CRS system\n# Empirically we know that the coordinate refence system is 3857\n\n# Getting London Boroughs Data\ndf &lt;- spData::lnd |&gt;\n  st_transform(crs = st_crs(3857))\n\n\n# Starting the process of Overlaying the geom_sf() data on this\n# Most important is to add the inherit.aes = FALSE argument.\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nlondon_base2 &lt;- ggmap_bbox(london_base1)\n\n# Plotting the actual map\n\n# Starting with base map tiles\ng &lt;- ggmap(london_base2) +\n  \n  # Plotting the actual sf object data on london boroughs\n  geom_sf(\n    data = df,\n    aes(fill = NAME),\n    inherit.aes = FALSE,\n    alpha = 0.5,\n    colour = alpha(\"white\", 0.5)\n  ) +\n  \n  # Plotting names of London Boroughs on top of the geom_sf\n  geom_sf_text(\n    data = df,\n    aes(label = NAME),\n    inherit.aes = FALSE,\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = TRUE\n  ) +\n  \n  # Forcing the ggplot2 map to be in CRS: 3857\n  coord_sf(\n    crs = st_crs(3857)\n  ) +\n  \n  # Some theme elements\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"none\"\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \n                        \"ggmap_rasters\", \n                        \"fig_2.png\"),\n  plot = g\n)\n\n\n\n\n\n\n\n\nFigure 2: “Overlapping a geom_sf() object over and above ggmap raster tiles obtained from Stadia Maps”\n\n\n\n\n\n\nqmplot(): Similar to qplot(), but automatically adds a background map. It simplifies mapping by automatically computing the bounding box.\n\n\nWork-in-Progress: Other ggmap() functions\n\nmake_bbox(): Computes a bounding box for a dataset based on latitude and longitude columns.\ngeom_hdr() and geom_labeldensity2d(): Useful for plotting density and contour maps on top of ggmap layers, commonly used for visualizing spatial data like crime maps.\nget_googlemap(): Retrieves maps from Google Maps by specifying a location and zoom level. Different map types are supported (e.g., satellite, terrain, hybrid).\ngeocode() and revgeocode(): Provides geocoding and reverse geocoding services using Google Maps API to convert addresses to coordinates and vice versa.\nmutate_geocode(): Works like mutate() in dplyr, adding latitude and longitude columns to a data frame based on an address.\ntrek() and route(): Calculates routes between locations using Google’s routing API, which can be plotted as paths on a map using geom_path().\nmapdist(): Computes distances and travel times between multiple locations. It’s vectorized for multiple origin-destination pairs.\nregister_google(): Registers a Google Maps API key for use with the ggmap package, allowing access to various Google Maps services. The key can be saved for future sessions."
  },
  {
    "objectID": "geocomputation/computing_sea_routes.html",
    "href": "geocomputation/computing_sea_routes.html",
    "title": "Computing shortest routes in the sea that avoid land",
    "section": "",
    "text": "Dataset used: This #TidyTuesday dataset comes from the Center for Whale Research (CWR), which monitors Southern Resident killer whales in the Salish Sea, part of the Pacific Northwest. The dataset, scraped by Jadey Ryan and documented here, contains information on encounters from 2017 to 2024. Each encounter involves photographing and identifying individual whales. The data can be accessed via the {orcas} R package and includes variables like encounter duration, location, and pod. While the dataset is mostly tidy, some inconsistencies such as missing values and negative durations remain. | Source | Data.\nHere’s my #TidyTuesday Visualization for this project in Figure 1, and the code used and the visualization webpage.\n\n\n\n\n\n\nFigure 1: This map visualizes the movements of Southern Resident killer whales, with arrows marking the starting and ending points of each recorded encounter. The concentration of arrows within a small area highlights the key regions in the Salish Sea where these encounters occur most frequently. Background map images provided by StadiaMaps.\n\n\n\n\n\nMethod 1: Using {geosphere} and {sf}\n\nStep 1: Loading libraries, getting the data and cleaning it\n\n\nCode\n# Loading the Libraries\nlibrary(tidyverse)       # Data wrangling\nlibrary(sf)              # SF objects\nlibrary(showtext)        # Using google fonts in R\nlibrary(geosphere)       # Spherical trigonometry for geography\n\n# Set fonts for including in all graphics\nfont_add_google(\"Saira Semi Condensed\", \"body_font\")\nfont_add_google(\"Saira Extra Condensed\",\"caption_font\")\nshowtext_auto()\n\n# Load orcas data\norcas &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-15/orcas.csv')\n\nsessioninfo::session_info()$packages |&gt; \n  as_tibble() |&gt; \n  dplyr::select(package, \n         version = loadedversion, \n         date, source) |&gt;\n  filter(package %in% .packages()) |&gt; \n  arrange(package) |&gt; \n  janitor::clean_names(\n    case = \"title\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive(\n    use_search = TRUE\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 1: List of packages used during this analysis and their versions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Clean the data, make it in {sf} format\n\n\nCode\n# A cleaner tibble to use for our visualization\ndf_sf &lt;- orcas |&gt; \n  as_tibble() |&gt;\n  dplyr::select(year, duration, \n         begin_latitude, begin_longitude,\n         end_latitude, end_longitude) |&gt; \n\n  # Convert the duration of encounter into seconds\n  mutate(\n    # remove parenthesis content from duration\n    duration = str_remove(duration, \"\\\\s*\\\\(.*\\\\)\"),\n    \n    # remove the \"s\" for seconds\n    duration = str_extract(duration, \"-?\\\\d+\"),\n    \n    # convert the duration into number\n    duration = as.numeric(duration)\n  ) |&gt; \n  \n  # Remove aberrant observation with durations less than zero\n  filter(duration &gt;= 0) |&gt; \n  \n  # Remove observations with missingness\n  drop_na() |&gt; \n  \n  # Allot an ID number to each finally selected observation\n  mutate(id = row_number()) |&gt; \n  dplyr::relocate(id, .before = everything())\n\n########################################################\n# Get a bounding box on the coordinates of encounters\nbbox_orcas &lt;- bind_rows(\n  \n  # Geometry column of starting coordiantes\n    sf::st_as_sf(\n      df_sf |&gt; dplyr::select(begin_latitude, begin_longitude),\n      coords = c(\"begin_longitude\",\"begin_latitude\"),\n      crs = 'EPSG:4326'\n    ) |&gt;\n    mutate(type = \"start_coords\"),\n    \n\n  # Geometry column of starting coordiantes\n    sf::st_as_sf(\n      df_sf |&gt; dplyr::select(end_latitude, end_longitude),\n      coords = c(\"end_longitude\",\"end_latitude\"),\n      crs = 'EPSG:4326'\n    ) |&gt;\n    mutate(type = \"end_coords\")\n) |&gt; \n  st_bbox()\n\n######################################################\n# Display cleaned data\n\ndf_sf |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    columns = -c(year, id),\n    decimals = 2\n  ) |&gt; \n  gt::tab_header(\n    title = \"Cleaned Data on starting and ending coordinates\",\n    subtitle = \"Recorded Encounters of Orcas (Southern Killer Whales) in the Salish Sea (2017-2024)\"\n  )\n\n\n\n\nTable 2: A table of clean data that shows id, year, duration and starting and ending coordinates of each Killer Whale encounter as an {sf} class column\n\n\n\n\n\n\nCleaned Data on starting and ending coordinates\nRecorded Encounters of Orcas (Southern Killer Whales) in the Salish Sea (2017-2024)\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Computing routes using geosphere::gcIntermediate()\n\n\nCode\n# Technique Credits: https://github.com/xmc811/flightplot/blob/master/R/main.R\n# Credits: Mingchu Xu\n# https://www.linkedin.com/in/mingchu-xu-467a0946/\n# On Twitter: @xmc811\n\nroutes &lt;- geosphere::gcIntermediate(\n  p1 = df_sf |&gt; dplyr::select(begin_longitude, begin_latitude),\n  p2 = df_sf |&gt; dplyr::select(end_longitude, end_latitude),\n  n = 100,\n  addStartEnd = TRUE,\n  sp = TRUE) |&gt; \n  sf::st_as_sf()\n\n# Check whether it works\nggplot() +\n  geom_sf(data = routes)\n\n\n\n\n\n\n\n\nFigure 2: The routes computed by the {geosphere} package’s gcIntermediate() function\n\n\n\n\n\n\n\nStep 4: Getting background maps for the Salish Sea area: USA and Canada\nFor this, we first convert our sf object on Map of USA and Canada, shown in Figure 3 (a) into a SpatVector. In the {terra} package in R, a SpatVector is the main class used to represent and work with vector data in geographic information system (GIS) contexts. A SpatVector can store points, lines, polygons, or any combination of these geometries, along with associated attributes (data linked to these geometries). We can create a SpatVector from:\n\nShapefiles (widely used for vector data in GIS)\nOther vector file formats like GeoJSON, KML, or GPKG.\nR objects such as data frames or matrices that contain coordinate information.\n\nThe reason to create a SpatVector is for performing spatial operations like buffering, intersecting, or spatial joins.The terra::vect() is the method to create these objects from various file formats or other R objects.\nThen, we use the terra::crop() to crop USA and Canada map to a specified geographic extent Figure 3 (b) defined by bounding box of the sf objects of orcas created in previous step. When applied to a SpatVector object (vector data), terra::crop() trims the geometries (points, lines, or polygons) so that only the portions within a specified spatial extent remain. Lastly, we re-convert the cropped SpatVector back into an sf object, shown in ?@fig-basemap1-3\n\n\nCode\n# Extract country borders data\nbase_map &lt;- rgeoboundaries::gb_adm0(country = c(\"USA\", \"Canada\")) %&gt;% \n  rmapshaper::ms_simplify(0.5)\n\n# checking the size\n# object.size(base_map) |&gt; print(units = \"Mb\")\n# 4.3 Mb\n\nggplot(base_map) +\n  geom_sf() +\n  coord_sf(\n    crs = usmap::usmap_crs()\n  )\n\nsea &lt;- terra::crop(terra::vect(base_map), bbox_orcas)\n\n# Finally, reconvert the Cropped area back into an sf object\nsea_sf &lt;- sea |&gt; \n  st_as_sf()\n\nggplot(sea_sf) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n(a) Map of entire USA and Canada from {rgeoboundaries}\n\n\n\n\n\n\n\n\n\n\n\n(b) Using the terra::crop() from {terra} to focus on Salish Sea area. The Salish Sea area plotted as an sf object\n\n\n\n\n\n\nFigure 3: Background Map of the Salish Sea Area in 2 steps: (4.1) Getting map of USA and Canada from {rgeoboundaries}, and (4.2) Cropping out the map of Salish Sea area\n\n\n\n\n\n\nStep 5: Computing and Removing routes intersecting with land (i.e., erroneous data)\n\n\nCode\n# Test if path is only sea. Each logical test if for each ID in the \n# df1 tibble\ntest_intersect &lt;- lengths(\n  st_intersects(\n    st_transform(routes, st_crs(base_map)), base_map\n  )\n) &gt; 0\n\n# Compute distance for each \ndist_encounter &lt;- st_length(routes)\n\n# Create a second tibble of distance & paths for each encounter\ndf_routes &lt;- routes |&gt; \n  st_transform(st_crs(base_map)) |&gt; \n  bind_cols(id = df_sf$id) |&gt; \n  bind_cols(whether_intersect_land = test_intersect) |&gt; \n  bind_cols(dist_encounter = as.numeric(dist_encounter)) |&gt; \n  left_join(df_sf |&gt; dplyr::select(year, id, duration)) |&gt; \n  mutate(speed = dist_encounter / duration)\n  \n# A vector of IDs whose paths dont intersect land\nids_to_plot &lt;- df_routes |&gt; \n  filter(whether_intersect_land == FALSE) |&gt; \n  pull(id)\n\ndf_routes |&gt; \n  dplyr::relocate(geometry, .after = everything()) |&gt; \n  gt::gt() |&gt; \n  # gt::cols_hide(geometry) |&gt; \n  gt::fmt_number(\n    columns = c(dist_encounter, speed),\n    decimals = 1\n  ) |&gt; \n  gt::fmt(\n    columns = geometry,\n    fns = function(x) {str_sub(x, 1, 20)}\n  ) |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 3: A table of intersecting and non-intersecting routes\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 6: Plotting the non-intersecting routes in Figure 4\n\n\nCode\n# ggmap::register_stadiamaps(\"YOUR-KEY-HERE\")\n\nbbox_stadiamap &lt;- c(left = bbox_orcas[\"xmin\"],\n  right = bbox_orcas[\"xmax\"],\n  top = bbox_orcas[\"ymax\"],\n  bottom = bbox_orcas[\"ymin\"])\nnames(bbox_stadiamap) &lt;- c(\"left\", \"right\", \"top\", \"bottom\")\n\n# Getting the Stamen Maps for the background tiles as raster\nstamen_tiles_lowres &lt;- ggmap::get_stadiamap(\n   bbox_stadiamap,\n   zoom = 8,\n   maptype = \"stamen_terrain\"\n)\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nstamen_tiles_lowres2 &lt;- ggmap_bbox(stamen_tiles_lowres)\n\ng &lt;- ggmap::ggmap(stamen_tiles_lowres2) +\n  geom_sf(\n    data = df_routes |&gt; \n            filter(!whether_intersect_land) |&gt; \n            st_transform(crs = 3857),\n    mapping = aes(\n      geometry = geometry\n    ),\n    color = \"grey10\",\n    alpha = 0.5,\n    inherit.aes = FALSE,\n    arrow = arrow(\n      angle = 20,\n      length = unit(0.5, \"mm\")\n    ),\n    linewidth = 0.2\n  ) +\n  coord_sf(\n    expand = F\n  ) +\n  labs(\n    x = \"Longitude\", y = \"Latitude\"\n  ) +\n  theme_minimal()\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"computing_sea_routes_1.png\"),\n  width = 900,\n  height = 700,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: This map visualizes the movements of Southern Resident killer whales, with arrows marking the starting and ending points of each recorded encounter. The concentration of arrows within a small area highlights the key regions in the Salish Sea where these encounters occur most frequently. Background map images provided by StadiaMaps.\n\n\n\n\n\n\n\nMethod 2: Using raster and gdistance package\nThe following code for computing sea routes is inspired from Code by Benjamin Nowak hosted on GitHub as a part of #TidyTuesday visualizations.\n\nStep 1: Getting the data and cleaning it\nThe packages used in this analysis are shown in the Table 4\n\n\nCode\n# Loading the Libraries\nlibrary(tidyverse)       # Data wrangling\nlibrary(rgeoboundaries)  # Getting country & admin boundaries.\nlibrary(rmapshaper)      # For multi-polygon simplification\nlibrary(sf)              # SF objects\nlibrary(terra)           # Spatial data analysis\nlibrary(tidyterra)       # Tidyverse methods for terra objects\nlibrary(gdistance)       # Distances and Routes on Geographical Grids\nlibrary(showtext)        # Using google fonts in R\n\n# Set fonts for including in all graphics\nfont_add_google(\"Saira Semi Condensed\", \"body_font\")\nfont_add_google(\"Saira Extra Condensed\",\"caption_font\")\nshowtext_auto()\n\n# Load orcas data\norcas &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-15/orcas.csv')\n\nsessioninfo::session_info()$packages |&gt; \n  as_tibble() |&gt; \n  dplyr::select(package, \n         version = loadedversion, \n         date, source) |&gt; \n  filter(package %in% .packages()) |&gt; \n  arrange(package) |&gt; \n  janitor::clean_names(\n    case = \"title\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive(\n    use_search = TRUE\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 4: List of packages used during this analysis and their versions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Clean the data\n\n\nCode\n# A cleaner tibble to use for our visualization\ndf1 &lt;- orcas |&gt; \n  as_tibble() |&gt;\n  dplyr::select(year, duration, \n         begin_latitude, begin_longitude,\n         end_latitude, end_longitude) |&gt; \n\n  # Convert the duration of encounter into seconds\n  mutate(\n    # remove parenthesis content from duration\n    duration = str_remove(duration, \"\\\\s*\\\\(.*\\\\)\"),\n    \n    # remove the \"s\" for seconds\n    duration = str_extract(duration, \"-?\\\\d+\"),\n    \n    # convert the duration into number\n    duration = as.numeric(duration)\n  ) |&gt; \n  \n  # Remove aberrant observation with durations less than zero\n  filter(duration &gt;= 0) |&gt; \n  \n  # Remove observations with missingness\n  drop_na() |&gt; \n  \n  # Allot an ID number to each finally selected observation\n  mutate(id = row_number()) |&gt; \n  dplyr::relocate(id, .before = everything())\n\ndf1 |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    columns = -c(year, id),\n    decimals = 2\n  )\n\n\n\n\nTable 5: A table of clean data that shows id, year, duration and starting and ending coordinates of each Killer Whale encounter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Creating data is specific formats needed by {sf} {terra}\n\n\nCode\n# The starting Coordinates as an sf object\nstart_coordinates &lt;- df1 |&gt; \n  dplyr::select(id, begin_latitude, begin_longitude) |&gt; \n  sf::st_as_sf(\n    coords = c(\"begin_longitude\",\"begin_latitude\"),\n    crs = 'EPSG:4326'\n  ) |&gt; \n  mutate(type = \"start\")\n\n# The ending Coordinates as an sf object  \nend_coordinates &lt;- df1 |&gt; \n  dplyr::select(id, end_latitude, end_longitude) |&gt; \n  sf::st_as_sf(\n    coords = c(\"end_longitude\",\"end_latitude\"),\n    crs = 'EPSG:4326'\n  ) |&gt; \n  mutate(type = \"end\")\n\n# Compiling starting and ending coordinates into a tibble\norcas_sf &lt;- start_coordinates |&gt; \n  bind_rows(end_coordinates)\n\n# Extracting the bounding box of that tibble to get our map\nbb_orcas &lt;- st_bbox(orcas_sf)\n\norcas_sf |&gt; \n  print(n = 10)\n\n\nSimple feature collection with 1168 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -125.6233 ymin: 47.85333 xmax: -122.0445 ymax: 49.55733\nGeodetic CRS:  WGS 84\n# A tibble: 1,168 × 3\n      id             geometry type \n * &lt;int&gt;          &lt;POINT [°]&gt; &lt;chr&gt;\n 1     1  (-124.6925 48.5105) start\n 2     2  (-123.1578 48.4765) start\n 3     3    (-123.2 48.57167) start\n 4     4 (-123.3367 49.09267) start\n 5     5 (-123.0368 48.79683) start\n 6     6 (-122.9295 48.43633) start\n 7     7 (-123.8992 48.84733) start\n 8     8  (-123.592 48.02783) start\n 9     9    (-123.4358 48.87) start\n10    10 (-123.3302 48.80333) start\n# ℹ 1,158 more rows\n\n\n\n\nStep 4: Getting background maps for the Salish Sea area: USA and Canada\nFor description of the actions performed, please see Step 4 of the Method 1 above.\n\n\nCode\n# Extract country borders data\nbase_map &lt;- rgeoboundaries::gb_adm0(country = c(\"USA\", \"Canada\")) %&gt;% \n  rmapshaper::ms_simplify(0.5)\n\n# checking the size\n# object.size(base_map) |&gt; print(units = \"Mb\")\n# 4.3 Mb\n\nggplot(base_map) +\n  geom_sf() +\n  coord_sf(\n    crs = usmap::usmap_crs()\n  )\n\nsea &lt;- terra::crop(terra::vect(base_map), bb_orcas)\n\nggplot(sea) +\n  geom_sf()\n\n# Finally, reconvert the Cropped area back into an sf object\nsea_sf &lt;- sea |&gt; \n  st_as_sf()\n\nggplot(sea_sf) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n(a) Map of entire USA and Canada from {rgeoboundaries}\n\n\n\n\n\n\n\n\n\n\n\n(b) Using the terra::crop() from {terra} to focus on Salish Sea area\n\n\n\n\n\n\n\n\n\n\n\n(c) The same Salish Sea area plotted as an sf object\n\n\n\n\n\n\nFigure 5: Background Map of the Salish Sea Area in 2 steps: (4.1) Getting map of USA and Canada from {rgeoboundaries}, and (4.2) Cropping out the map of Salish Sea area\n\n\n\n\n\n\nStep 5: Converting into rasters to plot compute distances and intersections\nterra::rast() function is used to create a raster object or load an existing raster dataset (e.g., GeoTIFF, ASCII, or other raster formats). A raster is a grid of cells (pixels) where each cell has a value representing information such as elevation, temperature, land cover, etc. We use it here to Create an empty raster, defining the number of rows, columns, extent, and coordinate reference system (CRS) to create a raster template.\nterra::rasterize() function is then used to convert vector data (points, lines, polygons) into raster format. This process assigns values from vector geometries to raster cells, typically based on whether the geometries overlap with the cells or using attributes from the vector data. For example, here we are Rasterizing polygons: i.e., for each land types: USA, Canada or other, we can rasterize it so that each raster cell represents one of these three.\n\n\nCode\n# Convert vector to raster and set highly diffferent pixel values based on whether an area is sea or land (i.e. not sea)\n\n# Step 5.1: Generate an empty raster defining the resolution by\n#           number of rows and columns, and a CRS from sea_sf\nr &lt;- terra::rast(sea_sf, ncols = 500, nrows = 500)\n\nggplot() +\n  geom_spatraster(data = r)\n\nrr &lt;- terra::rasterize(sea_sf, r, \"shapeISO\") %&gt;%\n  mutate(shapeISO = case_when(\n    shapeISO %in% c('CAN', 'USA') ~ 1,  # assign value 1 to land\n    TRUE ~ 1000                         # assign value 1000 to sea\n  ))\n\nggplot() +\n  geom_spatraster(data = rr)\n\n\n\n\n\n\n\n\nFigure 6: The empty raster of 500 X 500 created using terra::rast()\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: The raster is enhanced by adding the polygons data from the salish sea area map we cropped in the last step.\n\n\n\n\n\n\n\nStep 6: Computing the distance between starting and ending coordinates\n\nThe gdistance::transition() function is used to create a transition matrix from raster data. The Transition Matrix is a sparse matrix where each element represents the movement “cost” or “resistance” from one cell to its neighboring cells. The transition matrix enables the calculation of the most efficient path (e.g., the least-cost path) from one location to another. Thus, it is used for calculating least-cost paths, commute distances, and other kinds of spatial movement analyses.\nThe transition matrix helps in Movement Modeling: It is used to model movement across a landscape, such as wildlife migration, water flow, or human navigation, where each raster cell’s value might represent an obstacle or ease of travel. Note that we had assigned different value to land and sea raster points.\nAfter creating a transition layer using gdistance::transition(), the gdistance::geoCorrection() function is used to apply geographic corrections to account for the varying distances between raster cells due to the curvature of the Earth or grid layout. This step is crucial when working with spatial data in a geographic coordinate system (e.g., latitude and longitude) where distances between cells are not uniform.\nThe gdistance::shortestPath() is then used to compute the shortest (or least-cost) path between two points on a raster grid, based on a transition matrix that describes the “cost” or “resistance” of moving from one cell to another. The function calculates this path by minimizing the total cost or resistance, taking into account the values in the transition matrix, which typically represent the difficulty or ease of moving through each cell.\n\n\n\nCode\n# For quick rendering of this .qmd file, I have not evaluated \n# this chunk of code, and rather saved the results of \"distance\"\n# as an .rds file and reloaded it.\n\n# Compute transition matrix from raster pixels\nr_trans &lt;- gdistance::transition(\n  x = raster(rr), \n  transitionFunction = mean, \n  directions = 16\n)\n# object.size(r_trans) |&gt; print(units = \"Mb\")\n# 24.7 Mb\n\nr_trans &lt;- geoCorrection(r_trans)\n# object.size(r_trans) |&gt; print(units = \"Mb\")\n# 24.7 Mb\n\n# Compute the shortest path between start and end for the \n# first line of the transition matrix, and convert into sf object:\n\ndistance &lt;- gdistance::shortestPath(\n  r_trans, \n  c(df1 |&gt; filter(id == 1) |&gt; pull(begin_longitude),\n    df1 |&gt; filter(id == 1) |&gt; pull(begin_latitude)), \n  c(df1 |&gt; filter(id == 1) |&gt; pull(end_longitude),\n    df1 |&gt; filter(id == 1) |&gt; pull(end_latitude)), \n  output = \"SpatialLines\"\n) |&gt; \n  st_as_sf()\n\n# Repeat the process for the other points / IDs\nfor (i in 2:nrow(df1)) {\n  \n  temp &lt;- gdistance::shortestPath(\n  r_trans, \n  c(df1 |&gt; filter(id == i) |&gt; pull(begin_longitude),\n    df1 |&gt; filter(id == i) |&gt; pull(begin_latitude)), \n  c(df1 |&gt; filter(id == i) |&gt; pull(end_longitude),\n    df1 |&gt; filter(id == i) |&gt; pull(end_latitude)), \n  output = \"SpatialLines\"\n) |&gt; \n  st_as_sf()\n  \n  distance &lt;- distance |&gt; \n    bind_rows(temp)\n\n}\n\n# Add a CRS to the newly created sf object \ndistance &lt;- distance |&gt; \n  st_set_crs(st_crs(base_map))\n\nsaveRDS(distance, file = here::here(\"data\", \"orcas_distance.rds\"))\n\n\n\n\nCode\ndistance &lt;- readRDS(here::here(\"data\", \"orcas_distance.rds\"))\n\n# Displaying the shortest paths\nggplot() +\n  \n  geom_sf(\n    data = sea_sf, \n    alpha = 0.75, \n    fill = \"#725428\") +\n\n  geom_sf(\n    data = distance\n  ) +\n  coord_sf(expand = FALSE) +\n  \n  theme(\n    panel.background = element_rect(fill = \"#b6e3db\")\n  )\n\n\n\n\n\n\n\n\nFigure 8: The shortest paths computed using {gdistance} show us that many of them are passing over land - these seem to be errors in the data\n\n\n\n\n\n\n\nStep 7: Check whether paths intersect land, and retain only non-intersecting routes\nThe sf::st_intersects() function is used to determine whether two spatial geometries intersect. It checks if any part of one geometry touches or overlaps with another.\nThe sf::st_length() function is then used to calculate the length of geometries represented in sf (simple features) objects. It returns the length of each geometry in the specified unit of measurement.\n\n\nCode\n# Test if path is only sea. Each logical test if for each ID in the \n# df1 tibble\ntest_intersect &lt;- lengths(st_intersects(distance, base_map)) &gt; 0\n\n# Compute distance for each \ndist_encounter &lt;- st_length(distance)\n\n# Create a second tibble of distance & paths for each encounter\ndf2 &lt;- distance |&gt; \n  bind_cols(id = start_coordinates$id) |&gt; \n  bind_cols(whether_intersect_land = test_intersect) |&gt; \n  bind_cols(dist_encounter = as.numeric(dist_encounter)) |&gt; \n  left_join(df1 |&gt; dplyr::select(year, id, duration)) |&gt; \n  mutate(speed = dist_encounter / duration)\n  \n# A vector of IDs whose paths dont intersect land\nids_to_plot &lt;- df2 |&gt; \n  filter(whether_intersect_land == FALSE) |&gt; \n  pull(id)\n\ndf2 |&gt; \n  dplyr::relocate(geometry, .after = everything()) |&gt; \n  slice_head(n = 10) |&gt; \n  mutate(geometry = as.character(geometry)) |&gt; \n  gt::gt() |&gt; \n  # gt::cols_hide(geometry) |&gt; \n  gt::fmt_number(\n    columns = c(dist_encounter, speed),\n    decimals = 2\n  ) |&gt; \n  gt::fmt(\n    columns = geometry,\n    fns = function(x) {str_sub(x, 1, 50)}\n  )\n\n\n\n\n\n\n\n\nid\nwhether_intersect_land\ndist_encounter\nyear\nduration\nspeed\ngeometry\n\n\n\n\n1\nFALSE\n12,981.52\n2024\n5580\n2.33\nc(-124.689260978699, -124.703576316833, -124.71789\n\n\n2\nFALSE\n757.91\n2024\n2460\n0.31\nc(-123.157519798279, -123.157519798279, -123.15751\n\n\n3\nFALSE\n1,845.91\n2024\n9900\n0.19\nc(-123.200465812683, -123.193308143616, -123.18615\n\n\n4\nFALSE\n11,256.39\n2024\n5460\n2.06\nc(-123.336461524963, -123.336461524963, -123.33646\n\n\n5\nFALSE\n6,932.37\n2024\n2460\n2.82\nc(-123.035839424133, -123.035839424133, -123.03583\n\n\n6\nFALSE\n11,305.02\n2024\n6300\n1.79\nc(-122.928474388123, -122.921316719055, -122.91415\n\n\n7\nTRUE\n7,742.05\n2024\n6360\n1.22\nc(-123.901917381287, -123.901917381287, -123.90191\n\n\n8\nTRUE\n130,922.24\n2024\n2340\n55.95\nc(-123.594137611389, -123.594137611389, -123.59413\n\n\n9\nFALSE\n7,738.62\n2024\n3900\n1.98\nc(-123.436668891907, -123.443826560974, -123.45098\n\n\n10\nFALSE\n2,816.18\n2024\n840\n3.35\nc(-123.329303855896, -123.329303855896, -123.32930\n\n\n\n\n\n\n\n\n\nStep 8: Plotting the final routes with ggplot2\n\n\nCode\nland &lt;- \"#725428\"\nsea &lt;- \"#b6e3db\"\norc &lt;- \"grey10\"\n\nggplot() +\n  geom_sf(\n    data = sea_sf,\n    mapping = aes(geometry = geometry),\n    fill = land, color = NA,\n    alpha = 0.9\n  ) +\n  geom_sf(\n    df2 |&gt; filter(!whether_intersect_land),\n    mapping = aes(\n      alpha = speed,\n      geometry = geometry\n    ),\n    color = orc\n  ) + \n  coord_sf(\n    expand = F\n  ) +\n  scale_alpha(range = c(0.5, 0.9)) +\n  guides(alpha = \"none\") +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = sea, color = NA)\n  )\n\n\n\n\n\n\n\n\nFigure 9: The final map with routes shown that don’t intersect land. The alpha (transparency) of each route is mapped to speed."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html",
    "href": "geocomputation/osm_driving_directions.html",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "",
    "text": "Inspired from the tutorial from Andrew Heiss, titled “How to make fancy road trip maps with R and OpenStreetMap”."
  }
]