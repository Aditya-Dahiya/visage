[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visualizing Information and Spatial Analysis with ggplot2 Extensions",
    "section": "",
    "text": "Welcome to V.I.S.A.G.E., a resource for extending ggplot2 and the tidyverse to create stunning visualizations, perform geo-computation, and analyze complex data. Built using R and RStudio, this site demonstrates how packages like sf, various ggplot2 extensions, and other tools in the tidyverse enhance data manipulation and visualization. Explore dynamic graphs, interactive maps, and reproducible workflows built with Quarto to see how modern tools can turn data into insights."
  },
  {
    "objectID": "geocomputation.html",
    "href": "geocomputation.html",
    "title": "Geo-Computation",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\nNov 3, 2024\n\n\nGeographic data in R (Chapter 2)\n\n\nKey Learnings from, and Solutions to the exercises in Chapter 2 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow.\n\n\n\n\nOct 26, 2024\n\n\nDriving Directions using Open Street Maps Routing Service\n\n\nUsing {tidygeocoder}, {osrm}, {sf}, {tidyverse} and {ggmap} along with Open Source Techniques to plot driving directions along various cities in Europe in the norther-Mediterranean region\n\n\n\n\nOct 25, 2024\n\n\n3 types of Cartograms in R with {sf} and {cartogram}\n\n\nCreating Cartograms – contiguous, non-contiguous and packed-circles – in R with {cartogram}, and making non-overlapping text annotations in maps, and custom callouts in Quarto.\n\n\n\n\nOct 20, 2024\n\n\nComputing shortest routes in the sea that avoid land\n\n\nUsing data from Killer Whales encounters in Salish Sea to plot routes of their recorded encounters, and showing those routes that dont intersect land - i.e., removing erroneous data.\n\n\n\n\nOct 16, 2024\n\n\nCreating Maps in R with ggplot2 having background Raster Images using ggmap\n\n\nLearning how to create maps in R using the {ggmap} package, integrating custom raster base maps with {ggplot2} for geospatial data visualization. This page covers the setup, API authentication, and plotting functions to map data effectively.\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Welcome to my little corner of the internet! I’m Dr. Aditya Dahiya, your friendly neighborhood data enthusiast. With an MBBS from AIIMS, New Delhi and a Master of Public Health from Harvard University, I’ve always had a penchant for diving deep into the intricacies of data—and what better way to do that than with ggplot2, its myriad extensions and other open-source packages.\nWhen I’m not navigating the labyrinth of Haryana’s bureaucracy (don’t worry, I have a map!), I channel my experiences as a Fulbright Fellow into making data visualization a captivating storytelling tool. Think of me as your data-wrangling, file-taming, bureaucracy-battling guide with a slightly skewed sense of humor. Need more bureaucratic banter or data insights? Connect with me on LinkedIn or shoot me an email — I promise it won’t be as formal as a government memo!"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About Me",
    "section": "Education",
    "text": "Education\nHarvard University | Boston, MA | MPH in Global Health | Aug 2021 - May 2022\nAll India Institute of Medical Sciences | New Delhi, India | M.B.B.S. | Aug 2005-Dec 2010"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "About Me",
    "section": "Experience",
    "text": "Experience\nIndian Administrative Service | Director | Aug 2011 - present\nNeuro-Radiology, AIIMS New Delhi | Junior Resident Doctor | Jan 2011 - Aug 2011"
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html",
    "href": "geocomputation/ggmap_rasters.html",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "",
    "text": "On this page, we’ll explore how to create visually appealing maps in R using the ggmap package (ggmap?), a popular extension of ggplot2 designed for easy integration of raster map tiles from online mapping services. Let us see how to set up the required tools and generate maps with custom base layers, using both ggmap and functions like get_stadiamap().\nggmap is an extension of the ggplot2 package that enables users to overlay data on geographic maps. It retrieves raster map tiles from sources such as Google Maps, Stamen Maps, and Stadia Maps, making it easier to create maps and integrate geospatial data visualization with familiar ggplot2 workflows.\nCode\nlibrary(tidyverse)\nlibrary(ggmap)\nlibrary(sf)\n\nsysfonts::font_add_google(\"Saira Condensed\", \"caption_font\")\nsysfonts::font_add_google(\"Saira\", \"body_font\")\nshowtext::showtext_auto()\nAbout the Sample Dataset: The lnd dataset, part of the spData package (Bivand, Nowosad, and Lovelace 2024) in R, contains polygons representing the large administrative boroughs of London. This dataset includes attributes such as the borough name (NAME), official code (GSS_CODE), land area in hectares (HECTARES), and geometry data in the sfc_MULTIPOLYGON format. You can explore the dataset’s source here.\nCode\n# Data on The boroughs of London\ng &lt;- spData::lnd |&gt; \n  ggplot(\n    aes(\n      fill = NAME,\n      label = NAME,\n      size = HECTARES\n    )\n  ) +\n  geom_sf(\n    alpha = 0.75\n  ) +\n  geom_sf_text(\n    check_overlap = TRUE,\n    family = \"caption_font\"\n  ) +\n  scale_size_continuous(\n    range = c(8, 15)\n  ) +\n  coord_sf() +\n  labs(x = NULL, y = NULL) +\n  theme_grey(\n    base_size = 20\n  ) +\n  theme(\n    legend.position = \"none\",\n    axis.ticks.length = unit(0, \"mm\")\n  )\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"ggmap_rasters_1.png\")\n)"
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#getting-started-with-ggmap",
    "href": "geocomputation/ggmap_rasters.html#getting-started-with-ggmap",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Getting Started with ggmap",
    "text": "Getting Started with ggmap\nBefore creating maps, you’ll need to install the ggmap package, which is available through CRAN.\ninstall.packages(\"ggmap\")\nTo ensure that you can access map tiles from Stadia Maps, you will need an API key. This key allows you to authenticate and use their map services within your R scripts.\nSetting Up API Key Authentication: To access Stadia Maps, follow these steps:\n\nSign up for a free Stadia Maps account and generate an API key.\nSave the API key securely in your environment using the register_stadiamaps() function.\n\nregister_stadiamaps(\"YOUR-API-KEY-HERE\", write = TRUE)\nBy saving the key in your .Renviron file, you ensure it will automatically load in new R sessions, avoiding the need to hard code it into your script."
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#retrieving-a-base-map-with-get_stadiamap",
    "href": "geocomputation/ggmap_rasters.html#retrieving-a-base-map-with-get_stadiamap",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Retrieving a Base-map with get_stadiamap()",
    "text": "Retrieving a Base-map with get_stadiamap()\nOnce your API key is set, you can start generating maps using functions such as get_stadiamap() etc. This function allows you to fetch base maps by specifying the bounding box coordinates of your area of interest. The function will return a ggmap object that you can further customize using ggplot2 syntax."
  },
  {
    "objectID": "geocomputation/ggmap_rasters.html#exploring-various-ggmap-functions",
    "href": "geocomputation/ggmap_rasters.html#exploring-various-ggmap-functions",
    "title": "Creating Maps in R with ggplot2 having background Raster Images using ggmap",
    "section": "Exploring various ggmap Functions",
    "text": "Exploring various ggmap Functions\n\nBase functions: get_stadiamap() & ggmap()\nFetches map tiles from Stadia Maps and Stamen Design, after choosing the design from Map Style Library, for a specified bounding box or region and zoom level, and displays them using ggmap(). The various map styles available under the get_stadiamap(maptype = \"your-map-type-here\") argument are: —\n\n\n\n\n\n\n\nMap Type\nDescription\n\n\n\n\nstamen_terrain\nA detailed terrain map highlighting elevation and natural features like hills and rivers.\n\n\nstamen_toner\nA bold, high-contrast map design with stark black-and-white features, ideal for print or urban areas.\n\n\nstamen_toner_lite\nA lighter version of the toner map, providing clearer backgrounds with less emphasis on contrast.\n\n\nstamen_watercolor\nA unique, artistic map style that looks like a watercolor painting, perfect for creative visualizations.\n\n\nstamen_terrain_background\nA terrain map focusing only on the background without labels, useful for overlaying custom data.\n\n\nstamen_toner_background\nA simplified toner map background without labels, ideal for adding data layers on top.\n\n\nstamen_terrain_lines\nTerrain map with added contour lines to emphasize elevation changes.\n\n\nstamen_terrain_labels\nTerrain map that includes place labels, enhancing context for geographic features.\n\n\nstamen_toner_lines\nToner map with a focus on roads and paths, outlined clearly against the background.\n\n\nstamen_toner_labels\nA toner map style with added labels for places, roads, and other key features.\n\n\n\nNote: It is very important is to add the inherit.aes = FALSE argument in geom_sf() if overlaying sf objects on the the {ggmap} raster tiles.\nThe R code below demonstrates how to overlay spatial geometries from sf objects onto raster base maps using ggmap and geom_sf(). The get_stadiamap() function from Stadia Maps is used to fetch raster tiles (specifically with the stamen_toner_lines style) for the London area, which are then transformed into EPSG:3857 (Web Mercator) using a custom function ggmap_bbox() (credits: andyteuchner on stackoverflow post) to ensure the map tiles align correctly with the CRS of the spatial data. The London Boroughs dataset (spData::lnd) is similarly projected to EPSG:3857, and the boroughs are visualized with semi-transparent polygons and labeled with their names using geom_sf() and geom_sf_text(). This approach ensures the raster background and vector geometries are properly aligned.\n\n\nCode\n# Obtain the bounding box of London Boroughs\nlondon_bbox &lt;- sf::st_bbox(spData::lnd)\n\n# A bounding box in the format c(lowerleftlon, lowerleftlat, upperrightlon, upperrightlat)\nlondon_bbox &lt;- c(\n  left = london_bbox$xmin,\n  right = london_bbox$xmax,\n  bottom = london_bbox$ymin,\n  top = london_bbox$ymax\n)\nnames(london_bbox) &lt;- c(\"left\", \"right\", \"bottom\", \"top\")\n\n\n# Getting the map tiles\nlondon_base1 &lt;- get_stadiamap(\n  bbox = london_bbox,\n  zoom = 10,\n  maptype = \"stamen_toner_lines\"\n)\n\nst_crs(london_base1)\n# As we can see the raster images have no CRS system\n# Empirically we know that the coordinate refence system is 3857\n\n# Getting London Boroughs Data\ndf &lt;- spData::lnd |&gt;\n  st_transform(crs = st_crs(3857))\n\n\n# Starting the process of Overlaying the geom_sf() data on this\n# Most important is to add the inherit.aes = FALSE argument.\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nlondon_base2 &lt;- ggmap_bbox(london_base1)\n\n# Plotting the actual map\n\n# Starting with base map tiles\ng &lt;- ggmap(london_base2) +\n  \n  # Plotting the actual sf object data on london boroughs\n  geom_sf(\n    data = df,\n    aes(fill = NAME),\n    inherit.aes = FALSE,\n    alpha = 0.5,\n    colour = alpha(\"white\", 0.5)\n  ) +\n  \n  # Plotting names of London Boroughs on top of the geom_sf\n  geom_sf_text(\n    data = df,\n    aes(label = NAME),\n    inherit.aes = FALSE,\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = TRUE\n  ) +\n  \n  # Forcing the ggplot2 map to be in CRS: 3857\n  coord_sf(\n    crs = st_crs(3857)\n  ) +\n  \n  # Some theme elements\n  ggthemes::theme_map() +\n  theme(\n    legend.position = \"none\"\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \n                        \"ggmap_rasters\", \n                        \"fig_2.png\"),\n  plot = g\n)\n\n\n\n\n\n\n\n\nFigure 2: Overlapping a geom_sf() object over and above ggmap raster tiles obtained from Stadia Maps\n\n\n\n\n\n\nqmplot(): Similar to qplot(), but automatically adds a background map. It simplifies mapping by automatically computing the bounding box.\n\n\nWork-in-Progress: Other ggmap() functions\n\nmake_bbox(): Computes a bounding box for a dataset based on latitude and longitude columns.\ngeom_hdr() and geom_labeldensity2d(): Useful for plotting density and contour maps on top of ggmap layers, commonly used for visualizing spatial data like crime maps.\nget_googlemap(): Retrieves maps from Google Maps by specifying a location and zoom level. Different map types are supported (e.g., satellite, terrain, hybrid).\ngeocode() and revgeocode(): Provides geocoding and reverse geocoding services using Google Maps API to convert addresses to coordinates and vice versa.\nmutate_geocode(): Works like mutate() in dplyr, adding latitude and longitude columns to a data frame based on an address.\ntrek() and route(): Calculates routes between locations using Google’s routing API, which can be plotted as paths on a map using geom_path().\nmapdist(): Computes distances and travel times between multiple locations. It’s vectorized for multiple origin-destination pairs.\nregister_google(): Registers a Google Maps API key for use with the ggmap package, allowing access to various Google Maps services. The key can be saved for future sessions."
  },
  {
    "objectID": "geocomputation/computing_sea_routes.html",
    "href": "geocomputation/computing_sea_routes.html",
    "title": "Computing shortest routes in the sea that avoid land",
    "section": "",
    "text": "Dataset used: This #TidyTuesday dataset comes from the Center for Whale Research (CWR), which monitors Southern Resident killer whales in the Salish Sea, part of the Pacific Northwest. The dataset, scraped by Jadey Ryan and documented here, contains information on encounters from 2017 to 2024. Each encounter involves photographing and identifying individual whales. The data can be accessed via the {orcas} R package and includes variables like encounter duration, location, and pod. While the dataset is mostly tidy, some inconsistencies such as missing values and negative durations remain. | Source | Data.\nHere’s my #TidyTuesday Visualization for this project in Figure 1, and the code used and the visualization webpage.\n\n\n\n\n\n\nFigure 1: This map visualizes the movements of Southern Resident killer whales, with arrows marking the starting and ending points of each recorded encounter. The concentration of arrows within a small area highlights the key regions in the Salish Sea where these encounters occur most frequently. Background map images provided by StadiaMaps.\n\n\n\n\n\nMethod 1: Using {geosphere} and {sf}\n\nStep 1: Loading libraries, getting the data and cleaning it\n\n\nCode\n# Loading the Libraries\nlibrary(tidyverse)       # Data wrangling\nlibrary(sf)              # SF objects\nlibrary(showtext)        # Using google fonts in R\nlibrary(geosphere)       # Spherical trigonometry for geography\n\n# Set fonts for including in all graphics\nfont_add_google(\"Saira Semi Condensed\", \"body_font\")\nfont_add_google(\"Saira Extra Condensed\",\"caption_font\")\nshowtext_auto()\n\n# Load orcas data\norcas &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-15/orcas.csv')\n\nsessioninfo::session_info()$packages |&gt; \n  as_tibble() |&gt; \n  dplyr::select(package, \n         version = loadedversion, \n         date, source) |&gt;\n  filter(package %in% .packages()) |&gt; \n  arrange(package) |&gt; \n  janitor::clean_names(\n    case = \"title\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive(\n    use_search = TRUE\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 1: List of packages used during this analysis and their versions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Clean the data, make it in {sf} format\n\n\nCode\n# A cleaner tibble to use for our visualization\ndf_sf &lt;- orcas |&gt; \n  as_tibble() |&gt;\n  dplyr::select(year, duration, \n         begin_latitude, begin_longitude,\n         end_latitude, end_longitude) |&gt; \n\n  # Convert the duration of encounter into seconds\n  mutate(\n    # remove parenthesis content from duration\n    duration = str_remove(duration, \"\\\\s*\\\\(.*\\\\)\"),\n    \n    # remove the \"s\" for seconds\n    duration = str_extract(duration, \"-?\\\\d+\"),\n    \n    # convert the duration into number\n    duration = as.numeric(duration)\n  ) |&gt; \n  \n  # Remove aberrant observation with durations less than zero\n  filter(duration &gt;= 0) |&gt; \n  \n  # Remove observations with missingness\n  drop_na() |&gt; \n  \n  # Allot an ID number to each finally selected observation\n  mutate(id = row_number()) |&gt; \n  dplyr::relocate(id, .before = everything())\n\n########################################################\n# Get a bounding box on the coordinates of encounters\nbbox_orcas &lt;- bind_rows(\n  \n  # Geometry column of starting coordiantes\n    sf::st_as_sf(\n      df_sf |&gt; dplyr::select(begin_latitude, begin_longitude),\n      coords = c(\"begin_longitude\",\"begin_latitude\"),\n      crs = 'EPSG:4326'\n    ) |&gt;\n    mutate(type = \"start_coords\"),\n    \n\n  # Geometry column of starting coordiantes\n    sf::st_as_sf(\n      df_sf |&gt; dplyr::select(end_latitude, end_longitude),\n      coords = c(\"end_longitude\",\"end_latitude\"),\n      crs = 'EPSG:4326'\n    ) |&gt;\n    mutate(type = \"end_coords\")\n) |&gt; \n  st_bbox()\n\n######################################################\n# Display cleaned data\n\ndf_sf |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    columns = -c(year, id),\n    decimals = 2\n  ) |&gt; \n  gt::tab_header(\n    title = \"Cleaned Data on starting and ending coordinates\",\n    subtitle = \"Recorded Encounters of Orcas (Southern Killer Whales) in the Salish Sea (2017-2024)\"\n  )\n\n\n\n\nTable 2: A table of clean data that shows id, year, duration and starting and ending coordinates of each Killer Whale encounter as an {sf} class column\n\n\n\n\n\n\nCleaned Data on starting and ending coordinates\nRecorded Encounters of Orcas (Southern Killer Whales) in the Salish Sea (2017-2024)\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Computing routes using geosphere::gcIntermediate()\n\n\nCode\n# Technique Credits: https://github.com/xmc811/flightplot/blob/master/R/main.R\n# Credits: Mingchu Xu\n# https://www.linkedin.com/in/mingchu-xu-467a0946/\n# On Twitter: @xmc811\n\nroutes &lt;- geosphere::gcIntermediate(\n  p1 = df_sf |&gt; dplyr::select(begin_longitude, begin_latitude),\n  p2 = df_sf |&gt; dplyr::select(end_longitude, end_latitude),\n  n = 100,\n  addStartEnd = TRUE,\n  sp = TRUE) |&gt; \n  sf::st_as_sf()\n\n# Check whether it works\nggplot() +\n  geom_sf(data = routes)\n\n\n\n\n\n\n\n\nFigure 2: The routes computed by the {geosphere} package’s gcIntermediate() function\n\n\n\n\n\n\n\nStep 4: Getting background maps for the Salish Sea area: USA and Canada\nFor this, we first convert our sf object on Map of USA and Canada, shown in Figure 3 (a) into a SpatVector. In the {terra} package in R, a SpatVector is the main class used to represent and work with vector data in geographic information system (GIS) contexts. A SpatVector can store points, lines, polygons, or any combination of these geometries, along with associated attributes (data linked to these geometries). We can create a SpatVector from:\n\nShapefiles (widely used for vector data in GIS)\nOther vector file formats like GeoJSON, KML, or GPKG.\nR objects such as data frames or matrices that contain coordinate information.\n\nThe reason to create a SpatVector is for performing spatial operations like buffering, intersecting, or spatial joins.The terra::vect() is the method to create these objects from various file formats or other R objects.\nThen, we use the terra::crop() to crop USA and Canada map to a specified geographic extent Figure 3 (b) defined by bounding box of the sf objects of orcas created in previous step. When applied to a SpatVector object (vector data), terra::crop() trims the geometries (points, lines, or polygons) so that only the portions within a specified spatial extent remain. Lastly, we re-convert the cropped SpatVector back into an sf object, shown in ?@fig-basemap1-3\n\n\nCode\n# Extract country borders data\nbase_map &lt;- rgeoboundaries::gb_adm0(country = c(\"USA\", \"Canada\")) %&gt;% \n  rmapshaper::ms_simplify(0.5)\n\n# checking the size\n# object.size(base_map) |&gt; print(units = \"Mb\")\n# 4.3 Mb\n\nggplot(base_map) +\n  geom_sf() +\n  coord_sf(\n    crs = usmap::usmap_crs()\n  )\n\nsea &lt;- terra::crop(terra::vect(base_map), bbox_orcas)\n\n# Finally, reconvert the Cropped area back into an sf object\nsea_sf &lt;- sea |&gt; \n  st_as_sf()\n\nggplot(sea_sf) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n(a) Map of entire USA and Canada from {rgeoboundaries}\n\n\n\n\n\n\n\n\n\n\n\n(b) Using the terra::crop() from {terra} to focus on Salish Sea area. The Salish Sea area plotted as an sf object\n\n\n\n\n\n\nFigure 3: Background Map of the Salish Sea Area in 2 steps: (4.1) Getting map of USA and Canada from {rgeoboundaries}, and (4.2) Cropping out the map of Salish Sea area\n\n\n\n\n\n\nStep 5: Computing and Removing routes intersecting with land (i.e., erroneous data)\n\n\nCode\n# Test if path is only sea. Each logical test if for each ID in the \n# df1 tibble\ntest_intersect &lt;- lengths(\n  st_intersects(\n    st_transform(routes, st_crs(base_map)), base_map\n  )\n) &gt; 0\n\n# Compute distance for each \ndist_encounter &lt;- st_length(routes)\n\n# Create a second tibble of distance & paths for each encounter\ndf_routes &lt;- routes |&gt; \n  st_transform(st_crs(base_map)) |&gt; \n  bind_cols(id = df_sf$id) |&gt; \n  bind_cols(whether_intersect_land = test_intersect) |&gt; \n  bind_cols(dist_encounter = as.numeric(dist_encounter)) |&gt; \n  left_join(df_sf |&gt; dplyr::select(year, id, duration)) |&gt; \n  mutate(speed = dist_encounter / duration)\n  \n# A vector of IDs whose paths dont intersect land\nids_to_plot &lt;- df_routes |&gt; \n  filter(whether_intersect_land == FALSE) |&gt; \n  pull(id)\n\ndf_routes |&gt; \n  dplyr::relocate(geometry, .after = everything()) |&gt; \n  gt::gt() |&gt; \n  # gt::cols_hide(geometry) |&gt; \n  gt::fmt_number(\n    columns = c(dist_encounter, speed),\n    decimals = 1\n  ) |&gt; \n  gt::fmt(\n    columns = geometry,\n    fns = function(x) {str_sub(x, 1, 20)}\n  ) |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 3: A table of intersecting and non-intersecting routes\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 6: Plotting the non-intersecting routes in Figure 4\n\n\nCode\n# ggmap::register_stadiamaps(\"YOUR-KEY-HERE\")\n\nbbox_stadiamap &lt;- c(left = bbox_orcas[\"xmin\"],\n  right = bbox_orcas[\"xmax\"],\n  top = bbox_orcas[\"ymax\"],\n  bottom = bbox_orcas[\"ymin\"])\nnames(bbox_stadiamap) &lt;- c(\"left\", \"right\", \"top\", \"bottom\")\n\n# Getting the Stamen Maps for the background tiles as raster\nstamen_tiles_lowres &lt;- ggmap::get_stadiamap(\n   bbox_stadiamap,\n   zoom = 8,\n   maptype = \"stamen_terrain\"\n)\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nstamen_tiles_lowres2 &lt;- ggmap_bbox(stamen_tiles_lowres)\n\ng &lt;- ggmap::ggmap(stamen_tiles_lowres2) +\n  geom_sf(\n    data = df_routes |&gt; \n            filter(!whether_intersect_land) |&gt; \n            st_transform(crs = 3857),\n    mapping = aes(\n      geometry = geometry\n    ),\n    color = \"grey10\",\n    alpha = 0.5,\n    inherit.aes = FALSE,\n    arrow = arrow(\n      angle = 20,\n      length = unit(0.5, \"mm\")\n    ),\n    linewidth = 0.2\n  ) +\n  coord_sf(\n    expand = F\n  ) +\n  labs(\n    x = \"Longitude\", y = \"Latitude\"\n  ) +\n  theme_minimal()\n\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\", \"computing_sea_routes_1.png\"),\n  width = 900,\n  height = 700,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: This map visualizes the movements of Southern Resident killer whales, with arrows marking the starting and ending points of each recorded encounter. The concentration of arrows within a small area highlights the key regions in the Salish Sea where these encounters occur most frequently. Background map images provided by StadiaMaps.\n\n\n\n\n\n\n\nMethod 2: Using raster and gdistance package\nThe following code for computing sea routes is inspired from Code by Benjamin Nowak hosted on GitHub as a part of #TidyTuesday visualizations.\n\nStep 1: Getting the data and cleaning it\nThe packages used in this analysis are shown in the Table 4\n\n\nCode\n# Loading the Libraries\nlibrary(tidyverse)       # Data wrangling\nlibrary(rgeoboundaries)  # Getting country & admin boundaries.\nlibrary(rmapshaper)      # For multi-polygon simplification\nlibrary(sf)              # SF objects\nlibrary(terra)           # Spatial data analysis\nlibrary(tidyterra)       # Tidyverse methods for terra objects\nlibrary(gdistance)       # Distances and Routes on Geographical Grids\nlibrary(showtext)        # Using google fonts in R\n\n# Set fonts for including in all graphics\nfont_add_google(\"Saira Semi Condensed\", \"body_font\")\nfont_add_google(\"Saira Extra Condensed\",\"caption_font\")\nshowtext_auto()\n\n# Load orcas data\norcas &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-10-15/orcas.csv')\n\nsessioninfo::session_info()$packages |&gt; \n  as_tibble() |&gt; \n  dplyr::select(package, \n         version = loadedversion, \n         date, source) |&gt; \n  filter(package %in% .packages()) |&gt; \n  arrange(package) |&gt; \n  janitor::clean_names(\n    case = \"title\"\n  ) |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive(\n    use_search = TRUE\n  ) |&gt; \n  gtExtras::gt_theme_espn()\n\n\n\n\nTable 4: List of packages used during this analysis and their versions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Clean the data\n\n\nCode\n# A cleaner tibble to use for our visualization\ndf1 &lt;- orcas |&gt; \n  as_tibble() |&gt;\n  dplyr::select(year, duration, \n         begin_latitude, begin_longitude,\n         end_latitude, end_longitude) |&gt; \n\n  # Convert the duration of encounter into seconds\n  mutate(\n    # remove parenthesis content from duration\n    duration = str_remove(duration, \"\\\\s*\\\\(.*\\\\)\"),\n    \n    # remove the \"s\" for seconds\n    duration = str_extract(duration, \"-?\\\\d+\"),\n    \n    # convert the duration into number\n    duration = as.numeric(duration)\n  ) |&gt; \n  \n  # Remove aberrant observation with durations less than zero\n  filter(duration &gt;= 0) |&gt; \n  \n  # Remove observations with missingness\n  drop_na() |&gt; \n  \n  # Allot an ID number to each finally selected observation\n  mutate(id = row_number()) |&gt; \n  dplyr::relocate(id, .before = everything())\n\ndf1 |&gt; \n  gt::gt() |&gt; \n  gt::opt_interactive() |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::fmt_number(\n    columns = -c(year, id),\n    decimals = 2\n  )\n\n\n\n\nTable 5: A table of clean data that shows id, year, duration and starting and ending coordinates of each Killer Whale encounter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Creating data is specific formats needed by {sf} {terra}\n\n\nCode\n# The starting Coordinates as an sf object\nstart_coordinates &lt;- df1 |&gt; \n  dplyr::select(id, begin_latitude, begin_longitude) |&gt; \n  sf::st_as_sf(\n    coords = c(\"begin_longitude\",\"begin_latitude\"),\n    crs = 'EPSG:4326'\n  ) |&gt; \n  mutate(type = \"start\")\n\n# The ending Coordinates as an sf object  \nend_coordinates &lt;- df1 |&gt; \n  dplyr::select(id, end_latitude, end_longitude) |&gt; \n  sf::st_as_sf(\n    coords = c(\"end_longitude\",\"end_latitude\"),\n    crs = 'EPSG:4326'\n  ) |&gt; \n  mutate(type = \"end\")\n\n# Compiling starting and ending coordinates into a tibble\norcas_sf &lt;- start_coordinates |&gt; \n  bind_rows(end_coordinates)\n\n# Extracting the bounding box of that tibble to get our map\nbb_orcas &lt;- st_bbox(orcas_sf)\n\norcas_sf |&gt; \n  print(n = 10)\n\n\nSimple feature collection with 1168 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -125.6233 ymin: 47.85333 xmax: -122.0445 ymax: 49.55733\nGeodetic CRS:  WGS 84\n# A tibble: 1,168 × 3\n      id             geometry type \n * &lt;int&gt;          &lt;POINT [°]&gt; &lt;chr&gt;\n 1     1  (-124.6925 48.5105) start\n 2     2  (-123.1578 48.4765) start\n 3     3    (-123.2 48.57167) start\n 4     4 (-123.3367 49.09267) start\n 5     5 (-123.0368 48.79683) start\n 6     6 (-122.9295 48.43633) start\n 7     7 (-123.8992 48.84733) start\n 8     8  (-123.592 48.02783) start\n 9     9    (-123.4358 48.87) start\n10    10 (-123.3302 48.80333) start\n# ℹ 1,158 more rows\n\n\n\n\nStep 4: Getting background maps for the Salish Sea area: USA and Canada\nFor description of the actions performed, please see Step 4 of the Method 1 above.\n\n\nCode\n# Extract country borders data\nbase_map &lt;- rgeoboundaries::gb_adm0(country = c(\"USA\", \"Canada\")) %&gt;% \n  rmapshaper::ms_simplify(0.5)\n\n# checking the size\n# object.size(base_map) |&gt; print(units = \"Mb\")\n# 4.3 Mb\n\nggplot(base_map) +\n  geom_sf() +\n  coord_sf(\n    crs = usmap::usmap_crs()\n  )\n\nsea &lt;- terra::crop(terra::vect(base_map), bb_orcas)\n\nggplot(sea) +\n  geom_sf()\n\n# Finally, reconvert the Cropped area back into an sf object\nsea_sf &lt;- sea |&gt; \n  st_as_sf()\n\nggplot(sea_sf) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n(a) Map of entire USA and Canada from {rgeoboundaries}\n\n\n\n\n\n\n\n\n\n\n\n(b) Using the terra::crop() from {terra} to focus on Salish Sea area\n\n\n\n\n\n\n\n\n\n\n\n(c) The same Salish Sea area plotted as an sf object\n\n\n\n\n\n\nFigure 5: Background Map of the Salish Sea Area in 2 steps: (4.1) Getting map of USA and Canada from {rgeoboundaries}, and (4.2) Cropping out the map of Salish Sea area\n\n\n\n\n\n\nStep 5: Converting into rasters to plot compute distances and intersections\nterra::rast() function is used to create a raster object or load an existing raster dataset (e.g., GeoTIFF, ASCII, or other raster formats). A raster is a grid of cells (pixels) where each cell has a value representing information such as elevation, temperature, land cover, etc. We use it here to Create an empty raster, defining the number of rows, columns, extent, and coordinate reference system (CRS) to create a raster template.\nterra::rasterize() function is then used to convert vector data (points, lines, polygons) into raster format. This process assigns values from vector geometries to raster cells, typically based on whether the geometries overlap with the cells or using attributes from the vector data. For example, here we are Rasterizing polygons: i.e., for each land types: USA, Canada or other, we can rasterize it so that each raster cell represents one of these three.\n\n\nCode\n# Convert vector to raster and set highly diffferent pixel values based on whether an area is sea or land (i.e. not sea)\n\n# Step 5.1: Generate an empty raster defining the resolution by\n#           number of rows and columns, and a CRS from sea_sf\nr &lt;- terra::rast(sea_sf, ncols = 500, nrows = 500)\n\nggplot() +\n  geom_spatraster(data = r)\n\nrr &lt;- terra::rasterize(sea_sf, r, \"shapeISO\") %&gt;%\n  mutate(shapeISO = case_when(\n    shapeISO %in% c('CAN', 'USA') ~ 1,  # assign value 1 to land\n    TRUE ~ 1000                         # assign value 1000 to sea\n  ))\n\nggplot() +\n  geom_spatraster(data = rr)\n\n\n\n\n\n\n\n\nFigure 6: The empty raster of 500 X 500 created using terra::rast()\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: The raster is enhanced by adding the polygons data from the salish sea area map we cropped in the last step.\n\n\n\n\n\n\n\nStep 6: Computing the distance between starting and ending coordinates\n\nThe gdistance::transition() function is used to create a transition matrix from raster data. The Transition Matrix is a sparse matrix where each element represents the movement “cost” or “resistance” from one cell to its neighboring cells. The transition matrix enables the calculation of the most efficient path (e.g., the least-cost path) from one location to another. Thus, it is used for calculating least-cost paths, commute distances, and other kinds of spatial movement analyses.\nThe transition matrix helps in Movement Modeling: It is used to model movement across a landscape, such as wildlife migration, water flow, or human navigation, where each raster cell’s value might represent an obstacle or ease of travel. Note that we had assigned different value to land and sea raster points.\nAfter creating a transition layer using gdistance::transition(), the gdistance::geoCorrection() function is used to apply geographic corrections to account for the varying distances between raster cells due to the curvature of the Earth or grid layout. This step is crucial when working with spatial data in a geographic coordinate system (e.g., latitude and longitude) where distances between cells are not uniform.\nThe gdistance::shortestPath() is then used to compute the shortest (or least-cost) path between two points on a raster grid, based on a transition matrix that describes the “cost” or “resistance” of moving from one cell to another. The function calculates this path by minimizing the total cost or resistance, taking into account the values in the transition matrix, which typically represent the difficulty or ease of moving through each cell.\n\n\n\nCode\n# For quick rendering of this .qmd file, I have not evaluated \n# this chunk of code, and rather saved the results of \"distance\"\n# as an .rds file and reloaded it.\n\n# Compute transition matrix from raster pixels\nr_trans &lt;- gdistance::transition(\n  x = raster(rr), \n  transitionFunction = mean, \n  directions = 16\n)\n# object.size(r_trans) |&gt; print(units = \"Mb\")\n# 24.7 Mb\n\nr_trans &lt;- geoCorrection(r_trans)\n# object.size(r_trans) |&gt; print(units = \"Mb\")\n# 24.7 Mb\n\n# Compute the shortest path between start and end for the \n# first line of the transition matrix, and convert into sf object:\n\ndistance &lt;- gdistance::shortestPath(\n  r_trans, \n  c(df1 |&gt; filter(id == 1) |&gt; pull(begin_longitude),\n    df1 |&gt; filter(id == 1) |&gt; pull(begin_latitude)), \n  c(df1 |&gt; filter(id == 1) |&gt; pull(end_longitude),\n    df1 |&gt; filter(id == 1) |&gt; pull(end_latitude)), \n  output = \"SpatialLines\"\n) |&gt; \n  st_as_sf()\n\n# Repeat the process for the other points / IDs\nfor (i in 2:nrow(df1)) {\n  \n  temp &lt;- gdistance::shortestPath(\n  r_trans, \n  c(df1 |&gt; filter(id == i) |&gt; pull(begin_longitude),\n    df1 |&gt; filter(id == i) |&gt; pull(begin_latitude)), \n  c(df1 |&gt; filter(id == i) |&gt; pull(end_longitude),\n    df1 |&gt; filter(id == i) |&gt; pull(end_latitude)), \n  output = \"SpatialLines\"\n) |&gt; \n  st_as_sf()\n  \n  distance &lt;- distance |&gt; \n    bind_rows(temp)\n\n}\n\n# Add a CRS to the newly created sf object \ndistance &lt;- distance |&gt; \n  st_set_crs(st_crs(base_map))\n\nsaveRDS(distance, file = here::here(\"data\", \"orcas_distance.rds\"))\n\n\n\n\nCode\ndistance &lt;- readRDS(here::here(\"data\", \"orcas_distance.rds\"))\n\n# Displaying the shortest paths\nggplot() +\n  \n  geom_sf(\n    data = sea_sf, \n    alpha = 0.75, \n    fill = \"#725428\") +\n\n  geom_sf(\n    data = distance\n  ) +\n  coord_sf(expand = FALSE) +\n  \n  theme(\n    panel.background = element_rect(fill = \"#b6e3db\")\n  )\n\n\n\n\n\n\n\n\nFigure 8: The shortest paths computed using {gdistance} show us that many of them are passing over land - these seem to be errors in the data\n\n\n\n\n\n\n\nStep 7: Check whether paths intersect land, and retain only non-intersecting routes\nThe sf::st_intersects() function is used to determine whether two spatial geometries intersect. It checks if any part of one geometry touches or overlaps with another.\nThe sf::st_length() function is then used to calculate the length of geometries represented in sf (simple features) objects. It returns the length of each geometry in the specified unit of measurement.\n\n\nCode\n# Test if path is only sea. Each logical test if for each ID in the \n# df1 tibble\ntest_intersect &lt;- lengths(st_intersects(distance, base_map)) &gt; 0\n\n# Compute distance for each \ndist_encounter &lt;- st_length(distance)\n\n# Create a second tibble of distance & paths for each encounter\ndf2 &lt;- distance |&gt; \n  bind_cols(id = start_coordinates$id) |&gt; \n  bind_cols(whether_intersect_land = test_intersect) |&gt; \n  bind_cols(dist_encounter = as.numeric(dist_encounter)) |&gt; \n  left_join(df1 |&gt; dplyr::select(year, id, duration)) |&gt; \n  mutate(speed = dist_encounter / duration)\n  \n# A vector of IDs whose paths dont intersect land\nids_to_plot &lt;- df2 |&gt; \n  filter(whether_intersect_land == FALSE) |&gt; \n  pull(id)\n\ndf2 |&gt; \n  dplyr::relocate(geometry, .after = everything()) |&gt; \n  slice_head(n = 10) |&gt; \n  mutate(geometry = as.character(geometry)) |&gt; \n  gt::gt() |&gt; \n  # gt::cols_hide(geometry) |&gt; \n  gt::fmt_number(\n    columns = c(dist_encounter, speed),\n    decimals = 2\n  ) |&gt; \n  gt::fmt(\n    columns = geometry,\n    fns = function(x) {str_sub(x, 1, 50)}\n  )\n\n\n\n\n\n\n\n\nid\nwhether_intersect_land\ndist_encounter\nyear\nduration\nspeed\ngeometry\n\n\n\n\n1\nFALSE\n12,981.52\n2024\n5580\n2.33\nc(-124.689260978699, -124.703576316833, -124.71789\n\n\n2\nFALSE\n757.91\n2024\n2460\n0.31\nc(-123.157519798279, -123.157519798279, -123.15751\n\n\n3\nFALSE\n1,845.91\n2024\n9900\n0.19\nc(-123.200465812683, -123.193308143616, -123.18615\n\n\n4\nFALSE\n11,256.39\n2024\n5460\n2.06\nc(-123.336461524963, -123.336461524963, -123.33646\n\n\n5\nFALSE\n6,932.37\n2024\n2460\n2.82\nc(-123.035839424133, -123.035839424133, -123.03583\n\n\n6\nFALSE\n11,305.02\n2024\n6300\n1.79\nc(-122.928474388123, -122.921316719055, -122.91415\n\n\n7\nTRUE\n7,742.05\n2024\n6360\n1.22\nc(-123.901917381287, -123.901917381287, -123.90191\n\n\n8\nTRUE\n130,922.24\n2024\n2340\n55.95\nc(-123.594137611389, -123.594137611389, -123.59413\n\n\n9\nFALSE\n7,738.62\n2024\n3900\n1.98\nc(-123.436668891907, -123.443826560974, -123.45098\n\n\n10\nFALSE\n2,816.18\n2024\n840\n3.35\nc(-123.329303855896, -123.329303855896, -123.32930\n\n\n\n\n\n\n\n\n\nStep 8: Plotting the final routes with ggplot2\n\n\nCode\nland &lt;- \"#725428\"\nsea &lt;- \"#b6e3db\"\norc &lt;- \"grey10\"\n\nggplot() +\n  geom_sf(\n    data = sea_sf,\n    mapping = aes(geometry = geometry),\n    fill = land, color = NA,\n    alpha = 0.9\n  ) +\n  geom_sf(\n    df2 |&gt; filter(!whether_intersect_land),\n    mapping = aes(\n      alpha = speed,\n      geometry = geometry\n    ),\n    color = orc\n  ) + \n  coord_sf(\n    expand = F\n  ) +\n  scale_alpha(range = c(0.5, 0.9)) +\n  guides(alpha = \"none\") +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = sea, color = NA)\n  )\n\n\n\n\n\n\n\n\nFigure 9: The final map with routes shown that don’t intersect land. The alpha (transparency) of each route is mapped to speed."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html",
    "href": "geocomputation/osm_driving_directions.html",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "",
    "text": "This code provides a detailed methodology for creating a visually informative route map for a driving trip along the northern Mediterranean, integrating data visualization, spatial data handling, and Open Street Maps (OSM) routing services in R. Utilizing several packages, including {sf} (Pebesma and Bivand 2023) for spatial data and {tidygeocoder} (Cambon et al. 2021) for geocoding, the code transforms a dataset of locations into spatial coordinates. By accessing OSRM (Open Source Routing Machine) through the {osrm} (Giraud 2022)package, the code calculates and visualizes optimized driving routes between selected cities. Distances and travel durations are formatted using custom functions, enhancing the map’s usability and clarity.\nThe geospatial data is presented using {ggplot2} (Wickham 2016) with additional styling from {ggrepel} (Slowikowski 2024) for labels and {patchwork} (Pedersen 2024) to arrange plots. Base map layers are sourced from {rnaturalearth} (Massicotte and South 2023) and a refined background layer is added using {ggmap} with Stadia map tiles, adjusted to EPSG:3857 using custom bounding box functions. This layering enables effective visualization of routes on custom raster maps. The code’s structure allows for modifications, such as changing cities or map styling, demonstrating the adaptability of R’s spatial data packages in route mapping and driving directions creation.\nInspired from this tutorial (Heiss 2023) titled “How to make fancy road trip maps with R and OpenStreetMap”."
  },
  {
    "objectID": "geocomputation/cartogram_types.html",
    "href": "geocomputation/cartogram_types.html",
    "title": "3 types of Cartograms in R with {sf} and {cartogram}",
    "section": "",
    "text": "Introduction\nOn this webpage, we’ll explore how to create cartograms in R, using population data from the CIA World Factbook. Cartograms are a unique type of thematic map that reshape geographic regions to represent data variables rather than their actual geographic area. By resizing areas to reflect variables like population, cartograms reveal spatial patterns and disparities in a more visually striking way, making them a powerful tool for storytelling with data.\nUnlike traditional maps, where region size is based solely on geographical area, cartograms alter these sizes to communicate insights about underlying data trends. This approach offers several advantages: it enhances visualization by making patterns more apparent, communicates complex data to a broad audience effectively, and highlights disparities between regions, drawing attention to areas of interest. Additionally, cartograms facilitate comparative analysis by allowing viewers to easily compare regions resized according to a single variable.\nTo create cartograms in R, we’ll use a combination of packages, including {cartogram} (Jeworutzki 2023)for cartogram-specific functions, {sf} (Pebesma and Bivand 2023) for handling spatial data, {ggplot2} (Wickham 2016) for flexible mapping and plotting, and {tidyverse} (Wickham et al. 2019) for streamlined data manipulation. The {cartogram} package provides various cartogram types, including\n\nDorling cartograms (Figure 5) that represent regions as resized circles,\nContiguous area cartograms (Figure 3) that maintain topological relationships between regions, and\nNon-contiguous area cartograms (Figure 4) that allow flexibility in resizing by ignoring boundaries.\n\n\nAbout the Data\nThe dataset used in this tutorial is sourced from the CIA World Factbook, specifically the Country Comparisons from 2014. This resource provides essential statistics on population, area, and other key indicators for 265 global entities. Through the {openintro} and {usdatasets} R packages, we access population metrics that allow us to create cartograms—maps where countries’ sizes are distorted according to population values rather than geographic area. This dataset, which required no additional cleaning, enables the visualization of demographic distributions, highlighting countries’ population density and size in an intuitive way for mapping exercises in R.\n\n\n\n\n\n\nKey Learnings\n\n\n\n\nCreating Cartograms with {cartogram}, such as contiguous, non-contiguous, and Dorling cartograms to visually communicate data through shape transformations.\nCustom Callouts in Quarto with the Custom Callout Extension, which enhances document structure and readability, such as the present call-out.\nRepelling Overlapping Text Labels with {ggrepel} with geom_sf() and geom_sf_text() for improved clarity on maps.\n\n\n\n\n\nStep 1: Getting libraries and raw data\nIn this step, we are setting up our workspace to create a population-based cartogram using data from the CIA World Factbook. We begin by loading essential libraries, including {tidyverse} for data manipulation and visualization, {sf} for handling spatial data, and {cartogram} for creating cartograms. We load the cia_factbook dataset and use the {countrycode} package to add ISO3 country codes for mapping. The world_map object is created using the {rnaturalearth} package, which provides geographic data in sf format. Additionally, we set up custom fonts using {showtext} and define color palettes for filling and labeling countries, enhancing the map’s readability and aesthetic.\n\n\nCode\n# Load essential libraries\nlibrary(tidyverse)         # For data wrangling and visualization\nlibrary(sf)                # For handling spatial objects in R\nlibrary(ggrepel)           # For repelling overlapping labels in plots\nlibrary(cartogram)         # For creating different types of cartograms\nlibrary(showtext)          # For using custom Google Fonts in plots\n\n# Load and prepare the CIA Factbook data\ncia_data &lt;- openintro::cia_factbook |&gt; \n  mutate(\n    # Convert country names to ISO3 codes for easy matching with \n    # Geographical Maps data\n    iso_a3 = countrycode::countrycode(country, \"country.name\", \"iso3c\") \n  )\n\n# Retrieve the world map data\nworld_map &lt;- rnaturalearth::ne_countries(\n  scale = \"small\",      # Use small scale for manageable detail\n  returnclass = \"sf\"    # Return as an 'sf' object for spatial handling\n  )\n\n# Add a custom Google font for captions\nfont_add_google(\"Saira Extra Condensed\", \"caption_font\")\nshowtext_auto()           # Automatically apply custom fonts\n\n# Display the size of the world_map object in KB\n# object.size(world_map) |&gt; print(units = \"Kb\")\n\n# Define colors for country fill and text\n# Fill color palette for countries\nfill_palette &lt;- paletteer::paletteer_d(\"khroma::stratigraphy\")\n\n# Define a darker color palette for text labels\ncolour_palette &lt;- fill_palette |&gt; \n  str_sub(start = 1, end = 7) |&gt;  # Truncate hex codes to 6 characters\n  colorspace::darken(0.5)         # Darken colors by 50% for better contrast\n\n\n\n\nStep 2: Converting the data into a “tidy” tibble.\nIn this code snippet, we refine the world_map data and visualize it in the Mercator projection using the ggplot2 package. We start by selecting relevant columns, grouping by country name, and keeping the entry with the highest population estimate for countries with multiple entries. After joining this map data with the cia_data dataset, we filter out any countries without population data and apply the Pseudo-Mercator projection (CRS 3857) using {sf}’s st_transform() function. Finally, we use ggplot2 to plot the world map with geom_sf() and set a minimal theme and informative title and caption.\n\n\n\nTable 1\n\n\n\nCode\n# Filter, join, and transform world map data for plotting\n\nworld_map &lt;- world_map |&gt; \n  select(name, geometry, pop_est, iso_a3) |&gt;      # Select relevant columns\n  group_by(name) |&gt;                               # Group by country name\n  slice_max(order_by = pop_est, n = 1) |&gt;         # Retain country entry with max population estimate\n  left_join(cia_data) |&gt;                          # Join with CIA Factbook data\n  filter(!is.na(population)) |&gt;                   # Filter out entries without population data\n  st_transform(crs = 3857) |&gt;                     # Transform to Psuedo-Mercator projection (CRS = 3857)\n  ungroup()\n\n\n\n\n\n\n\n\nTable 2: The sf object morld map to be used in the susequent analysis\n\n\n\n\n\n\n\n\n\nName\nPop Est\nIso a 3\nCountry\nArea\nBirth Rate\nDeath Rate\nInfant Mortality Rate\nInternet Users\nLife Exp at Birth\nMaternal Mortality Rate\nNet Migration Rate\nPopulation\nPopulation Growth Rate\n\n\n\n\nAfghanistan\n38,041,754\nAFG\nAfghanistan\n652,230\n38.8\n14.1\n117.2\n1,000,000.0\n50.5\n460.0\n−1.8\n31,822,848\n2.3\n\n\nAlbania\n2,854,191\nALB\nAlbania\n28,748\n12.7\n6.5\n13.2\n1,300,000.0\n78.0\n27.0\n−3.3\n3,020,209\n0.3\n\n\nAlgeria\n43,053,054\nDZA\nAlgeria\n2,381,741\n24.0\n4.3\n21.8\nNA\n76.4\n97.0\n−0.9\n38,813,722\n1.9\n\n\nAngola\n31,825,295\nAGO\nAngola\n1,246,700\n39.0\n11.7\n80.0\nNA\n55.3\n450.0\n0.5\n19,088,106\n2.8\n\n\nArgentina\n44,938,712\nARG\nArgentina\n2,780,400\n16.9\n7.3\n10.0\n13,694,000.0\n77.5\n77.0\n0.0\n43,024,374\n0.9\n\n\nArmenia\n2,957,731\nARM\nArmenia\n29,743\n13.9\n9.3\n14.0\n208,200.0\n74.1\n30.0\n−5.9\n3,060,631\n−0.1\n\n\nAustralia\n25,364,307\nAUS\nAustralia\n7,741,220\n12.2\n7.1\n4.4\n15,810,000.0\n82.1\n7.0\n5.7\n22,507,617\n1.1\n\n\nAustria\n8,877,067\nAUT\nAustria\n83,871\n8.8\n10.4\n4.2\n6,143,000.0\n80.2\n4.0\n1.8\n8,223,062\n0.0\n\n\nAzerbaijan\n10,023,318\nAZE\nAzerbaijan\n86,600\n17.0\n7.1\n26.7\n2,420,000.0\n71.9\n43.0\n0.0\n9,686,210\n1.0\n\n\nBahamas\n389,482\nBHS\nBahamas, The\n13,880\n15.6\n7.0\n12.5\n115,800.0\n71.9\n47.0\n0.0\n321,834\n0.9\n\n\nBangladesh\n163,046,161\nBGD\nBangladesh\n143,998\n21.6\n5.6\n45.7\n617,300.0\n70.7\n240.0\n0.0\n166,280,712\n1.6\n\n\nBelarus\n9,466,856\nBLR\nBelarus\n207,600\n10.9\n13.5\n3.6\n2,643,000.0\n72.2\n4.0\n0.8\n9,608,058\n−0.2\n\n\nBelgium\n11,484,055\nBEL\nBelgium\n30,528\n10.0\n10.8\n4.2\n8,113,000.0\n79.9\n8.0\n1.2\n10,449,361\n0.0\n\n\nBelize\n390,353\nBLZ\nBelize\n22,966\n25.1\n6.0\n20.3\n36,000.0\n68.5\n53.0\n0.0\n340,844\n1.9\n\n\nBenin\n11,801,151\nBEN\nBenin\n112,622\n36.5\n8.4\n57.1\nNA\n61.1\n350.0\n0.0\n10,160,556\n2.8\n\n\nBhutan\n763,092\nBTN\nBhutan\n38,394\n18.1\n6.8\n37.9\n50,000.0\n69.0\n180.0\n0.0\n733,643\n1.1\n\n\nBolivia\n11,513,100\nBOL\nBolivia\n1,098,581\n23.3\n6.6\n38.6\n1,103,000.0\n68.5\n190.0\n−0.7\n10,631,486\n1.6\n\n\nBosnia and Herz.\n3,301,000\nBIH\nBosnia and Herzegovina\n51,197\n8.9\n9.6\n5.8\n1,422,000.0\n76.3\n8.0\n−0.4\n3,871,643\n−0.1\n\n\nBotswana\n2,303,697\nBWA\nBotswana\n581,730\n21.3\n13.3\n9.4\n120,000.0\n54.1\n160.0\n4.6\n2,155,784\n1.3\n\n\nBrazil\n211,049,527\nBRA\nBrazil\n8,514,877\n14.7\n6.5\n19.2\n75,982,000.0\n73.3\n56.0\n−0.1\n202,656,788\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\nKey Learning: Using geom_text_repel() in place of geom_text_sf() with stat = \"sf_coordinates\"\nIn this code, we generate two versions of a world map using the Mercator projection (CRS = 3857). The first plot demonstrates how using geom_sf_text() without any adjustment can lead to overlapping labels, particularly in densely populated areas. The second plot corrects this with geom_text_repel() from the {ggrepel} package (Slowikowski 2024), which dynamically adjusts label positions to prevent overlap and improve readability. Each map includes labels based on country name, and the label sizes vary by population, offering a clear contrast between the two approaches for displaying map text labels.\n\n\nCode\n# Plot the transformed world map data with overlapping labels\ng &lt;- ggplot(world_map) +\n  \n  # Draws the base map with country shapes\n  geom_sf(\n    linewidth = 0.1\n  ) +    \n  \n  # Adds country names as labels, without overlap prevention\n  geom_sf_text(\n    mapping = aes(\n      label = country\n    )\n  ) +\n  \n  # Applies a minimal theme for a clean visual layout\n  theme_minimal() +           \n  \n  # Sets title, subtitle, and caption for the plot\n  labs(\n    title = \"World Map: Labels Overlapping when using geom_sf_text()\",\n    subtitle = \"Map in the Mercator Projection (CRS = 3857)\",\n    caption = \"Source: {rnaturalearth} package data retrieved with ne_countries() function\"\n  ) +\n  \n  theme(\n    panel.grid = element_line(\n      linewidth = 0.1\n    )\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"cartogram_types_1.png\"),\n  plot = g,\n  height = 600,\n  width = 800,\n  units = \"px\"\n)\n\n# Plot the transformed world map data with repelled labels\ng &lt;- ggplot(world_map) +\n  \n  # Draws the base map with country shapes\n  geom_sf(\n    linewidth = 0.1,       # Sets line width for label positioning\n    colour = \"grey10\"\n  ) +    \n  \n  # Adds country names as labels with repel effect to prevent overlap\n  geom_text_repel(\n    mapping = aes(\n      label = country,\n      geometry = geometry,\n      size = population\n    ),\n    stat = \"sf_coordinates\",   # Sets the stat for spatial coordinates\n    family = \"caption_font\",   # Sets the font family for labels\n    force_pull = 100,\n    force = 0.01,\n    linewidth = 0.01\n  ) +\n  \n  # Scales the size of labels based on population\n  scale_size_continuous(\n    range = c(5, 25)\n  ) +\n  \n  # Applies a minimal theme for a clean visual layout\n  theme_minimal(\n    base_size = 80\n  ) +    \n    \n  # Sets title, subtitle, and caption for the plot\n  labs(\n    title = \"World Map: Labels with geom_text_repel() with stat = \\\"sf_coordinates\\\"\",\n    caption = \"Source: {rnaturalearth} package data retrieved with ne_countries() function\",\n    x = NULL, y = NULL\n  ) +\n  \n  # Removes the legend for size\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_line(\n      linewidth = 0.01\n    )\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\",\n                        \"images\",\n                        \"cartogram_types_2.png\"),\n  plot = g,\n  height = 3700,\n  width = 4900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: Basic World Map: With no effort to prevent overlapping of labels\n\n\n\n\n\n\n\n\n\nFigure 2: Labels Repelled from each other to prevent overlapping, using geom_text_repel() from package {ggrepel}\n\n\n\n\n\nStep 3: Converting geometry into Cartograms geometry using {cartogram}\nIn this step, we generate three types of cartograms based on population data, each offering a unique way to represent global population distribution using the {cartogram} package. First, we transform the world map data to the Mercator projection (EPSG 3857), which is the standard projection for web maps. We then create three cartograms:\n\na contiguous cartogram that distorts countries proportionally to population while maintaining geographic adjacency,\na Dorling cartogram that represents each country as a circle sized by population, and\na non-contiguous cartogram that allows countries to resize independently, resulting in more accurate shapes but less geographic continuity.\n\n\n# Transforming the data to different cartogram types based on population\n\n# Create a contiguous cartogram where countries maintain adjacency\nworld_map_cont &lt;- cartogram::cartogram_cont(world_map, \"population\")\n\n# Create a Dorling cartogram where each country is represented by a circle\nworld_map_dorling &lt;- cartogram::cartogram_dorling(world_map, \"population\")\n\n# Create a non-contiguous cartogram where countries resize independently\nworld_map_ncont &lt;- cartogram::cartogram_ncont(world_map, \"population\")\n\n\n\n\nResults\n\nType 1: A Continuous Cartogram\nIn this code, we generate a contiguous cartogram plot, shown in Figure 3, using {ggplot2} and {sf} libraries, with countries sized according to population. The code begins by arranging world_map_cont in descending order of population (so that the countries with larger population are displayed first, while we use the argument check_overlap = TRUE with geom_sf_text(). The cartogram plot is created using geom_sf() for shapes and geom_sf_text() for country labels, with label sizes reflecting population. Manual scales are applied to align fill and text colors with predefined palettes. The plot includes a centered title and minimal theme.\n\n\nCode\n# Arrange the cartogram data by population in descending order\ng &lt;- world_map_cont |&gt; \n  arrange(desc(population)) |&gt; \n\n# Initialize ggplot, mapping fill and color aesthetics to country\n  ggplot(\n    mapping = aes(\n      fill = country,\n      colour = country\n    )\n  ) +\n\n# Add the country shapes without borders\n  geom_sf(\n    colour = \"transparent\"\n  ) +\n\n# Add text labels for each country with size proportional to population\n  geom_sf_text(\n    mapping = aes(\n      label = country,\n      size = population,\n      geometry = geometry\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = TRUE\n  ) +\n\n# Set continuous scale for text size within a specified range\n  scale_size_continuous(\n    range = c(1, 10)\n  ) +\n\n# Apply manual color scale for fill and outline of countries\n  scale_fill_manual(\n    values = fill_palette\n  ) +\n  scale_colour_manual(\n    values = colour_palette\n  ) +\n\n# Add plot title and remove x and y axis labels\n  labs(\n    x = NULL, y = NULL,\n    title = \"A contiguous Cartogram of countries' population\"\n  ) +\n\n# Apply a minimal theme with custom font and size\n  theme_minimal(\n    base_family = \"caption_font\",\n    base_size = 16\n  ) +\n\n# Customize plot appearance with centered title and invisible legend\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_line(\n      colour = \"grey90\",\n      linetype = 3,\n      linewidth = 0.1\n    ),\n    plot.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\"),\n      size = 32\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# Save the plot as a PNG with defined size and white background\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"cartogram_types_3.png\"),\n  height = 900,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 3: A World Map Cartogram, with countries sized by population, using data from CIA World Factbook. The contiguous cartogram ensures that neighbousing countries keep touching each other, although shapes are distorted.\n\n\n\n\n\nType 2: A Non-continuous Cartogram\nThe next code chunk generates a non-contiguous cartogram, shown in Figure 4, where countries are resized according to population but maintain their original shapes, making it easier to recognize familiar geographic forms.. It uses two layers of geom_sf() to add the original world map with a grey outline for context and the resized cartogram countries with a semi-transparent overlay. Text labels are added for each country, sized by population, without overlapping.\n\n\nCode\n# Arrange the non-contiguous cartogram data by population in descending order\ng &lt;- world_map_ncont |&gt; \n  arrange(desc(population)) |&gt; \n\n# Initialize ggplot, mapping fill and color aesthetics to country\n  ggplot(\n    mapping = aes(\n      fill = country,\n      colour = country\n    )\n  ) +\n\n# Add the original world map with grey borders and white fill\n  geom_sf(\n    data = world_map,\n    fill = \"white\",\n    colour = \"grey60\",\n    linewidth = 0.1\n  ) +\n\n# Add the non-contiguous cartogram countries with transparency\n  geom_sf(\n    colour = \"transparent\",\n    alpha = 0.75\n  ) +\n\n# Add text labels for each country with size proportional to population\n  geom_sf_text(\n    mapping = aes(\n      label = country,\n      size = population,\n      geometry = geometry\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\",\n    check_overlap = FALSE\n  ) +\n\n# Set continuous scale for text size within a specified range\n  scale_size_continuous(\n    range = c(1, 10)\n  ) +\n\n# Apply manual color scale for fill and outline of countries\n  scale_fill_manual(\n    values = fill_palette\n  ) +\n  scale_colour_manual(\n    values = colour_palette\n  ) +\n\n# Add plot title and remove x and y axis labels\n  labs(\n    x = NULL, y = NULL,\n    title = \"A non-contiguous Cartogram of countries' population - preserves the country shapes\"\n  ) +\n\n# Apply a minimal theme with custom font and size\n  theme_minimal(\n    base_family = \"caption_font\",\n    base_size = 16\n  ) +\n\n# Customize plot appearance with centered title and invisible legend\n  theme(\n    legend.position = \"none\",\n    panel.grid = element_line(\n      colour = \"grey90\",\n      linetype = 3,\n      linewidth = 0.1\n    ),\n    plot.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\"),\n      size = 28\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# Save the plot as a PNG with defined size and white background\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"cartogram_types_4.png\"),\n  height = 900,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: A non-contiguous cartogram of countries population, using data from CIA Factbook, shows that while shapes of countries are preserved, their neighbouring countries don’t touch each others’ borders anymore.\n\n\n\n\n\nType 3: A non-overlapping circles Cartogram\nThis code snippet creates a Dorling cartogram, shown in Figure 5, where countries are represented as non-overlapping circles sized according to their populations. The ggplot function is used to set up the aesthetic mappings for fill and color based on the country. The geom_sf() function is employed to add the circular representations of countries without outlines, while geom_sf_text() adds text labels for each country, sized according to their populations.\n\n\nCode\n# Arrange the Dorling cartogram data by population in descending order\ng &lt;- world_map_dorling |&gt; \n  arrange(desc(population)) |&gt; \n\n# Initialize ggplot, mapping fill and color aesthetics to country\n  ggplot(\n    mapping = aes(\n      fill = country,\n      colour = country\n    )\n  ) +\n\n# Add the non-overlapping circles representing countries\n  geom_sf(\n    colour = \"transparent\"\n  ) +\n\n# Add text labels for each country, sized by population\n  geom_sf_text(\n    mapping = aes(\n      label = country,\n      size = population,\n      geometry = geometry\n    ),\n    family = \"caption_font\",\n    fontface = \"bold\"\n  ) +\n\n# Set continuous scale for text size within a specified range\n  scale_size_continuous(\n    range = c(1, 10)\n  ) +\n\n# Apply manual color scale for fill and Text of countries\n  scale_fill_manual(\n    values = fill_palette\n  ) +\n  scale_colour_manual(\n    values = colour_palette\n  ) +\n\n# Add plot title and remove x and y axis labels\n  labs(\n    x = NULL, y = NULL,\n    title = \"A non-overlapping circles Cartogram of countries' population.\"\n  ) +\n\n# Apply a map theme with custom font and size\n  ggthemes::theme_map(\n    base_family = \"caption_font\",\n    base_size = 16\n  ) +\n\n# Customize plot appearance with centered title and invisible legend\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n      hjust = 0.5,\n      margin = margin(0,0,0,0, \"mm\"),\n      size = 28\n    ),\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\n# Save the plot as a PNG with defined size and white background\nggsave(\n  plot = g,\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"cartogram_types_5.png\"),\n  height = 900,\n  width = 1200,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\n\n\n\n\nReferences\n\nJeworutzki, Sebastian. 2023. “Cartogram: Create Cartograms with r.” https://CRAN.R-project.org/package=cartogram.\n\n\nPebesma, Edzer, and Roger Bivand. 2023. “Spatial Data Science: With Applications in r.” https://doi.org/10.1201/9780429459016.\n\n\nSlowikowski, Kamil. 2024. “Ggrepel: Automatically Position Non-Overlapping Text Labels with ’Ggplot2’.” https://CRAN.R-project.org/package=ggrepel.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the Tidyverse” 4: 1686. https://doi.org/10.21105/joss.01686."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-1-setting-up-basics",
    "href": "geocomputation/osm_driving_directions.html#step-1-setting-up-basics",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 1: Setting up basics",
    "text": "Step 1: Setting up basics\nThis code initializes an R project for geospatial data analysis and visualization, utilizing multiple packages for enhanced map presentation, styling, and data wrangling:\n\nData Handling & Visualization: Packages like tidyverse provide core data manipulation tools and ggplot2 for visualizations.\nSpatial Data Management: sf simplifies handling spatial objects in a tidy framework, and osrm connects R to the Open Source Routing Machine for geospatial route calculations.\nGeocoding: tidygeocoder automates address-based geocoding.\nMap Enhancements: ggspatial adds visual elements like scale bars; ggrepel prevents overlapping labels for clear visuals.\nCustom Fonts: sysfonts and showtext allow use of Google Fonts, applied through a custom theme.\nPlot Layouts & Tables: patchwork enables combining ggplot plots, and gt produces elegant HTML tables.\n\nThe code defines custom fonts for plot titles and body text using Google Fonts (e.g., “Barlow”) and sets up a theme function, theme_drive, for applying a modern, minimal aesthetic in ggplot2. It also specifies text color and font-family defaults for labels in plots.\n\n\nCode\nlibrary(tidyverse)     # Data Wrangling and ggplot2\nlibrary(sf)            # Handle spatial data in R in a tidy way\nlibrary(tidygeocoder)  # Automated geocoding of addresses\nlibrary(osrm)          # Access OSRM through R\nlibrary(ggrepel)       # Nicer non-overlapping labels\nlibrary(glue)          # Easier string interpolation\nlibrary(scales)        # Nicer labeling functions\nlibrary(patchwork)     # Combine plots made in ggplot2\nlibrary(ggspatial)     # Nicer map features like scale bars\nlibrary(showtext)      # Displaying google fonts\nlibrary(sysfonts)      # Getting google fonts into R\nlibrary(gt)            # Displaying beautiful HTML tables \n\n# A font for the titles and major points\nsysfonts::font_add_google(\"Barlow\", \"title_font\")\n\n# A font for the body and text\nsysfonts::font_add_google(\"Barlow Condensed\", \"body_font\")\n\n# Allow R graphics devices to display these fonts\nshowtext::showtext_auto()\n\n# Text colour\ntext_col &lt;- \"grey20\"\n\n# Custom ggplot theme to make pretty plots\n# Get the font at https://fonts.google.com/specimen/Overpass\n\ntheme_drive &lt;- function(...) {\n  theme_void(\n    base_family = \"body_font\",\n    base_size = 14\n  ) +\n  theme(\n    text = element_text(\n      colour = text_col,\n      family = \"body_font\",\n      hjust = 0.5\n    ),\n    ...\n  )\n}\n\n# Make labels use the fonts specified by default\nupdate_geom_defaults(\"label_repel\", list(family = \"body_font\",\n                                         colour = text_col))\nupdate_geom_defaults(\"label\", list(family = \"body_font\",\n                                         colour = text_col))\nupdate_geom_defaults(\"text_repel\", list(family = \"body_font\",\n                                         colour = text_col))\nupdate_geom_defaults(\"text\", list(family = \"body_font\",\n                                         colour = text_col))"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-2-a-road-trip-plan",
    "href": "geocomputation/osm_driving_directions.html#step-2-a-road-trip-plan",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 2: A Road Trip Plan",
    "text": "Step 2: A Road Trip Plan\nLet us plan a road trip along the northern shores of the Mediterranean Sea, hopping along the famous sites in the capitals and important cities of some countries. This code snippet uses R to create a table of famous attractions across several European countries, geocodes each location to obtain its latitude and longitude, and displays the data in a formatted table with map coordinates:\n\nData Setup: A sample dataset is created with columns for country, capital, attraction, and address using dplyr.\nGeocoding: The tidygeocoder package is used to automatically retrieve latitude and longitude coordinates based on the address, using OpenStreetMap’s geocoding service.\nSpatial Transformation: Once coordinates are obtained, sf converts them into a simple feature (SF) object, setting the coordinate system to EPSG:4326 for geographic data.\nTabular Display: The data is formatted as a stylish HTML table using gt and gtExtras for theme styling.\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(gt)\n\nrawdata &lt;- dplyr::tribble(\n  ~id, ~country,               ~capital,    ~attraction,                   ~address,\n  1,   \"Greece\",               \"Athens\",    \"Acropolis Museum\",            \"15 Dionysiou Areopagitou St, Athens 11742\",\n  2,   \"Albania\",              \"Tirana\",    \"Skanderbeg Square\",           \"Sheshi Skënderbej, Tirana 1001\",\n  3,   \"Montenegro\",           \"Podgorica\", \"Millennium Bridge\",           \"Cetinjski Put, Podgorica 81000\",\n  4,   \"Bosnia and Herzegovina\",\"Sarajevo\", \"Baščaršija (Old Bazaar)\",     \"Baščaršija, Sarajevo 71000\",\n  5,   \"Croatia\",              \"Zagreb\",    \"Ban Jelačić Square\",          \"Trg bana Josipa Jelačića, Zagreb 10000\",\n  6,   \"Slovenia\",             \"Ljubljana\", \"Ljubljana Castle\",            \"Grajska planota 1, Ljubljana 1000\",\n  7,   \"Italy\",                \"Venice\",    \"St. Mark's Basilica\",         \"Piazza San Marco, Venice 30124\",\n  8,   \"Italy\",                \"Florence\",  \"Piazza del Duomo\",            \"Piazza del Duomo, Florence 50122\",\n  9,   \"Italy\",                \"Rome\",      \"Trevi Fountain\",              \"Piazza di Trevi, Rome 00187\"\n)\n\n\n# Convert latitude and longitudes into SF Coordinates\n\n\ndf &lt;- rawdata |&gt; \n  \n  # Compile a full address to be used for finding the coordinates\n  # mutate(\n  #   address = paste(\n  #     destination,\n  #     capital, \n  #     country,\n  #     sep = \", \"\n  #   )\n  # ) |&gt; \n  tidygeocoder::geocode(\n    address = address,\n    # country = country,\n    # city = capital,\n    method = \"osm\"\n  ) |&gt; \n  st_as_sf(\n    coords = c(\"long\", \"lat\"),\n    crs = st_crs(\"EPSG:4326\")\n  )\n\n\n\n\n\n\nTable 1: The data to be used for further analysis\n\n\n\n\n\n\n\n\n\nid\ncountry\ncapital\nattraction\naddress\ngeometry\n\n\n\n\n1\nGreece\nAthens\nAcropolis Museum\n15 Dionysiou Areopagitou St, Athens 11742\nc(23.7302954, 37.9303789)\n\n\n2\nAlbania\nTirana\nSkanderbeg Square\nSheshi Skënderbej, Tirana 1001\nc(19.8182412, 41.3271148)\n\n\n3\nMontenegro\nPodgorica\nMillennium Bridge\nCetinjski Put, Podgorica 81000\nc(19.2436765, 42.4413965)\n\n\n4\nBosnia and Herzegovina\nSarajevo\nBaščaršija (Old Bazaar)\nBaščaršija, Sarajevo 71000\nc(18.430885, 43.8590435)\n\n\n5\nCroatia\nZagreb\nBan Jelačić Square\nTrg bana Josipa Jelačića, Zagreb 10000\nc(15.9765701, 45.8130054)\n\n\n6\nSlovenia\nLjubljana\nLjubljana Castle\nGrajska planota 1, Ljubljana 1000\nc(14.5085094926128, 46.0488354)\n\n\n7\nItaly\nVenice\nSt. Mark's Basilica\nPiazza San Marco, Venice 30124\nc(12.3385088944988, 45.4342591)\n\n\n8\nItaly\nFlorence\nPiazza del Duomo\nPiazza del Duomo, Florence 50122\nc(11.2554773666595, 43.7731014)\n\n\n9\nItaly\nRome\nTrevi Fountain\nPiazza di Trevi, Rome 00187\nc(12.4836123990993, 41.90089955)"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-3-some-custom-functions",
    "href": "geocomputation/osm_driving_directions.html#step-3-some-custom-functions",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 3: Some Custom Functions",
    "text": "Step 3: Some Custom Functions\nThis code defines a set of custom functions in R to format durations, distances, and handle conversions between different units, useful for working with geographic and travel data:\n\nFormatting Durations: fmt_duration() takes an input in minutes and converts it into a readable string format. Durations are rounded to the nearest 15 minutes and formatted to display in hours and minutes. When durations exceed 24 hours, days are factored into the calculation by converting them to hours for accurate display.\nDistance Formatting:\n\nfmt_miles and fmt_km utilize scales::label_number() to format distances in miles and kilometers, respectively, with suffixes and thousand separators for clarity.\n\nDistance Conversions: Functions for converting between miles, meters, and kilometers:\n\nmiles_to_meters() converts miles to meters.\nmeters_to_miles() and km_to_miles() handle conversions from meters and kilometers to miles.\n\n\n\n\nCode\n# Credits: Andrew Weiss\n# URL: https://www.andrewheiss.com/blog/2023/06/01/\n#      geocoding-routing-openstreetmap-r/#packages-and-functions\n\n# Format duration in minutes and hours\n# This function takes a numeric input of a duration in minutes,\n# rounds it to the nearest 15 minutes, and formats the result as a string\n# indicating the number of hours and minutes in the duration.\n\nfmt_duration &lt;- function(x) {\n  \n  # Round to the nearest 15 minutes\n  n_seconds &lt;- round(seconds(x * 60) / (15 * 60)) * (15 * 60)\n  n_seconds &lt;- seconds_to_period(n_seconds)\n  \n  out &lt;- map_chr(n_seconds, \\(n) {\n    if (seconds(n) &lt;= 59) {\n      # If this is less than an hour, don't format anything with hours\n      glue(\"{MM} minutes\", MM = minute(n))\n    } else {\n      # The formatting is required in terms of hours only. When the \n      # duration exceeds 24 hours, `seconds_to_period()` converts the \n      # duration into days (e.g., `seconds_to_period(60 * 60 * 24)` returns \n      # \"1d 0H 0M 0S\") and displays zero hours. Therefore, the day portion \n      # of the period is extracted, multiplied by 24, and added to the \n      # hour component intended for display. \n      extra_day_hours &lt;- day(n) * 24\n  \n      glue(\"{HH} hour{s} {MM} minutes\",\n        HH = scales::label_comma()(hour(n) + extra_day_hours),\n        MM = minute(n),\n        s = ifelse(hour(n) == 1, \"\", \"s\")\n      )\n    }\n  })\n  \n  return(out)\n}\n\nfmt_miles &lt;- scales::label_number(\n  accuracy = 10, \n  suffix = \" miles\", \n  big.mark = \",\"\n  )\n\nfmt_km &lt;- scales::label_number(\n  accuracy = 10, \n  suffix = \" km\", \n  big.mark = \",\"\n  )\n\n\nmiles_to_meters &lt;- function(x) {\n  x * 1609.344\n}\n\nmeters_to_miles &lt;- function(x) {\n  x / 1609.344\n}\n\nkm_to_miles &lt;- function(x) {\n  meters_to_miles(x * 1000)\n}"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-4-the-base-map-and-the-driving-locations",
    "href": "geocomputation/osm_driving_directions.html#step-4-the-base-map-and-the-driving-locations",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 4: The base map and the driving locations",
    "text": "Step 4: The base map and the driving locations\nThis code creates a custom map showing key tourist attractions within the calculated bounding box of selected European countries:\n\nBounding Box Calculation:\n\nThe bounding box for mapped points is set with an additional degree of expansion (edi), extending the box slightly around all locations. This is calculated with st_bbox() using geometries in df.\n\nBasemap Creation:\n\nA basemap of European countries is created using rnaturalearth data, filtering out small states like Vatican City and San Marino. The map’s area data is computed for further customization if needed.\n\nMap Plotting:\n\nggplot2 and sf add visual layers:\n\nCountry boundaries as background with geom_sf().\nCountry names with partially transparent, bold labels via geom_sf_text().\nTourist attraction points and city names using red markers and labels.\n\n\n\n\n\nCode\n# Compute the bounding box for the maps\n# Expansion outside bounding box in degrees = edi\nedi = 0.5\ndrive_bbox &lt;- st_bbox(df$geometry) + c(-2 * edi, -2.5 * edi, edi, edi)\n\n\nbasemap &lt;- rnaturalearth::ne_countries(scale = 50) |&gt;\n  select(name, iso_a3, geometry) |&gt; \n  filter(!(name %in% c(\"Vatican\", \"San Marino\"))) |&gt; \n  st_crop(drive_bbox) |&gt; \n  mutate(area = as.numeric(st_area(geometry)))\n\ng &lt;- ggplot(basemap) +\n  geom_sf() +\n  geom_sf_text(\n    mapping = aes(\n      label = name\n    ),\n    alpha = 0.5,\n    fontface = \"bold\",\n    nudge_y = +0.3\n  ) +\n  geom_sf(\n    data = df,\n    colour = \"darkred\",\n    size = 2,\n    alpha = 0.5\n  ) +\n  geom_sf_text(\n    data = df,\n    mapping = aes(label = capital),\n    colour = \"darkred\",\n    nudge_y = -0.2\n  ) +\n  labs(x = NULL, y = NULL)\n\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_4.png\"),\n  plot = g,\n  height = 900,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 1: A basic map showing the selected cities and the map of selected countries using data available in {rnaturalearth} and ne_countries()"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-5-getting-the-routes-and-a-raw-map-of-the-routes",
    "href": "geocomputation/osm_driving_directions.html#step-5-getting-the-routes-and-a-raw-map-of-the-routes",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 5: Getting the Routes and a raw map of the routes",
    "text": "Step 5: Getting the Routes and a raw map of the routes\nThis code generates a visual map illustrating the shortest driving routes between selected European cities, based on OpenStreetMap data:\n\nRoute Data Preparation:\n\nStarting with df (containing cities and their coordinates), cities are paired sequentially as origins and destinations using lead(). The data is trimmed to exclude the final unpaired row.\nosrmRoute() retrieves the shortest driving route between each origin and destination pair, with the computed route details stored in a nested column named route.\n\nUnnesting and Formatting:\n\nThe route column is expanded to reveal route-specific data (geometry, distance, duration). Route geometry is then set as the primary spatial feature.\nCustom functions fmt_km() and fmt_duration() format the route’s distance and duration for clear labeling.\n\nMap Plotting:\n\nggplot2 visualizes the data in layers:\n\nA basemap of European countries, created earlier, serves as the background.\nCities are marked in red, with labels for capital cities slightly adjusted for readability.\nDriving routes between cities are drawn as connecting lines using the computed route_geometry.\n\n\n\n\n\nCode\ndfroutes &lt;- df|&gt; \n  rename(\n    origin_geometry = geometry,\n    origin_city = capital\n  ) |&gt;  \n  mutate(\n    destination_geometry = lead(origin_geometry),\n    destination_city = lead(origin_city)\n  )  |&gt; \n  slice_head(n = (nrow(df) - 1)) |&gt; \n  \n  # Let functions compute on our data frame a row-at-a-time\n  rowwise() |&gt; \n  \n  # Getting the shortest route between the two cities\n  mutate(route = osrmRoute(\n    src = origin_geometry, \n    dst = destination_geometry)\n  ) |&gt; \n\n# The route details are stored in a nested list column called `route`, # which we’ll unnest. This produces a data frame with three geometry \n# columns—for origin, destination, and route—so we’ll set the route \n# column as the primary geometry (allowing us to use `geom_sf(data = routes_geocoded)` directly).\n  \n  unnest(route, names_sep = \"_\") |&gt; \n  st_set_geometry(\"route_geometry\") |&gt; \n  mutate(\n    distance_text = fmt_km(route_distance),\n    duration_text = fmt_duration(route_duration)\n  )\n\n\n\n\nCode\ng &lt;- ggplot() +\n  geom_sf(\n    data = basemap\n  ) +\n  geom_sf(\n    data = df,\n    colour = \"red\",\n    size = 3\n  ) +\n  geom_sf_text(\n    data = df,\n    aes(label = capital),\n    nudge_y = -0.3,\n    size = 5\n  ) +\n  geom_sf(\n    data = dfroutes,\n    mapping = aes(\n      geometry = route_geometry\n    )\n  ) +\n  labs(\n    x = NULL, y = NULL\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_2.png\"),\n  plot = g,\n  height = 900,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 2: A simple map of the country boundaries [from {rnaturalearth} and function ne_countries()] with the route computed by osrmRoute() from {osrm} and selected destination cities as red dots."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-6-a-nice-stadia-map-background-map",
    "href": "geocomputation/osm_driving_directions.html#step-6-a-nice-stadia-map-background-map",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 6: A nice Stadia Map background map",
    "text": "Step 6: A nice Stadia Map background map\nThis code retrieves and customizes a basemap using Stadia Maps, overlaying it with geospatial data in EPSG:3857, a coordinate reference system commonly used for web mapping.\n\nAPI Setup:\n\nThe Stadia Maps API is registered with the register_stadiamap() function, allowing access to map tiles.\n\nBounding Box Definition:\n\nA bounding box (dv_bbox) is defined using the limits of the area of interest. The bounding box is adjusted to Stadia Maps’ format, setting boundaries based on longitude and latitude.\n\nFetching Map Tiles:\n\nget_stadiamap() retrieves map tiles with terrain background style (maptype = \"stamen_terrain_background\"), appropriate for visualizing geographic contexts.\n\nCoordinate System Transformation:\n\nA custom function, ggmap_bbox(), redefines the map’s bounding box to EPSG:3857, necessary for layering sf objects over the raster map. This transformation is critical for accurate overlay alignment.\n\nMap Overlay and Export:\n\nUsing ggmap(), the transformed Stadia basemap is displayed. The map, including overlaid geospatial features, is saved as a high-resolution image (osm_driving_directions_3.png) with ggsave().\n\n\n\n\nCode\n# ggmap::register_stadiamap(\"YOUR API KEY HERE\")\n\n# A bounding box in the format c(lowerleftlon, lowerleftlat, upperrightlon, upperrightlat)\ndv_bbox &lt;- drive_bbox\nnames(dv_bbox) &lt;- c(\"left\", \"bottom\", \"right\", \"top\")\n\n\n# Getting the map tiles\nbasemap2 &lt;- ggmap::get_stadiamap(\n  bbox = dv_bbox,\n  zoom = 7,\n  maptype = \"stamen_terrain_background\"\n)\nobject.size(basemap2) |&gt; print(units = \"Mb\")\n\nggmap::ggmap(basemap2)\n\n# Starting the process of Overlaying the geom_sf() data on this\n# Most important is to add the inherit.aes = FALSE argument.\n\n# Step: 1: \n# Credits: https://stackoverflow.com/questions/47749078/how-to-put-a-geom-sf-produced-map-on-top-of-a-ggmap-produced-raster by andyteucher on StackOverFlow (https://stackoverflow.com/users/1736291/andyteucher)\n\n# Define a function to fix the bbox to be in CRS EPSG:3857\nggmap_bbox &lt;- function(map) {\n  # Extract the bounding box (in lat/lon) from the ggmap\n  # to a numeric vector, and set the names to what\n  # sf::st_bbox expects:\n  map_bbox &lt;- setNames(\n    unlist(attr(map, \"bb\")),\n    c(\"ymin\", \"xmin\", \"ymax\", \"xmax\")\n  )\n\n  # Coonvert the bbox to an sf polygon, transform it to 3857,\n  # and convert back to a bbox (convoluted, but it works)\n  bbox_3857 &lt;- st_bbox(\n    st_transform(\n      st_as_sfc(\n        st_bbox(map_bbox, crs = 4326)\n        ), \n      3857\n    )\n  )\n\n  # Overwrite the bbox of the ggmap object with the transformed coordinates\n  attr(map, \"bb\")$ll.lat &lt;- bbox_3857[\"ymin\"]\n  attr(map, \"bb\")$ll.lon &lt;- bbox_3857[\"xmin\"]\n  attr(map, \"bb\")$ur.lat &lt;- bbox_3857[\"ymax\"]\n  attr(map, \"bb\")$ur.lon &lt;- bbox_3857[\"xmax\"]\n  map\n}\n\n# Use the function to convert our downloaded Raster Files into \n# the new CRS and new bounding box CRS\nbasemap_sf &lt;- ggmap_bbox(basemap2)\n\ng &lt;- ggmap::ggmap(basemap2) +\n  labs(x = NULL, y = NULL)\n\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_3.png\"),\n  plot = g,\n  height = 900,\n  width = 900,\n  units = \"px\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 3: The base map retrieved in the form of raster tiles, from {ggmap} using get_stadia_maps() with the map style “Stamen Terrain Background”"
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-7-the-overall-visualization",
    "href": "geocomputation/osm_driving_directions.html#step-7-the-overall-visualization",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 7: The overall visualization",
    "text": "Step 7: The overall visualization\nThis code snippet enhances the base map by overlaying spatial data, labels, and route details, creating a rich, layered map visualization with ggplot2 and ggmap. Here’s a breakdown of each step:\n\nBasemap Layer:\n\nUses ggmap::ggmap(basemap_sf) to display the raster map tiles retrieved and adjusted to EPSG:3857, enabling overlays of geospatial objects.\n\nCountry Boundaries and Names:\n\ngeom_sf() with transparency and thin lines adds country outlines, while geom_sf_text() displays country names proportionally sized by area.\n\nDriving Route:\n\nThe dfroutes dataset, containing route geometries between destinations, is layered with geom_sf(), color-coded for visibility.\n\nCity Locations and Labels:\n\ngeom_sf() highlights cities in red, while geom_text_repel() labels each city’s name, ensuring labels do not overlap with other map features.\n\nRoute Details:\n\ngeom_sf_label() displays distance labels along the route with partially transparent backgrounds, enhancing readability without cluttering.\n\nCoordinate System and Styling:\n\ncoord_sf() is set to EPSG:3857, matching the basemap. The theme_void() removes unnecessary plot elements for a clean map-focused look, with additional styling adjustments.\n\n\n\n\nCode\n# The base map raster tiles\ng &lt;- ggmap::ggmap(basemap_sf) +\n  \n  # Country boundaries\n  geom_sf(\n    data = basemap,\n    fill = \"transparent\",\n    colour = alpha(text_col, 0.3),\n    inherit.aes = F,\n    linewidth = 0.3\n  ) +\n  \n  # Country names\n  geom_sf_text(\n    data = basemap,\n    mapping = aes(label = name, size = area),\n    alpha = 0.5,\n    fontface = \"bold\",\n    inherit.aes = F\n  ) +\n  scale_size_continuous(range = c(5, 12)) +\n  \n  # The driving route\n  geom_sf(\n    data = dfroutes,\n    mapping = aes(\n      geometry = route_geometry\n    ),\n    inherit.aes = F,\n    colour = alpha(text_col, 0.8),\n    linewidth = 0.5\n  ) +\n  \n  # The cities to be visited\n  geom_sf(\n    data = df,\n    colour = \"red\",\n    size = 3, \n    inherit.aes = F,\n    alpha = 0.5\n  ) +\n  \n  # Names of cities\n  geom_text_repel(\n    data = df,\n    aes(\n      label = capital,\n      geometry = geometry\n    ),\n    inherit.aes = F,\n    stat = \"sf_coordinates\",\n    fontface = \"bold\",\n    size = 8\n  ) +\n  \n  # Route times and distances\n  geom_sf_label(\n    data = dfroutes,\n    mapping = aes(\n      label = paste0(distance_text)\n    ),\n    fill = alpha(\"white\", 0.5),\n    lineheight = 0.3,\n    inherit.aes = F,\n    label.size = unit(0, \"mm\")\n    \n  ) +\n  \n  # Coordinates and Scales\n  coord_sf(\n    crs = 3857\n  ) +\n  theme_void(\n    base_size = 40,\n    base_family = \"body_font\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.margin = margin(0,0,0,0, \"mm\")\n  )\n\nggsave(\n  filename = here::here(\"geocomputation\", \"images\",\n                        \"osm_driving_directions_1.png\"),\n  plot = g,\n  height = 9.25,\n  width = 10,\n  unit = \"cm\",\n  bg = \"white\"\n)\n\n\n\n\n\n\n\n\nFigure 4: The completed overall visualization - with a base map of raster tiles from {ggmap} get_stadia_map(), overlaid country names and boundaries from {rnaturalearth} ne_countries(), and routes from {osrm} package."
  },
  {
    "objectID": "geocomputation/osm_driving_directions.html#step-8-each-leg-of-the-trip-visualized-separately",
    "href": "geocomputation/osm_driving_directions.html#step-8-each-leg-of-the-trip-visualized-separately",
    "title": "Driving Directions using Open Street Maps Routing Service",
    "section": "Step 8: Each leg of the trip visualized separately",
    "text": "Step 8: Each leg of the trip visualized separately\nThis code snippet generates individual map visualizations for each driving route using ggmap and ggplot2. Here’s an explanation of the process, which effectively creates a series of images showcasing routes between pairs of cities:\n\nLoop through Routes:\n\nThe for loop iterates over each row of the dfroutes dataframe, which contains driving route data between origin and destination cities.\n\nDefine Temporary Bounding Box:\n\nFor each route, a temporary bounding box is created using the st_bbox() function and expanded slightly to ensure that the route is well-framed in the map view.\n\nRetrieve Map Tiles:\n\nThe get_stadiamap() function fetches map tiles based on the temporary bounding box, specifying a zoom level and map type (e.g., “outdoors”).\n\nCrop Basemap:\n\nA cropped version of the original country basemap is created to match the bounding box of the current route, ensuring the country boundaries align with the area of interest.\n\nCreate Map Visualization:\n\nggmap::ggmap(temp_basemap) initializes the base map, onto which various layers are added:\n\nCountry Names: Displayed using geom_sf_text(), showing the names of countries within the bounding box.\nDriving Route: The specific route for the current iteration is drawn using geom_sf().\nCities: Both the origin and destination cities are represented with red points using geom_sf().\nCity Labels: City names are added with geom_text_repel(), ensuring that they do not overlap with each other or other elements.\nRoute Details: Distance and duration information are displayed using geom_sf_label(), formatted neatly for clarity.\n\n\nFinalizing the Map:\n\nCoordinate System: Set to EPSG:3857 for compatibility with the base map.\nTheme Adjustments: theme_void() is used to create a clean look, removing axes and grid lines.\n\n\nThis approach results in a series of visually consistent maps, each illustrating a distinct driving route between two cities, complete with detailed annotations and clear geographic context. The display is done using the Tabset Panels layout available in Quarto.\n\n\nCode\nfor (i in 1: nrow(dfroutes)) {\n \n  # A bounding box in the format (left, right, top, bottom) for {ggmap}\n  temp_bbox &lt;- st_bbox(\n    dfroutes |&gt; \n    slice(i)\n    ) + c(-1, -1, 1, 1)\n  names(temp_bbox) &lt;- c(\"left\", \"bottom\", \"right\", \"top\")\n  \n  # Getting the map tiles\n  temp_basemap &lt;- ggmap::get_stadiamap(\n    bbox = temp_bbox,\n    zoom = 8,\n    maptype = \"outdoors\"\n  )  \n  \n  temp_basemap &lt;- ggmap_bbox(temp_basemap)\n  \n  object.size(temp_basemap) |&gt; print(units = \"Mb\")\n  \n  temp_baselinemap &lt;- st_crop(basemap, temp_bbox)\n  \n  # The base map raster tiles\n  g &lt;- ggmap::ggmap(temp_basemap) +\n    \n    # Country boundaries\n    # geom_sf(\n    #   data = temp_baselinemap,\n    #   fill = \"transparent\",\n    #   colour = alpha(text_col, 0.3),\n    #   inherit.aes = F,\n    #   linewidth = 0.3\n    # ) +\n    \n    # Country names\n    geom_sf_text(\n      data = temp_baselinemap,\n      mapping = aes(label = name, size = area),\n      alpha = 0.5,\n      fontface = \"bold\",\n      inherit.aes = F\n    ) +\n    scale_size_continuous(range = c(5, 12)) +\n    \n    # The driving route\n    geom_sf(\n      data = slice(dfroutes, i),\n      mapping = aes(\n        geometry = route_geometry\n      ),\n      inherit.aes = F,\n      colour = alpha(text_col, 0.8),\n      linewidth = 0.5\n    ) +\n    \n    # The cities to be visited: origin\n    geom_sf(\n      data = slice(dfroutes, i),\n      mapping = aes(geometry = origin_geometry),\n      colour = \"red\",\n      size = 3, \n      inherit.aes = F,\n      alpha = 0.4\n    ) +\n    # The cities to be visited: destination\n    geom_sf(\n      data = slice(dfroutes, i),\n      mapping = aes(geometry = destination_geometry),\n      colour = \"red\",\n      size = 3, \n      inherit.aes = F,\n      alpha = 0.4\n    ) +\n    \n    # Names of cities: Origin\n    geom_text_repel(\n      data = slice(dfroutes, i),\n      aes(\n        label = origin_city,\n        geometry = origin_geometry\n      ),\n      inherit.aes = F,\n      stat = \"sf_coordinates\",\n      fontface = \"bold\",\n      size = 8\n    ) +\n    # Names of cities: Destination\n    geom_text_repel(\n      data = slice(dfroutes, i),\n      aes(\n        label = destination_city,\n        geometry = destination_geometry\n      ),\n      inherit.aes = F,\n      stat = \"sf_coordinates\",\n      fontface = \"bold\",\n      size = 8\n    ) +\n    \n    \n    # Route times and distances\n    geom_sf_label(\n      data = slice(dfroutes, i),\n      mapping = aes(\n        label = paste0(\n          distance_text,\n          \"\\n\",\n          \"(\",\n          duration_text,\n          \")\"\n        )\n      ),\n      fill = alpha(\"white\", 0.5),\n      lineheight = 0.3,\n      inherit.aes = F,\n      label.size = unit(0, \"mm\"),\n      size = 5,\n      fontface = \"bold\"\n    ) +\n    \n    # Coordinates and Scales\n    coord_sf(\n      crs = 3857\n    ) +\n    \n    theme_void(\n      base_size = 40,\n      base_family = \"body_font\"\n    ) +\n    theme(\n      legend.position = \"none\",\n      plot.margin = margin(0,0,0,0, \"mm\")\n    )\n  \n  ggsave(\n    filename = here::here(\"geocomputation\", \"images\",\n                          paste0(\"osm_driving_directions_leg\", i, \".png\")),\n    plot = g,\n    height = 6,\n    width = 6,\n    unit = \"cm\",\n    bg = \"white\"\n  )\n   \n}\n\n\n\nLeg 1Leg 2Leg 3Leg 4Leg 5Leg 6Leg 7Leg 8\n\n\n\n\n\n\n\n\nFigure 5: Day 1: Drive from Athens to Tirana.\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Day 2: Drive from Tirana to Padogorica.\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Day 3: Drive from Padogorica to Sarajevo.\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Day 4: Drive from Sarajevo to Zagreb.\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Day 5: Drive from Zagreb to Ljubljana.\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Day 6: Drive from Ljubljana to Venice.\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Day 7: Drive from Venice to Florence.\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Day 8: Drive from Florence to Rome."
  },
  {
    "objectID": "ggplot2_ext.html",
    "href": "ggplot2_ext.html",
    "title": "ggplot2 Extensions",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nSubtitle\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "geocomputation/chapter1.html",
    "href": "geocomputation/chapter1.html",
    "title": "Chapter 2: Geocomputation with R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter1.html#introduction",
    "href": "geocomputation/chapter1.html#introduction",
    "title": "Chapter 2: Geocomputation with R",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter1.html#vector-data",
    "href": "geocomputation/chapter1.html#vector-data",
    "title": "Chapter 2: Geocomputation with R",
    "section": "2.2 Vector Data",
    "text": "2.2 Vector Data\n\nVector Data: Represents geographic features using points, lines, and polygons based on coordinate reference systems (CRS).\n\nExample: London’s coordinates c(-0.1, 51.5) in geographic CRS or c(530000, 180000) in projected CRS (British National Grid).\n\nCRS Overview:\n\nGeographic CRS uses lon/lat (0° longitude and latitude origin).\nProjected CRS, like the British National Grid, is based on Easting/Northing coordinates with positive values.\n\nKey dependencies / libraries used by the sf Package:\n\nGDAL: Handles geographic data formats\nPROJ: For CRS transformations\nGEOS: Supports planar geometry for projected data\nS2: Manages spherical geometry for unprojected data (e.g., lon/lat), toggleable with sf::sf_use_s2(FALSE).\n\nGeometry Engines:\n\nPlanar (GEOS): For 2D projected data.\nSpherical (S2): For 3D unprojected data.\n\n\n\n2.2.1 Introduction to Simple Features\n\nSimple Features (SF): Hierarchical model by OGC; supports multiple geometry types.\nCore Types: sf package in R supports 7 core geometry types (points, lines, polygons, and “multi” versions).\nLibrary Integration: sf replaces sp, rgdal, rgeos; unified interface for GEOS (geometry), GDAL (data I/O), PROJ (CRS).\nNon-Planar Support: Integrates s2 for geographic (lon/lat) operations, used by default for accuracy on spherical geometries.\nData Storage: SF objects are data frames with a spatial column (geom).\nVignettes: Documentation accessible with vignette(package = \"sf\") for practical use and examples.\nPlotting: plot(sf_object) maps all variables, unlike single-map GIS tools.\nSummary: summary() gives spatial and attribute data insights.\nSubset: SF objects subsettable like data frames, retaining spatial metadata.\n\n\n\nCode\n# See which vignettes are available\n# vignette(package = \"sf\")\n\nworld\n## Simple feature collection with 177 features and 10 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\n## # A tibble: 177 × 11\n##    iso_a2 name_long continent region_un subregion type  area_km2     pop lifeExp\n##  * &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n##  1 FJ     Fiji      Oceania   Oceania   Melanesia Sove…   1.93e4  8.86e5    70.0\n##  2 TZ     Tanzania  Africa    Africa    Eastern … Sove…   9.33e5  5.22e7    64.2\n##  3 EH     Western … Africa    Africa    Northern… Inde…   9.63e4 NA         NA  \n##  4 CA     Canada    North Am… Americas  Northern… Sove…   1.00e7  3.55e7    82.0\n##  5 US     United S… North Am… Americas  Northern… Coun…   9.51e6  3.19e8    78.8\n##  6 KZ     Kazakhst… Asia      Asia      Central … Sove…   2.73e6  1.73e7    71.6\n##  7 UZ     Uzbekist… Asia      Asia      Central … Sove…   4.61e5  3.08e7    71.0\n##  8 PG     Papua Ne… Oceania   Oceania   Melanesia Sove…   4.65e5  7.76e6    65.2\n##  9 ID     Indonesia Asia      Asia      South-Ea… Sove…   1.82e6  2.55e8    68.9\n## 10 AR     Argentina South Am… Americas  South Am… Sove…   2.78e6  4.30e7    76.3\n## # ℹ 167 more rows\n## # ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nnames(world)\n##  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n##  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nclass(world)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nCode\nworld |&gt; names()\n\nclass(world)\n\nggplot(world) + geom_sf()\n\nplot(world)\n\nworld[1:2, 1:3]\n\nvignette(\"sf1\")\n\nrbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\n\nlist(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\n\nsf_use_s2()\n\nraster_filepath = system.file(\n  \"raster/srtm.tif\", \n  package = \"spDataLarge\"\n  )\n\nmy_rast = rast(raster_filepath)\n\n?rast\n\nclass(my_rast)\nprint(my_rast)\nmy_rast\nobject.size(my_rast)\n?srtm.tif\nncell(my_rast)\n457*465\nres(my_rast)\ninMemory(my_rast)\nplot(my_rast)\n\n\nnew_raster = rast(nrows = 36, ncols = 36, \n                  xmin = -15, xmax = 15, ymin = -15, ymax = 15,\n                  vals = round(rnorm(n = 36*36) * 100, 1))\n\nplot(new_raster)\n\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\n\nmulti_rast |&gt; \n  plot()\n\nnlyr(multi_rast)"
  },
  {
    "objectID": "geocomputation/chapter2.html",
    "href": "geocomputation/chapter2.html",
    "title": "Geographic data in R (Chapter 2)",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter2.html#introduction",
    "href": "geocomputation/chapter2.html#introduction",
    "title": "Geographic data in R (Chapter 2)",
    "section": "",
    "text": "Geographic Data Models: Vector and raster models are foundational.\n\nVector Model: Represents geographic data as points, lines, and polygons with precise boundaries; commonly used in social sciences for features like human settlements.\nRaster Model: Divides surfaces into cells; useful in environmental sciences, often based on remote sensing and aerial data. Scalable and consistent over large areas.\n\nChoosing a Model:\n\nVector is often used in social sciences.\nRaster is prevalent in environmental studies.\n\nR Implementation:\n\nUse sf for vector data.\nUse terra for raster data.\n\n\n\nlibrary(sf)           # Simple Features in R\nlibrary(terra)        # Raster Data in R\nlibrary(spData)       # Spatial Datasets\nlibrary(spDataLarge)  # Large Spatial Datasets\nlibrary(tidyverse)    # Data Wrangling and Visualization"
  },
  {
    "objectID": "geocomputation/chapter2.html#vector-data",
    "href": "geocomputation/chapter2.html#vector-data",
    "title": "Geographic data in R (Chapter 2)",
    "section": "2.2 Vector Data",
    "text": "2.2 Vector Data\n\nVector Data: Represents geographic features using points, lines, and polygons based on coordinate reference systems (CRS).\n\nExample: London’s coordinates c(-0.1, 51.5) in geographic CRS or c(530000, 180000) in projected CRS (British National Grid).\n\nCRS Overview:\n\nGeographic CRS uses lon/lat (0° longitude and latitude origin).\nProjected CRS, like the British National Grid, is based on Easting/Northing coordinates with positive values.\n\nKey dependencies / libraries used by the sf Package:\n\nGDAL: Handles geographic data formats\nPROJ: For CRS transformations\nGEOS: Supports planar geometry for projected data\nS2: Manages spherical geometry for unprojected data (e.g., lon/lat), toggleable with sf::sf_use_s2(FALSE).\n\nGeometry Engines:\n\nPlanar (GEOS): For 2D projected data.\nSpherical (S2): For 3D unprojected data.\n\n\n\n2.2.1 Introduction to Simple Features\n\nSimple Features (SF): Hierarchical model by OGC (Open Geospatial Consortium); supports multiple geometry types.\nCore Types: sf package in R supports 7 core geometry types (points, lines, polygons, and their “multi” versions).\nLibrary Integration: sf replaces sp, rgdal, rgeos; unified interface for GEOS (geometry), GDAL (data I/O), PROJ (CRS).\nNon-Planar Support: Integrates s2 for geographic (lon/lat) operations, used by default for accuracy on spherical geometries.\nData Storage: SF objects are data frames with a spatial column (geometry or geom).\nVignettes: Documentation accessible with vignette(package = \"sf\") for practical use and examples.\nPlotting: plot(sf_object) maps all variables, unlike single-map GIS tools.\nSummary: summary() gives spatial and attribute data insights.\nSubset: SF objects subsettable like data frames, retaining spatial metadata.\n\n\nworld\n\nSimple feature collection with 177 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n# A tibble: 177 × 11\n   iso_a2 name_long continent region_un subregion type  area_km2     pop lifeExp\n * &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 FJ     Fiji      Oceania   Oceania   Melanesia Sove…   1.93e4  8.86e5    70.0\n 2 TZ     Tanzania  Africa    Africa    Eastern … Sove…   9.33e5  5.22e7    64.2\n 3 EH     Western … Africa    Africa    Northern… Inde…   9.63e4 NA         NA  \n 4 CA     Canada    North Am… Americas  Northern… Sove…   1.00e7  3.55e7    82.0\n 5 US     United S… North Am… Americas  Northern… Coun…   9.51e6  3.19e8    78.8\n 6 KZ     Kazakhst… Asia      Asia      Central … Sove…   2.73e6  1.73e7    71.6\n 7 UZ     Uzbekist… Asia      Asia      Central … Sove…   4.61e5  3.08e7    71.0\n 8 PG     Papua Ne… Oceania   Oceania   Melanesia Sove…   4.65e5  7.76e6    65.2\n 9 ID     Indonesia Asia      Asia      South-Ea… Sove…   1.82e6  2.55e8    68.9\n10 AR     Argentina South Am… Americas  South Am… Sove…   2.78e6  4.30e7    76.3\n# ℹ 167 more rows\n# ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\nnames(world)\n\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n\nclass(world)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n########### THE GEOMETRY COLUMN IS STICKY ################\nsummary(world[\"lifeExp\"])\n\n    lifeExp                 geom    \n Min.   :50.62   MULTIPOLYGON :177  \n 1st Qu.:64.96   epsg:4326    :  0  \n Median :72.87   +proj=long...:  0  \n Mean   :70.85                      \n 3rd Qu.:76.78                      \n Max.   :83.59                      \n NA's   :10                         \n\n\n\n\nCode\nplot(world)\n\n\n\n\n\n\n\n\nFigure 1: The basic plot() function on a sf object produced multiple plots, one for each of the non-geometry variables (columns) in the plotted dataset.\n\n\n\n\n\n\n\n2.2.2 Why Simple Features?\n\nCross-Compatibility: SF model is compatible with many GIS tools (e.g., QGIS, PostGIS), enabling easy data transfer.\nAdvantages of sf in R:\n\nData Handling: Fast reading/writing of spatial data.\nPlotting: Improved plotting speed and performance.\nData Frame-Like: sf objects behave like data frames.\nConsistent Naming: sf functions are intuitive, starting with st_.\nTidyverse-Friendly: Works well with |&gt; and integrates with tidyverse packages.\n\nData Import Options:\n\nread_sf(): Imports data as a tidy tibble (quietly).\nst_read(): Imports data as a base R data frame (verbose).\n\nPopularity: sf is the primary package for spatial vector data in R, preferred over alternatives like spatstat and terra.\n\n\nworld_dfr &lt;- st_read(system.file(\"shapes/world.shp\", package = \"spData\"))\n## Reading layer `world' from data source \n##   `C:\\Users\\dradi\\AppData\\Local\\R\\win-library\\4.3\\spData\\shapes\\world.shp' \n##   using driver `ESRI Shapefile'\n## Simple feature collection with 177 features and 10 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n## Geodetic CRS:  WGS 84\nworld_dfr &lt;- read_sf(system.file(\"shapes/world.shp\", package = \"spData\"))\n\nclass(world_dfr)\n## [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n2.2.3 Basic Maps\n\nPlotting in sf:\n\nplot() creates multi-panel plots for multiple variables or a single-panel plot for one variable.\nSupports fixed color customization using col and border arguments.\n\n\n\n\nCode\nplot(world)\n\n\n\n\n\n\n\n\nFigure 2: The base plot() function creates a faceted output with a map for each variable other than geometry\n\n\n\n\n\n\nLayering Plots: Add layers to existing plots with add = TRUE. Use reset = FALSE for plots with a key.\nOverlaying Data: Circles representing population size can be plotted using cex and st_centroid().\nBounding Box Expansion: expandBB adjusts the plot boundaries (bottom, left, top, right).\nLimitations: Base plot() is simple but limited in functionality; use tmap for advanced maps.\n\n\n\n2.2.4 Geometry Types\n\nGeometry Basics:\n\nCore components of simple features; sf supports 18 types.\nFocus on 7 common types: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.\n\nEncoding Standards:\n\nWKB (Well-known binary): Hexadecimal, computer-friendly format.\nWKT (Well-known text): Human-readable format, often shown for explanation.\n\nCommon Geometries:\n\nPOINT: Single coordinate (e.g., POINT (5 2)).\nLINESTRING: Connected sequence of points (e.g., LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)).\nPOLYGON: Closed ring of points (e.g., POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))).\n\nMulti-Geometries:\n\nMULTIPOINT: Multiple points (e.g., MULTIPOINT (5 2, 1 3, 3 4, 3 2)).\nMULTILINESTRING: Multiple linestrings (e.g., MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))).\nMULTIPOLYGON: Multiple polygons (e.g., MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))).\n\nGeometry Collection:\n\nMix of geometry types (e.g., GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))).\n\n\n\n\n2.2.5 The sf Class\n\nStructure of sf Objects: Composed of geometries (sfc object) and non-geographic attributes (data.frame or tibble).\nCreation of sf Objects: Steps:\n\nCreate geometry (sfg) with functions like st_point()\nConvert to geometry column (sfc) with CRS using function st_sfc(..., crs = \"...\")\nCombine attributes (data.frame) with sfc using function st_sf(..., geometry = ...)\n\n\n\n\nCharacteristics:\n\nsf objects have dual class: sf and data.frame.\nSpatial attributes stored in a geometry column.\nsf behaves like a data.frame but with spatial extension.\n\n\n\n\n2.2.6 Simple Feature Geometries (sfg)\nAn sfg object represents a single simple feature geometry. A simple feature geometry column (sfc) is a collection of sfg objects and can also include information about the coordinate reference system (CRS) being used.\nGeometries can be created using st_ functions or imported from existing spatial files.\n\nsfg Creation Functions:\n\nst_point(): Create a single point.\nst_linestring(): Create a linestring.\nst_polygon(): Create a polygon.\nst_multipoint(): Create a multipoint.\nst_multilinestring(): Create a multilinestring.\nst_multipolygon(): Create a multipolygon.\nst_geometrycollection(): Create a geometry collection.\n\nInput Data Types:\n\nNumeric Vector: Single points.\nMatrix: Sets of points for multipoint or linestring.\nList: Complex structures for multilinestrings, (multi)polygons, or geometry collections.\n\nExamples:\n\n\nCode\n\n# Create a point\npoint &lt;- st_point(c(8, 3))  # POINT (8 3)\nprint(point)\nggplot(point) +\n  geom_sf()\n\n# Create a multipoint\nmultipoint_matrix &lt;- rbind(c(8, 3), c(2, 5), c(5, 7), c(7, 3))\nmultipoint &lt;- st_multipoint(multipoint_matrix)  # MULTIPOINT ((8 3), (2 5), (5 7), (7 3))\nprint(multipoint)\nggplot(multipoint) +\n  geom_sf()\n\n# Create a linestring\nlinestring_matrix &lt;- rbind(c(2, 8), c(6, 6), c(7, 2), c(5, 3), c(8, 4))\nlinestring &lt;- st_linestring(linestring_matrix)  # LINESTRING (2 8, 6 6, 7 2, 5 3, 8 4)\nprint(linestring)\nggplot(linestring) +\n  geom_sf()\n\n# Create a polygon\npolygon_list &lt;- list(rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8)))\npolygon &lt;- st_polygon(polygon_list)  # POLYGON ((2 8, 4 3, 7 2, 6 7, 2 8))\nprint(polygon)\nggplot(polygon) +\n  geom_sf()\n\n# Polygon with a hole\npolygon_border &lt;- rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8))\npolygon_hole &lt;- rbind(c(4, 6), c(5, 6), c(5, 5), c(4, 5), c(4, 6))\npolygon_with_hole_list &lt;- list(polygon_border, polygon_hole)\npolygon_with_hole &lt;- st_polygon(polygon_with_hole_list)  # POLYGON with a hole\nprint(polygon_with_hole)\nggplot(polygon_with_hole) +\n  geom_sf()\n\n# Create a multilinestring\nmultilinestring_list = list(\n  rbind(c(2, 8), c(6, 6), c(7, 2), c(5, 3), c(8, 4)),\n  rbind(c(3, 2), c(5, 8))\n)\nmultilinestring = st_multilinestring(multilinestring_list)  # MULTILINESTRING\nprint(multilinestring)\nggplot(multilinestring) +\n  geom_sf()\n\n# Create a multipolygon\nmultipolygon_list = list(\n  list(rbind(c(2, 8), c(4, 3), c(7, 2), c(6, 7), c(2, 8))),\n  list(rbind(c(0, 3), c(2, 3), c(2, 4), c(0, 4), c(0, 3)))\n)\nmultipolygon = st_multipolygon(multipolygon_list)  # MULTIPOLYGON\nprint(multipolygon)\nggplot(multipolygon) +\n  geom_sf()\n\n# Create a geometry collection\ngeometrycollection_list = list(st_multipoint(multipoint_matrix), st_linestring(linestring_matrix))\ngeometry_collection = st_geometrycollection(geometrycollection_list)  # GEOMETRYCOLLECTION\nprint(geometry_collection)\nggplot(geometry_collection) +\n  geom_sf()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) A point\n\n\n\n\n\n\n\n\n\n\n\n(b) A multipoint\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) A linestring\n\n\n\n\n\n\n\n\n\n\n\n(d) A polygon\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e) Polygon with a hole\n\n\n\n\n\n\n\n\n\n\n\n(f) Multilinestring\n\n\n\n\n\n\n\n\n\n\n\n\n\n(g) Multipolygon\n\n\n\n\n\n\n\n\n\n\n\n(h) Geometry Collection\n\n\n\n\n\n\n\nFigure 3: Creating different sample geometry objects in R with {sf}\n\n\n\n\n\n2.2.8 The sfheaders Package\n\nOverview:\n\nsfheaders (Cooley 2024) is an R package designed to efficiently create and manipulate sf objects from vectors, matrices, and data frames.\nIt does not rely on the sf library and instead uses underlying C++ code, enabling faster operations and the potential for further development with compiled code.\n\nCompatibility:\n\nAlthough separate from sf, it is fully compatible, producing valid sf objects like sfg, sfc, and sf.\n\nKey Functionality:\n\nConverts:\n\nVector → sfg_POINT\nMatrix → sfg_LINESTRING\nData Frame → sfg_POLYGON\n\nCreates sfc and sf objects using similar syntax.\n\nAdvantages:\n\nsfheaders is optimized for high-speed ‘deconstruction’ and ‘reconstruction’ of sf objects and casting between geometry types, offering faster performance than sf in many cases.\n\n\n\n\n2.2.9 Spherical Geometry Operations with S2\n\nConcept:\n\nSpherical geometry operations acknowledge Earth’s roundness, as opposed to planar operations that assume flat surfaces.\nSince sf version 1.0.0, R integrates with Google’s S2 spherical geometry engine, enabling accurate global spatial operations.\nS2 supports operations like distance, buffer, and area calculations, allowing accurate geocomputation on a spherical Earth model.\nKnown as a Discrete Global Grid System (DGGS), S2 is similar to other systems like H3, which is a global hexagonal index.\n\nS2 Mode:\n\nBy default, S2 is enabled in sf. Verify with:\nsf_use_s2()\nTurning Off S2:\nsf_use_s2(FALSE)\n\nS2 Limitations and Edge Cases:\n\nSome operations may fail due to S2’s stricter definitions, potentially affecting legacy code. Error messages such as Error in s2_geography_from_wkb ... might require turning off S2.\n\nRecommendation:\n\nKeep S2 enabled for accurate global calculations unless specific operations necessitate its deactivation."
  },
  {
    "objectID": "geocomputation/chapter2.html#raster-data",
    "href": "geocomputation/chapter2.html#raster-data",
    "title": "Geographic data in R (Chapter 2)",
    "section": "2.3 Raster Data",
    "text": "2.3 Raster Data\n\nThe raster data model represents the world as a continuous grid of cells (pixels). Focuses on regular grids, where each cell is of constant size, though other grid types (e.g., rotated, sheared) exist.\nStructure:\n\nComprises a raster header and a matrix of equally spaced cells.\nThe raster header includes:\n\nCRS (Coordinate Reference System)\nExtent (geographical area covered)\nOrigin (starting point, often the lower left corner; the terra package defaults to the upper left).\n\nExtent is defined by:\n\nNumber of columns (ncol)\nNumber of rows (nrow)\nCell size resolution\n\n\nCell Access and Modification:\n\nCells can be accessed and modified by:\n\nCell ID\nExplicitly specifying row and column indices.\n\nThis matrix representation is efficient as it avoids storing corner coordinates (unlike vector polygons).\n\nData Characteristics:\n\nEach cell can hold a single value, which can be either:\n\nContinuous (e.g., elevation, temperature)\nCategorical (e.g., land cover classes).\n\n\nApplications:\n\nRaster maps are useful for continuous phenomena (e.g., temperature, population density) and can also represent discrete features (e.g., soil classes).\n\n\n\n2.3.1 R Packages for Working with Raster Data\n\nSeveral R packages for reading and processing raster datasets have emerged over the last two decades. The raster package was the first significant advancement in R’s raster capabilities when launched in 2010. It was the premier package until the development of terra and stars, both offering powerful functions for raster data.\nThis book emphasizes terra, which replaces the older, slower raster package.\nComparison of terra and stars:\n\n\n\n\n\n\n\n\n\nFeature\nterra\nstars\n\n\n\n\nPrimary Focus\nRegular grids\nSupports regular, rotated, sheared, rectilinear, and curvilinear grids\n\n\nData Structure\nOne or multi-layered rasters\nRaster data cubes with multiple layers, time steps, and attributes\n\n\nMemory Management\nUses C++ code and pointers for data storage\nUses lists of arrays for smaller rasters; file paths for larger ones\n\n\nVector Data Integration\nUses its own class SpatVector but supports sf objects\nClosely related to vector objects/functions in sf\n\n\nFunctions & Methods\nLarge number of built-in, purpose-specific functions (e.g., re-sampling, cropping)\nMix of built-in functions (st_ prefix), existing dplyr functions, and custom methods for R functions\n\n\nConversion Between Packages\nConversion to stars with st_as_stars()\nConversion to terra with rast()\n\n\nPerformance\nGenerally optimized for speed and memory efficiency\nFlexible, but performance varies based on data type and structure\n\n\nBest Use Cases\nSingle or multi-layer rasters; fast processing\nComplex data cubes with layers over time and multiple attributes\n\n\nProgramming Language Basis\nPrimarily C++\nR with some C++ integration\n\n\n\n\n\n2.3.2 Introduction to terra\n\nThe terra package is designed for handling raster objects in R, supporting a range of functions to create, read, export, manipulate, and process raster datasets.\n\nWhile its functionality is similar to the older raster package, terra offers improved computational efficiency.\nDespite terra’s advantages, the raster class system remains popular due to its widespread use in other R packages.\nterra provides seamless translation between the two object types using functions like raster(), stack(), and brick() for backward compatibility.\n\nKey Features:\n\nLow-Level Functionality: Includes functions that help in building new tools for raster data processing.\nMemory Management: Supports processing of large raster datasets by dividing them into smaller chunks for iterative processing, allowing operations beyond available RAM capacity.\n\n\n\n\nCode\nraster_filepath &lt;- system.file(\"raster/srtm.tif\", \n                              package = \"spDataLarge\")\nmy_rast &lt;- rast(raster_filepath)\n\nclass(my_rast)\n## [1] \"SpatRaster\"\n## attr(,\"package\")\n## [1] \"terra\"\n\next(my_rast)\n## SpatExtent : -113.239583212784, -112.85208321281, 37.1320834298579, 37.5129167631658 (xmin, xmax, ymin, ymax)\n\nprint(my_rast)\n## class       : SpatRaster \n## dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n## resolution  : 0.0008333333, 0.0008333333  (x, y)\n## extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : srtm.tif \n## name        : srtm \n## min value   : 1024 \n## max value   : 2892\n\n\n\nDedicated Reporting Functions:\n\ndim(): Number of rows, columns, and layers.\nncell(): Total number of cells (pixels).\nres(): Spatial resolution.\next(): Spatial extent.\ncrs(): Coordinate reference system (CRS).\ninMemory(): Checks if data is stored in memory or on disk.\nsources: Shows file location.\n\nAccessing Full Function List:\n\nRun help(\"terra-package\") to see all available terra functions.\n\n\n\n\n2.3.3 Basic Map-Making\n\nPlotting with terra:\n\nThe terra package offers a simple way to create basic visualizations using the plot() function, specifically designed for SpatRaster objects.\n\n\n\n\nCode\nplot(my_rast)\n\n\n\n\n\n\n\n\nFigure 4: An example raster data displayed with {terra} using plot()\n\n\n\n\n\n\nAdvanced Plotting Options:\n\nplotRGB(): A specialized function in terra for creating color composite plots using three layers (e.g., red, green, blue bands) from a SpatRaster object.\ntmap Package (Tennekes 2018): Useful for creating both static and interactive maps for raster and vector data.\nrasterVis Package (2023): Includes functions such as levelplot() to create advanced visualizations, including faceted plots for displaying changes over time.\n\n\n\n\n2.3.4 Raster Classes\n\nThe SpatRaster class in terra represents raster objects. Rasters are commonly created by reading a file using rast()\n\nterra supports reading various formats via GDAL, only loading the header and a file pointer into RAM.\n\nCreating Rasters from Scratch: Use rast() to make new raster objects:\n\nFills values row-wise from the top left corner.\nResolution depends on rows, columns, and extent; defaults to degrees (WGS84 CRS).\n\n\n\n\nCode\n# Create a new SpatRaster object: a checkerboard design\nnew_raster = rast(nrows = 50, ncols = 50, \n                  xmin = 0, xmax = 50, \n                  ymin = 0, ymax = 50,\n                  vals = rep(c(1, 0.25, 0.75, 0.5), \n                             times = 12)) \n\n\n# Plot the new raster\nplot(new_raster, \n     col = c(\"darkblue\", \n             \"white\",\n             \"blue\",\n             \"lightblue\"), # Use blue and white for the design\n     axes = TRUE, \n     box = FALSE)\n\n\n\n\n\n\n\n\nFigure 5: Creating a new raster from scratch\n\n\n\n\n\n\nHandling Multi-Layer Rasters:\n\nSpatRaster supports multi-layer rasters, such as satellite or time-series data:\n\nUse nlyr() to get the number of layers:\nAccess layers with [[ or $.\nUse subset() for layer extraction:\n\n\nCombining Raster Layers:\n\nMerge SpatRaster layers using c():\n\nSaving SpatRaster Objects:\n\nSince they often point to files, direct saving to .rds or .rda isn’t feasible.\nSolutions:\n\nwrap(): Creates a temporary object for saving or cluster use.\nwriteRaster(): Saves as a regular raster file."
  },
  {
    "objectID": "geocomputation/chapter2.html#coordinate-reference-systems",
    "href": "geocomputation/chapter2.html#coordinate-reference-systems",
    "title": "Geographic data in R (Chapter 2)",
    "section": "2.4 Coordinate Reference Systems",
    "text": "2.4 Coordinate Reference Systems\n\nCRSs (Coordinate Reference Systems) are essential for spatial data, defining how spatial elements correspond to the Earth’s surface (or other celestial bodies).\nTypes of CRSs:\n\nGeographic CRSs:\n\nRepresent data on a three-dimensional surface (e.g., latitude and longitude).\nCoordinate units are typically degrees.\n\nProjected CRSs:\n\nRepresent data on a two-dimensional, flat plane.\nTransform spherical Earth data into a flat map.\nCoordinate units can be in meters, feet, etc.\n\n\n\n\n2.4.1 Geographic Coordinate Reference Systems\n\nGeographic CRSs use longitude and latitude to identify locations on Earth.\n\nLongitude: Measures East-West position relative to the Prime Meridian.\nLatitude: Measures North-South position relative to the equatorial plane.\nDistances are measured in angular units (degrees), not meters, impacting spatial measurements (explored further in Section 7).\n\nThe Earth can be modeled as spherical or ellipsoidal.\n\nSpherical models: Simplify calculations by assuming Earth is a perfect sphere.\nEllipsoidal models: More accurately represent Earth with distinct equatorial and polar radii. The equatorial radius is about 11.5 km longer than the polar radius due to Earth’s compression.\n\nDatum refers to the model describing the relationship between coordinate values and actual locations on Earth. A datum consists of:\n\nEllipsoid: An idealized mathematical model of the Earth’s shape, which helps to approximate the Earth’s surface.\nOrigin Point: A fixed starting point for the coordinate system, where the ellipsoid is anchored to Earth.\nOffset and Orientation: How the ellipsoid is aligned with respect to the actual shape of the Earth.\n\n\n\n\nThe two types of Datums are: —\n\nGeocentric datum (e.g., WGS84): Centered at Earth’s center of gravity, providing global consistency but less local accuracy.\nLocal datum (e.g., NAD83): Adjusted for specific regions to better align with the Earth’s surface, accounting for local geographic variations (e.g., mountain ranges).\n\n\n\n\n2.4.2 Projected Coordinate Reference Systems\n\nProjected CRSs are based on geographic CRSs and use map projections to represent Earth’s three-dimensional surface in Easting and Northing (x and y) values. These CRSs rely on Cartesian coordinates on a flat surface, with an origin and linear units (e.g., meters).\nDeformations:\n\nThe conversion from 3D to 2D inherently introduces distortions. Projected CRSs can only preserve one or two of the following properties:\n\nArea: Preserved in equal-area projections.\nDirection: Preserved in azimuthal projections.\nDistance: Preserved in equidistant projections.\nShape: Preserved in conformal projections.\n\n\n\n\n\nTypes of Projections and Their Characteristics\n\n\n\n\n\n\n\n\n\nType of Projection\nDescription\nCommon Properties Preserved\nBest Used For\n\n\n\n\nConic\nProjects Earth’s surface onto a cone.\nArea, shape\nMaps of mid-latitude regions\n\n\nCylindrical\nProjects Earth’s surface onto a cylinder.\nDirection, shape\nWorld maps\n\n\nPlanar (Azimuthal)\nProjects onto a flat surface at a point or line.\nDistance, direction\nPolar region maps\n\n\n\n\n\nDeformations by Projection Type\n\n\n\n\n\n\n\n\nProperty\nDefinition\nProjection Type That Preserves It\n\n\n\n\nArea\nThe relative size of regions is maintained.\nEqual-area projections (e.g., Albers)\n\n\nDirection\nBearings from the center are accurate.\nAzimuthal projections (e.g., Lambert)\n\n\nDistance\nCorrect distances are preserved along specific lines or from specific points.\nEquidistant projections (e.g., Equirectangular)\n\n\nShape\nLocal angles and shapes are maintained, though areas are distorted.\nConformal projections (e.g., Mercator)\n\n\n\n\nUse the Map Projection Explorer for details.\nUse st_crs() for querying CRSs in sf objects and crs() for terra objects.\n\n\n\nCode\nsf_proj_info(type = \"proj\") |&gt; \n  as_tibble() |&gt; \n  gt::gt() |&gt; \n  gt::cols_label_with(fn = snakecase::to_title_case) |&gt; \n  gtExtras::gt_theme_espn() |&gt; \n  gt::opt_interactive()\n\n\n\n\nTable 1: A list of the available projections supported by the PROJ library"
  },
  {
    "objectID": "geocomputation/chapter2.html#exercises",
    "href": "geocomputation/chapter2.html#exercises",
    "title": "Geographic data in R (Chapter 2)",
    "section": "2.6 Exercises",
    "text": "2.6 Exercises\n\n\nE1\nUsing summary() on the geometry column of the world data object in the spData package provides valuable information about the spatial characteristics of the dataset:\n\nGeometry Type:\n\nThe output will indicate the type of geometries present in the world data object. Here, it is MULTIPOLYGON suggesting that the dataset represents the outlines of countries or regions in MULTIPLOYGON formats.\n\nNumber of Countries:\n\nThe summary will show the number of geometries or features present, which corresponds to the number of countries or regions represented in the world dataset. Here, it is 177 countries.\n\nCoordinate Reference System (CRS):\n\nThe output will include details about the CRS, and in the present case it is EPSG:4326.\n\n\n\nsummary((spData::world$geom))\n\n MULTIPOLYGON     epsg:4326 +proj=long... \n          177             0             0 \n\n\n\n\n\nE2\nTo generate the world map, you can run the following code (as shown in Section 2.2.3):\n\nCode\nlibrary(spData)\nplot(world[3:6])\nplot(world[\"pop\"])\n\n\n\n\n\n\n\n\n\n\nFigure 6: Reproducing Figure 2.4 of the book\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Reproducing Figure 2.4 of the book\n\n\n\n\n\n\n\nSimilarities:\n\nThe map displays country boundaries and highlights the global population distribution as shown in the book.\nThe color scale representing population data is consistent with that described in the book, with larger populations shown with more intense colors.\n\nDifferences:\n\nThe aspect ratio or positioning of the map might vary depending on your screen resolution and window size.\nThe color theme and legend display may differ if your R setup or graphic device uses default settings different from those in the book.\n\ncex Argument: This parameter controls the size of plotting symbols in R. It is a numeric value that acts as a multiplier for the default size of symbols.\n\nSetting cex to values larger than 1 enlarges symbols, while values less than 1 shrink them.\n\nReason for cex = sqrt(world$pop) / 10000 : The code sets cex to sqrt(world$pop) / 10000 to scale the size of the points on the map in proportion to the population of each country. This square root transformation is used to moderate the variation in symbol sizes because population values can vary significantly between countries. Dividing by 10,000 helps to reduce the symbol size to a reasonable range for plotting.\n\nOther Ideas: —\n\nBubble Plot: Overlay a bubble plot on the map with points sized by population.\n\n\n\nCode\nplot(world[\"pop\"])\npoints(st_coordinates(st_centroid(world$geom)), \n       cex = sqrt(world$pop) / 5000, \n       col = \"red\", pch = 19)\n\n\n\n\n\n\n\n\n\n\nChoropleth Map: Use color gradients to represent population density.\n\n\n\nCode\nlibrary(tmap)\ntm_shape(world) +\n  tm_polygons(\"pop\", style = \"jenks\", \n              palette = \"Blues\", \n              title = \"Population\")\n\n\n\n\n\n\n\n\n\n\nLog Transformation: Visualize population using a log scale for better differentiation.\n\n\n\nCode\nworld$log_pop = log10(world$pop + 1)\nplot(world[\"log_pop\"])\n\n\n\n\n\n\n\n\n\n\n\n\nE3\nTo create a map of Nigeria in context and customize it using the plot() function, you can follow these steps:\nStep 1: Load Necessary Libraries and Data: Make sure you have the spData package loaded and access to the world spatial data.\nStep 2: Plotting Nigeria in Context: You can plot Nigeria by subsetting the world data and adjusting parameters such as lwd (line width), col (color), and expandBB (expanding the bounding box). Here’s an example code snippet:\nStep 3: Annotating the Map: To annotate the map with text labels, you can use the text() function. Here’s an example where we add the name of Nigeria and its capital, Abuja:\nStep 4: Exploring the text() Documentation\n\nlwd: This argument controls the line width for the borders of the countries.\ncol: This argument sets the fill color for the countries. You can customize it based on your preference.\nexpandBB: This argument expands the bounding box of the plot, which can help visualize nearby areas more clearly.\n\n\n\n\nE4\nTo create an empty SpatRaster object with 10 columns and 10 rows, assign random values between 0 and 10, and then plot it, you can use the terra package in R. Here’s how you can do it:\n\n\nCode\nlibrary(terra)\n\n# Create an empty SpatRaster object with 10 columns and 10 rows\nmy_raster &lt;- rast(nrows = 10, ncols = 10)\n\n# Assign random values between 0 and 10\nvalues(my_raster) &lt;- runif(ncell(my_raster), min = 0, max = 10)\n\n# Plot the raster\nplot(my_raster, main = \"Random Values Raster\")\n\n\n\n\n\n\n\n\n\n\n\n\nE5\nTo read in the raster/nlcd.tif file from the spDataLarge package and examine its properties, you can follow these steps in R:\n\nlibrary(spDataLarge)\nlibrary(terra)\n\n# Read the raster file\nnlcd_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\nInformation You Can Obtain: —\n\nBasic Properties: The print(nlcd_raster) command will provide you with information about the raster, including its dimensions, number of layers, and type of data.\n\n# Check the basic properties of the raster\nprint(nlcd_raster)\n\nclass       : SpatRaster \ndimensions  : 1359, 1073, 1  (nrow, ncol, nlyr)\nresolution  : 31.5303, 31.52466  (x, y)\nextent      : 301903.3, 335735.4, 4111244, 4154086  (xmin, xmax, ymin, ymax)\ncoord. ref. : NAD83 / UTM zone 12N (EPSG:26912) \nsource      : nlcd.tif \ncolor table : 1 \ncategories  : levels \nname        :   levels \nmin value   :    Water \nmax value   : Wetlands \n\n\nSummary Statistics: The summary(nlcd_raster) function will give you basic statistics about the raster values, such as minimum, maximum, and mean values. In this case, it tells the number of cells with Forest, Shrubland, Barren, Developed, Cultivated, Wetlands and Other land-use types.\n\n# Get summary statistics\nsummary(nlcd_raster)\n\n        levels     \n Forest    :52620  \n Shrubland :37463  \n Barren    : 7290  \n Developed : 1203  \n Cultivated:  596  \n Wetlands  :  443  \n (Other)   :  421  \n\n\nExtent: The ext(nlcd_raster) command will provide the geographical extent of the raster, showing the minimum and maximum x and y coordinates.\n\n# Check the extent of the raster\next(nlcd_raster)\n\nSpatExtent : 301903.344386758, 335735.354381954, 4111244.46098842, 4154086.47216415 (xmin, xmax, ymin, ymax)\n\n\nRows and Columns: You can find the number of rows and columns in the raster using nrow(nlcd_raster) and ncol(nlcd_raster).\n\n# Get the number of rows and columns\nnrow(nlcd_raster)\n\n[1] 1359\n\nncol(nlcd_raster)\n\n[1] 1073\n\n\nCoordinate Reference System (CRS): The crs(nlcd_raster) command will return the CRS of the raster, which is essential for spatial analyses.\n\n# Get the coordinate reference system (CRS)\nstr_view(crs(nlcd_raster))\n\n[1] │ PROJCRS[\"NAD83 / UTM zone 12N\",\n    │     BASEGEOGCRS[\"NAD83\",\n    │         DATUM[\"North American Datum 1983\",\n    │             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n    │                 LENGTHUNIT[\"metre\",1]]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433]],\n    │         ID[\"EPSG\",4269]],\n    │     CONVERSION[\"UTM zone 12N\",\n    │         METHOD[\"Transverse Mercator\",\n    │             ID[\"EPSG\",9807]],\n    │         PARAMETER[\"Latitude of natural origin\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8801]],\n    │         PARAMETER[\"Longitude of natural origin\",-111,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8802]],\n    │         PARAMETER[\"Scale factor at natural origin\",0.9996,\n    │             SCALEUNIT[\"unity\",1],\n    │             ID[\"EPSG\",8805]],\n    │         PARAMETER[\"False easting\",500000,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8806]],\n    │         PARAMETER[\"False northing\",0,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8807]]],\n    │     CS[Cartesian,2],\n    │         AXIS[\"(E)\",east,\n    │             ORDER[1],\n    │             LENGTHUNIT[\"metre\",1]],\n    │         AXIS[\"(N)\",north,\n    │             ORDER[2],\n    │             LENGTHUNIT[\"metre\",1]],\n    │     USAGE[\n    │         SCOPE[\"Engineering survey, topographic mapping.\"],\n    │         AREA[\"North America - between 114°W and 108°W - onshore and offshore. Canada - Alberta; Northwest Territories; Nunavut; Saskatchewan. United States (USA) - Arizona; Colorado; Idaho; Montana; New Mexico; Utah; Wyoming.\"],\n    │         BBOX[31.33,-114,84,-108]],\n    │     ID[\"EPSG\",26912]]\n\n\nResolution: You can check the resolution of the raster with the res(nlcd_raster) function, which will indicate the size of each pixel.\n\n# Check the resolution of the raster\nres(nlcd_raster)\n\n[1] 31.53030 31.52466\n\n\nValues: The values(nlcd_raster) command allows you to access the actual values contained in the raster. Here, I am printing only the first few values.\n\n# Get the values of the raster\nvalues(nlcd_raster) |&gt; head()\n\n     levels\n[1,]      4\n[2,]      4\n[3,]      5\n[4,]      4\n[5,]      4\n[6,]      4\n\n\n\n\n\n\nE6\nTo check the Coordinate Reference System (CRS) of the raster/nlcd.tif file from the spDataLarge package, you can use the following steps in R. The CRS provides essential information about how the spatial data is projected on the Earth’s surface.\n\nlibrary(spDataLarge)\nlibrary(terra)\n\n# Read the raster file\nnlcd_raster &lt;- rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\n\n# Check the coordinate reference system (CRS)\nnlcd_crs &lt;- crs(nlcd_raster)\nnlcd_crs |&gt; str_view()\n\n[1] │ PROJCRS[\"NAD83 / UTM zone 12N\",\n    │     BASEGEOGCRS[\"NAD83\",\n    │         DATUM[\"North American Datum 1983\",\n    │             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n    │                 LENGTHUNIT[\"metre\",1]]],\n    │         PRIMEM[\"Greenwich\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433]],\n    │         ID[\"EPSG\",4269]],\n    │     CONVERSION[\"UTM zone 12N\",\n    │         METHOD[\"Transverse Mercator\",\n    │             ID[\"EPSG\",9807]],\n    │         PARAMETER[\"Latitude of natural origin\",0,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8801]],\n    │         PARAMETER[\"Longitude of natural origin\",-111,\n    │             ANGLEUNIT[\"degree\",0.0174532925199433],\n    │             ID[\"EPSG\",8802]],\n    │         PARAMETER[\"Scale factor at natural origin\",0.9996,\n    │             SCALEUNIT[\"unity\",1],\n    │             ID[\"EPSG\",8805]],\n    │         PARAMETER[\"False easting\",500000,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8806]],\n    │         PARAMETER[\"False northing\",0,\n    │             LENGTHUNIT[\"metre\",1],\n    │             ID[\"EPSG\",8807]]],\n    │     CS[Cartesian,2],\n    │         AXIS[\"(E)\",east,\n    │             ORDER[1],\n    │             LENGTHUNIT[\"metre\",1]],\n    │         AXIS[\"(N)\",north,\n    │             ORDER[2],\n    │             LENGTHUNIT[\"metre\",1]],\n    │     USAGE[\n    │         SCOPE[\"Engineering survey, topographic mapping.\"],\n    │         AREA[\"North America - between 114°W and 108°W - onshore and offshore. Canada - Alberta; Northwest Territories; Nunavut; Saskatchewan. United States (USA) - Arizona; Colorado; Idaho; Montana; New Mexico; Utah; Wyoming.\"],\n    │         BBOX[31.33,-114,84,-108]],\n    │     ID[\"EPSG\",26912]]\n\n\nUnderstanding the CRS Information: —\nThe output from the crs(nlcd_raster) command will typically include details such as:\n\nProjection Type: Indicates whether the CRS is geographic (latitude and longitude) or projected (a flat representation). Here, it is North American NAD83 / UTM Zone 12 N\nDatum: Information about the geodetic datum used, which is crucial for accurately locating points on the Earth’s surface. Here, it is North American Datum 1983.\nCoordinate Units: Specifies the units of measurement used for the coordinates, such as degrees (for geographic CRSs) or meters (for projected CRSs). Here, it is in metres, as shown in:\nLENGTHUNIT[\"metre\",1]\nEPSG Code: If applicable, the output might include an EPSG code, which is a standardized reference number for a specific CRS. This code can be used to look up more detailed information about the CRS. Here, it is: —\nID[\"EPSG\",26912]\nTransformation Parameters: If it’s a projected CRS, the output may include parameters related to the projection method, such as central meridian, standard parallels, and false easting/northing. Here, they are: —\n|         PRIMEM[\"Greenwich\",0,     \n│             ANGLEUNIT[\"degree\",0.0174532925199433]],     \n│         ID[\"EPSG\",4269]], \n|\n|\n│     CONVERSION[\"UTM zone 12N\",     \n│         METHOD[\"Transverse Mercator\",     \n│             ID[\"EPSG\",9807]],     \n│         PARAMETER[\"Latitude of natural origin\",0,     \n│             ANGLEUNIT[\"degree\",0.0174532925199433],     \n│             ID[\"EPSG\",8801]],     \n│         PARAMETER[\"Longitude of natural origin\",-111,     \n|             ANGLEUNIT[\"degree\",0.0174532925199433],     \n│             ID[\"EPSG\",8802]],     \n│         PARAMETER[\"Scale factor at natural origin\",0.9996,\n│             SCALEUNIT[\"unity\",1],     \n│             ID[\"EPSG\",8805]],     \n│         PARAMETER[\"False easting\",500000,     \n│             LENGTHUNIT[\"metre\",1],     \n│             ID[\"EPSG\",8806]],     \n│         PARAMETER[\"False northing\",0,     \n│             LENGTHUNIT[\"metre\",1],     \n│             ID[\"EPSG\",8807]]],"
  },
  {
    "objectID": "geocomputation/chapter2.html#units",
    "href": "geocomputation/chapter2.html#units",
    "title": "Geographic data in R (Chapter 2)",
    "section": "2.5 Units",
    "text": "2.5 Units\n\nCRSs include spatial units information, which is crucial for accurately interpreting distance and area.\nCartographic best practices suggest adding scale indicators on maps to show the relationship between map and ground distances.\nUnits in sf Objects:\n\nsf objects natively support units for geometric data, ensuring outputs from functions like st_area() come with a units attribute.\nThis feature, supported by the units package, avoids confusion across different CRSs, which may use meters, feet, etc.\nTo convert units, use units::set_units()\n\nUnits in Raster Data:\n\nUnlike sf, raster packages do not natively support units.\nUsers should be cautious when working with raster data to convert units properly.\nAn example to calculate the area of India in square meters and then, square kilometres\n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(units)\n\n# Calculate the area of India in square meters\nindia_area &lt;- rnaturalearth::ne_countries() |&gt; \n  filter(admin == \"India\") |&gt; \n  st_area()\nindia_area\n\n3.150428e+12 [m^2]\n\n# Convert area to square kilometers\nprint(paste(\"Area of India in square kilometers:\", format(set_units(india_area, km^2))))\n\n[1] \"Area of India in square kilometers: 3150428 [km^2]\"\n\n# Convert area to hectares\nprint(paste(\"Area of India in hectares:\", format(set_units(india_area, ha))))\n\n[1] \"Area of India in hectares: 315042827 [ha]\"\n\n# Convert area to acres\nprint(paste(\"Area of India in acres:\", format(set_units(india_area, acre))))\n\n[1] \"Area of India in acres: 778484666 [acre]\""
  }
]