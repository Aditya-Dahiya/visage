---
title: "Chapter 4: Spatial data operations"
subtitle: "Key Learnings from, and Solutions to the exercises in Chapter 4 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow."
date: "2024-11-16"
author: "Aditya Dahiya"
bibliography: references.bib
format:
  html:
    code-fold: false
editor_options: 
  chunk_output_type: console
execute: 
  error: false
  message: false
  warning: false
  eval: true
  cache: true
  collapse: true
categories:
  - "Geocomputation with R"
  - "Textbook Solutions"
comments:
  giscus: 
    repo: Aditya-Dahiya/visage
filters:
  - social-share
share:
  permalink: "https://aditya-dahiya.github.io/visage/geocomputation/chapter4.html"
  description: "Visualizing Information and Spatial Analysis with ggplot2 Extensions"
  twitter: true
  linkedin: true
  email: true
  mastodon: true
  facebook: true
---

```{r}
#| label: setup

library(sf)        # Simple Features in R
library(terra)     # Handling rasters in R
library(tidyverse) # All things tidy; Data Wrangling
library(spData)    # Spatial Datasets

sysfonts::font_add_google("Saira Extra Condensed", "caption_font")
showtext::showtext_auto()
```

## 4.1 Introduction to Spatial Operations

-   **Spatial Operations**: Include spatial joins for vectors and local/focal operations for rasters, allowing modification based on location and shape.
    -   Relation to Non-Spatial Operations: Many spatial operations (e.g., subsetting, joining) have non-spatial counterparts.
-   **Spatial Joins**: Can be done in multiple ways (e.g., **intersect**, **within distance**), unlike non-spatial joins *(refer to [fuzzyjoin](https://cran.r-project.org/web/packages/fuzzyjoin/index.html) package [@fuzzyjoin] for alternatives).*
    -   Types of Spatial Relationships: Includes operations like intersects and disjoint. Distance calculations explore spatial relationships.
-   **Raster Operations**:
    1.  Subsetting (Section 4.3.1)
    2.  Map Algebra: Modifies raster cell values through local, focal, zonal, and global operations (Sections 4.3.3 to 4.3.6).
    3.  Merging Rasters: Demonstrated with reproducible examples (Section 4.3.8).
-   **Coordinate Reference System (CRS)**: Consistency in CRS is essential for spatial operations..

## 4.2 Spatial operations on vector data

### 4.2.1 Spatial Subsetting: use `st_filter()`

-   Spatial subsetting extracts features from a spatial object (`x`) that relate spatially to another object (`y`).
-   Syntax: Use the `[ ]` operator: `x[y, , op = st_intersects]`.
    -   `x`: Target `sf` object.

    -   `y`: Subsetting `sf` object.

    -   `op`: Topological relation (default is `st_intersects`).

        [sf package documentation](https://r-spatial.github.io/sf/)
-   Default Operator: `st_intersects()` selects features intersecting with the subsetting object. Alternative operators like `st_disjoint()` can be used for different relations.
    -   Example: `nz_height[canterbury, ]` returns high points within Canterbury from the `nz_height` dataset in the spData package ([spData documentation](https://nowosad.github.io/spData/)).
-   Topological Relations: Include `touches`, `crosses`, and `within`. These determine spatial relationships between features in `x` and `y`.
-   Sparse Geometry Binary Predicate (sgbp):
    -   Using `st_intersects()`, an `sgbp` list object is created.
    -   Convert `sgbp` to logical vector for subsetting using `lengths({sgbp_object_name} > 0)`
    -   Using `sparse = FALSE` argument in `st_intersects()` returns a dense matrix.
-   Tidyverse Alternative: [`st_filter()`](https://r-spatial.github.io/sf/reference/st_filter.html) from the sf package simplifies spatial subsetting, increasing compatibility with `dplyr`.
-   Output Consistency: Subsets created using `[ ]`, logical vectors, or `st_filter()` are equivalent in spatial operations.

```{r}
#| label: fig-4-2-1
#| fig-cap: "Spatial Subsetting and plotting with tidyverse and ggplot2 methods"
#| fig-subcap: 
#|   - "New Zealand Map with all the peaks"
#|   - "New Zealand Map focussing on peaks that intersect with Canterbury"
#| collapse: true
#| code-fold: true

data("nz")
data("nz_height")

class(nz)

# A plot for all regions and all peaks
nz |> 
  ggplot() +
  geom_sf(fill = "white") +
  ggrepel::geom_text_repel(
    mapping = aes(
      label = Name,
      geometry = geom
    ),
    size = 4,
    family = "caption_font",
    stat = "sf_coordinates"
  ) +
  geom_sf(
    data = nz_height,
    pch = 2,
    colour = "red",
    size = 3
  ) +
  scale_fill_manual(
    values = c("white", "pink")
  ) +
  labs(
    title = "All peaks in New Zealand, and all regions."
  ) +
  theme_void() +
  theme(
    plot.background = element_rect(
      fill = "lightblue",
      colour = NA
    ),
    legend.position = "none"
  )

# Total peaks in New Zealand
nz_height |> dim()

# Peaks within Canterbury in New Zealand

# Base R Version
canterbury <- nz |> filter(Name == "Canterbury")
nz_height[canterbury,] |> dim()

# Tidyverse Version
nz_height |>
  st_filter(
    nz |> filter(Name == "Canterbury"),
    .predicate = st_intersects
  ) |> 
  dim()

# Getting the peaks which are inside Canterbury
canterbury_ids <- nz_height |>
  st_filter(
    nz |> filter(Name == "Canterbury"),
    .predicate = st_intersects
  ) |> 
  pull(t50_fid)

nz_height |> 
  mutate(in_canterbury = t50_fid %in% canterbury_ids) |> 
  ggplot() +
  
  # Base NZ Map and Label for Canterbury
  geom_sf(
    data = nz,
    mapping = aes(
      fill = Name == "Canterbury"
    )
  ) +
  geom_sf_text(
    data = filter(nz, Name == "Canterbury"),
    mapping = aes(
      label = Name,
      geometry = geom
    ),
    size = 4,
    family = "caption_font"
  ) +
  
  # Plotting the peaks, and colouring by presence in Canterbury
  geom_sf(
    mapping = aes(
      colour = in_canterbury,
      size = in_canterbury
    ),
    pch = 2
  ) +
  
  scale_fill_manual(
    values = c("white", "lightpink")
  ) +
  scale_colour_manual(
    values = c("black", "red")
  ) +
  guides(
    fill = "none"
  ) +
  labs(
    colour = "Peaks within Canterbury Region?",
    size = "Peaks within Canterbury Region?",
    title = "Highlighting Peaks within Canterbury region"
  ) +
  theme_void() +
  theme(
    plot.background = element_rect(
      fill = "lightblue"
    ),
    legend.position = "bottom"
  )
```

Example code for `st_intersects()` and `st_disjoint()` : these functions produce a sparse predicate list only. Hence, correct way to use them would be `st_filter()` with `.predicate = <function>` argument.

```{r}
nz_height |> 
  st_intersects(
    filter(nz, Name == "Canterbury")
  )

# The 70 peaks within Canterbury region
nz_height |> 
  st_filter(
    filter(nz, Name == "Canterbury"),
    .predicate = st_intersects
  )


# The 31 peaks outside Canterbury Region
nz_height |> 
  st_filter(
    filter(nz, Name == "Canterbury"),
    .predicate = st_disjoint
  )
```

### 4.2.2 Topological Relations

-   **Topological relations** describe spatial relationships between objects using logical TRUE or FALSE statements *(Egenhofer and Herring, 1990)*.
-   **Symmetrical vs. non-symmetrical relations**:
    -   Symmetrical relations (e.g., `equals`, `intersects`, `crosses`) yield the same result when order of input is swapped.
    -   Non-symmetrical relations (e.g., `contains`, `within`) depend on the order of input geometries.
-   **Binary predicates** in **`sf`** package test spatial relationships between vector geometries. See [vignette("sf3")](https://r-spatial.github.io/sf/articles/sf3.html). The following binary predicates exist in `sf` : —

| Function | Description | Symmetrical? |
|------------------------|------------------------|------------------------|
| `st_intersects` | Checks if geometries intersect. | Yes |
| `st_disjoint` | Checks if geometries do not intersect (are disjoint). | Yes |
| `st_touches` | Checks if geometries have at least one boundary point in common. | Yes |
| `st_crosses` | Checks if a geometry crosses another (e.g., a line crosses a polygon). | Yes |
| `st_overlaps` | Checks if geometries have some but not all interior points in common. | Yes |
| `st_equals` | Checks if geometries are topologically equal. | Yes |
| `st_within` | Checks if a geometry is completely contained within another. | **No** |
| `st_contains` | Checks if a geometry contains another completely. | **No** |
| `st_contains_properly` | Checks if a geometry contains another but not vice versa. | **No** |
| `st_covers` | Checks if a geometry covers another (includes boundary). | **No** |
| `st_covered_by` | Checks if a geometry is covered by another (includes boundary). | **No** |
| `st_equals_exact` | Checks if geometries are exactly equal within a given tolerance. | Yes |
| `st_is_within_distance` | Checks if geometries are within a specified distance from each other. | Yes |

-   **Sparse matrix output**: Functions like `st_intersects()` use sparse matrices to save memory by only registering positive results; setting `sparse = FALSE` returns a dense matrix.

```{r}
#| label: fig-create-objects
#| code-fold: true
#| fig-cap: "Some example objects to demonstrate the topological relations"

# Create two polygons
 polygon1 <- st_polygon(
   list(matrix(c(0, 0, 1, 0, 1, 1, 0, 1, 0, 0),
     ncol = 2,
     byrow = TRUE
   ))
 )

 polygon2 <- st_polygon(
   list(matrix(c(0.5, 0.5, 1.5, 0.5, 1.5, 1.5, 0.5, 1.5, 0.5, 0.5),
     ncol = 2,
     byrow = TRUE
   ))
 )

 polygon3 <- st_polygon(
   list(matrix(c(0.2, 1.2,
                 0.5, 1.2, 
                 0.5, 1.5, 
                 0.2, 1.5, 
                 0.2, 1.2),
     ncol = 2,
     byrow = TRUE
   ))
 )

 polygon4 <- st_polygon(
   list(matrix(c(1.2, 0.2, 
                 1.5, 0.2, 
                 1.5, 0.4, 
                 1.2, 0.4, 
                 1.2, 0.2),
     ncol = 2,
     byrow = TRUE
   ))
 )
 
 # Convert to sf objects
 sf_poly1 <- st_sfc(polygon1, crs = 4326)
 sf_poly2 <- st_sfc(polygon2, crs = 4326)
 sf_poly3 <- st_sfc(polygon3, crs = 4326)
 sf_poly4 <- st_sfc(polygon4, crs = 4326)
 
 # Create a collection of points
 points <- st_sfc(
   st_point(c(0.25, 0.25)),
   st_point(c(0.75, 0.75)),
   st_point(c(1.25, 1.25)),
   crs = 4326
 )

 sf_points <- tibble(
   point = c("p1", "p2", "p3"),
   geometry = points
 ) |>
   st_as_sf() |>
   st_set_crs(4326)

# Keeping environment clean
rm(polygon1, polygon2, 
   polygon3, polygon4,
   points)

# Visualize the objects
ggplot() +
  geom_sf(data = sf_poly1, 
          aes(fill = "sf_poly1"),
          alpha = 0.5) +
  geom_sf(data = sf_poly2, 
          aes(fill = "sf_poly2"),
          alpha = 0.5) +
  geom_sf(data = sf_poly3, 
          aes(fill = "sf_poly3"),
          alpha = 0.5) +
  geom_sf(data = sf_poly4, 
          aes(fill = "sf_poly4"),
          alpha = 0.5) +
  geom_sf(data = sf_points,
          aes(fill = point),
          pch = 21,
          size = 4) +
  labs(fill = NULL) +
  theme_minimal()
```

```{r}
#| label: display-relations
#| collapse: true
#| code-fold: false
#| echo: true

#################### Symmetrical Relations ######################
# The order in which sf objects are placed does not matter

## st_intersects()----------------------------------------
st_intersects(sf_poly1, sf_poly2, sparse = F) 

st_intersects(sf_poly1, sf_points, sparse = F) 

st_intersects(sf_poly1, sf_poly3, sparse = F)

st_intersects(sf_poly2 ,sf_poly3, sparse = F) 


# st_disjoint()------------------------------------------
st_disjoint(sf_poly1, sf_poly4, sparse = F)

st_disjoint(sf_poly2, sf_poly3, sparse = F) 


# st_touches()-------------------------------------------
st_touches(sf_poly1, sf_poly2, sparse = F) 

st_touches(sf_poly2, sf_poly3, sparse = F)

st_touches(sf_poly1, sf_points, sparse = F)


# st_crosses()-------------------------------------------
st_crosses(sf_poly1, sf_poly2, sparse = F)

st_crosses(sf_poly1, sf_points, sparse = F)

# st_overlaps()
st_overlaps(sf_poly1, sf_poly2, sparse = F)
st_overlaps(sf_poly1, sf_points, sparse = F)
st_overlaps(sf_poly3, sf_poly3, sparse = F)


# st_equals()-------------------------------------------
st_equals(sf_poly1, sf_poly1, sparse = F)



# st_equals_exact()-------------------------------------
st_equals_exact(sf_poly1, sf_poly2, par = 0.1, sparse = F)
st_equals_exact(sf_poly1, sf_poly2, par = 1, sparse = F)


# st_is_within_distance()-------------------------------
st_is_within_distance(sf_poly1, sf_poly2, dist = 0.1, sparse = F)
st_is_within_distance(sf_poly2, sf_poly3, dist = 0.1, sparse = F)
st_is_within_distance(sf_poly3, sf_poly4, dist = 0.1, sparse = F)
st_is_within_distance(sf_poly3, sf_poly4, dist = 13, sparse = F)


#################### Non-Symmetrical Relations ####################
# The order in which sf objects are placed changes the outcome

# st_within()-------------------------------------------
sf_points |> 
  st_within(sf_poly1, sparse = F)

sf_poly1 |> 
  st_within(sf_points, sparse = F)

sf_poly1 |> 
  st_within(sf_poly2, sparse = F)


# st_contains()-----------------------------------------
sf_poly1 |> 
  st_contains(sf_points, sparse = F)

sf_points |> 
  st_contains(sf_poly1, sparse = F)


# st_covers()-------------------------------------------
sf_poly1 |> 
  st_covers(sf_points, sparse = F)

sf_poly2 |> 
  st_covers(sf_poly1, sparse = F)


# st_covered_by()---------------------------------------
sf_points |> 
  st_covered_by(sf_poly1, sparse = F)

```

### 4.2.3 Distance Relations

-   **Distance relations** are continuous, unlike binary topological relations which return TRUE/FALSE values.
-   The [**`st_distance()`**](https://r-spatial.github.io/sf/reference/st_distance.html) function calculates distances between two **sf** objects, returning a matrix with units of measurement (e.g., meters).
-   [**`st_centroid()`**](https://r-spatial.github.io/sf/reference/st_centroid.html): Computes the geometric centroid of a spatial feature, useful for representing a region's central point in distance calculations.
-   **Matrix output**:
    -   Results are returned as a matrix, even for single value calculations.
    -   Computes a distance matrix between all combinations of features in objects (e.g., distances between multiple points and polygons).
-   **Point-to-polygon distance**: Represents the shortest distance from a point to any part of the polygon.
-   **Usage in distance-based joins**: [`st_distance()`](https://r-spatial.github.io/sf/reference/st_distance.html) is also used for performing joins based on distance criteria.
-   An example code to find distance between central points of Auckland and Canterbury Regions, vs. Top three peaks in New Zealand, returned as a matrix,a nd shown below as a beautiful table using {gt}.

```{r}
#| label: tbl-distance
#| tbl-cap: "Code output for use of st_centroid() and st_distance()"

# Central points of Auckland and Canterbury Regions
df1 <- nz |> 
  filter(str_detect(Name, "Auck|Canter")) |> 
  st_centroid() |> 
  select(Name, geom)

# Top 3 highest peaks in New Zealand
df2 <- nz_height |> 
  slice_max(order_by = elevation, n = 3)

# Finding the distance matrix
st_distance(df1, df2) |> 
  as_tibble() |> 
  mutate(state = c("Auckland", "Canterbury")) |> 
  relocate(state) |> 
  mutate(
    across(
      .cols = -state,
      .fns = as.numeric
    )
  ) |> 
  gt::gt() |> 
  gt::fmt_number(
    decimals = 1,
    scale_by = 1e-3
  ) |> 
  gt::cols_label(V1 = "Highest Peak", 
                 V2 = "Second",
                 V3 = "Third",
                 state = "Centroid of the State") |> 
  gt::tab_header(
    title = "Distance in kilometers"
  ) |> 
  gtExtras::gt_theme_538()
```

### 4.2.4 DE-9IM Strings

-   The **Dimensionally Extended 9-Intersection Model (DE-9IM)** underlies binary spatial predicates. This model forms the basis for many spatial operations and helps create custom spatial predicates.
-   **Origins**:
    -   Initially named “DE + 9IM,” it refers to the **dimensions of intersections** between the boundaries, interiors, and exteriors of two geometries (Clementini and Di Felice 1995).
    -   It applies to two-dimensional geometries (points, lines, polygons) in Euclidean space, requiring data in a projected coordinate reference system (CRS).
-   **How DE-9IM Works**:
    -   The model visualizes intersections between components of two geometries (interior, boundary, exterior) in a 3x3 matrix form, indicating the dimension of the intersection (0 for points, 1 for lines, 2 for polygons, and F for false).
    -   Flattening this matrix row-wise results in the DE-9IM string: **"212111212"**.
-   **Using `st_relate()`**: The [`st_relate()`](https://r-spatial.github.io/sf/reference/st_relate.html) function returns DE-9IM strings to describe spatial relations.
-   **Developing Custom Predicates**:
    -   By interpreting DE-9IM strings, custom binary spatial predicates like **queen** and **rook** relations can be created:
        -   **Queen relations** (shared border or point): Pattern `F***T****`.

        -   **Rook relations** (shared linear intersection): Pattern `F***1****`.
    -   Custom functions using [`st_relate()`](https://r-spatial.github.io/sf/reference/st_relate.html):

``` r
st_queen = function(x, y) 
  st_relate(x, y, pattern = "F***T****")

st_rook = function(x, y) 
  st_relate(x, y, pattern = "F***1****")
```

-   This identifies which geometries in a grid have queen or rook relations to the central geometry.

### 4.2.5 Spatial Joining with `st_join()`

-   Spatial joins combine datasets based on spatial relationships instead of shared key variables (as in non-spatial joins). It adds columns from a source object (`y`) to a target object (`x`).

-   **Join Details**:

    -   Default behavior: A left join, which retains all rows from `x` and includes rows with no match from `y`.

    -   Operators: Uses `st_intersects()` by default but can be modified via the `join` argument.

    -   Handles all geometry types: Works for points, lines, and polygons, though joins involving polygons may create duplicate rows for multiple matches in `y`.

-   **Flexibility**:

    -   **Inner joins**: Set `left = FALSE` to include only matched rows.

-   The `st_join()` function: The `join` argument defines the topological operator to determine these relationships, with the default being `st_intersects()`.

    -   We can customize this behavior by choosing alternative functions such as `st_contains`, `st_within`, `st_overlaps`, `st_touches`, or `st_disjoint`, among others, each defining a different geometric predicate.

    -   For example, `st_contains` selects features where geometries of `x` fully encompass those of `y`, while `st_within` does the reverse.

    -   Additionally, advanced options like `st_is_within_distance` allow proximity-based joins, and `st_relate` supports customized spatial relationships using a pattern.

-   Example: Getting 25 random points in the world, and seeing in which countries they fall in @fig-st-join.

```{r}
#| code-fold: true

# Getting 25 random points on the world,a dn then seeing in which countries they fall
random_points <- tibble(
  x = round(
    runif(
    25, 
    min = st_bbox(world)$xmin, 
    max = st_bbox(world)$xmax
    ),
    2
  ),
  y = round(
    runif(
    25, 
    min = st_bbox(world)$ymin, 
    max = st_bbox(world)$ymax
    ),
    2
  ),
  id = LETTERS[1:25]
) |> 
  st_as_sf(coords = c("x", "y")) |> 
  st_set_crs(value = crs(world))


# Easiest (but not tidyverse) way to subset
# world[random_points, ]

# Tidyverse way to filter: Names of Countries in which they fall
intersecting_countries <- world |> 
  st_filter(random_points) |> 
  pull(name_long)

# The power of spatial joins: A tibble of countries where each random
# point falls. st_join() by default performs a left_join()
st_join(
  random_points, 
  world |> select(name_long)
) |> 
  drop_na() |> 
  gt::gt() |> 
  gtExtras::gt_theme_nytimes()
```

```{r}
#| label: fig-st-join
#| fig-cap: "Using st_join() to spatially join two data sets, based on the st_intersect() relation"
#| code-fold: true


set.seed(42)

world |> 
  mutate(highlight = name_long %in% intersecting_countries) |> 
  ggplot() +
  geom_sf(
    mapping = aes(
      fill = highlight
    ),
    alpha = 0.5
  ) +
  scale_fill_manual(
    values = c("transparent", "red")
  ) +
  geom_sf(
    data = random_points,
    pch = 20,
    size = 4,
    colour = "black",
    alpha = 0.5
  ) +
  ggrepel::geom_text_repel(
    data = random_points,
    mapping = aes(label = id, geometry = geometry),
    size = 4,
    colour = "black",
    nudge_x = 2,
    nudge_y = -2,
    stat = "sf_coordinates"
  ) +
  labs(
    title = "25 random points on world map, and Countries in which they fall",
    x = NULL, y = NULL
  ) +
  theme(
    legend.position = "none"
  )
```

### 4.2.6 Distance-based Joins

-   Distance-based joins are used when geographic datasets are spatially proximate but do not intersect. The **sf** package enables such joins using spatial relationships like proximity.

-   **Example Dataset used**:

    -   `cycle_hire`: Official cycle hire points.
    -   `cycle_hire_osm`: Cycle hire points from OpenStreetMap.
    -   Relationship: These datasets are geographically close but do not overlap, as verified using [`st_intersects()`](https://r-spatial.github.io/sf/reference/st_intersects.html), which returns `FALSE` for all points.

-   **Implementation**:

    1.  **Check Proximity**:
        -   Use [`st_is_within_distance()`](https://r-spatial.github.io/sf/reference/st_is_within_distance.html) to determine points within a threshold distance (e.g., 20 meters).
    2.  **Perform Distance-based Join**:
        -   Apply [`st_join()`](https://r-spatial.github.io/sf/reference/st_join.html) with the `st_is_within_distance` predicate and a `dist` argument.
        -   The resulting dataset may contain duplicate rows if points in the target object (`cycle_hire`) match multiple points in the source (`cycle_hire_osm`).

-   **Key Observations**:

    -   Joins retain the geometry of features in the target dataset (`cycle_hire`).
    -   Distance-based joins are effective for linking datasets that are close geographically but do not overlap.

@fig-st_join2 visualizes the spatial relationship between two datasets, `cycle_hire` and `cycle_hire_osm`, using a proximity filter. The `st_filter()` function from the **sf** package identifies points in the `cycle_hire` dataset that are within 10 meters of points in `cycle_hire_osm`, leveraging the `st_is_within_distance` predicate. The result is a subset of `cycle_hire` points, which are plotted using **ggplot2**. The plot includes:

-   Filtered `cycle_hire` points (dark blue, fully opaque).

-   All `cycle_hire` points (dark blue, semi-transparent) for context.

-   All `cycle_hire_osm` points (red, semi-transparent) to show the proximity relationship.

```{r}
#| code-fold: true


data("cycle_hire")
data("cycle_hire_osm")

ggplot() +
  geom_sf(
    data = cycle_hire,
    colour = "blue",
    alpha = 0.5
  ) +
  geom_sf(
    data = cycle_hire_osm,
    colour = "red",
    alpha = 0.5
  )

st_intersects(cycle_hire, cycle_hire_osm, sparse = F) |> any()

# Official Cycle hire points with added info from OSM points within 10 metres
# 
# cycle_hire |> 
#   st_join(
#     cycle_hire_osm, 
#     join = st_is_within_distance,
#     dist = units::set_units(10, "m")
#   )


```

```{r}
#| label: fig-st_join2
#| fig-cap: "Cycle Hire Points Within 10 Meters of OpenStreetMap Locations"
#| code-fold: true

# Plot only points which have a OSM point within 10 metres
cycle_hire |> 
  st_filter(
    cycle_hire_osm,
    .predicate = st_is_within_distance,
    dist = units::set_units(10, "m")
  ) |> 
  ggplot() +
  geom_sf(size = 2, alpha = 1, colour = "darkblue") +
  geom_sf(
    data = cycle_hire, alpha = 0.2, colour = "darkblue"
  ) +
  geom_sf(
    data = cycle_hire_osm, alpha = 0.2, colour = "red"
  )

```
