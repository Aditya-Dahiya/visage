---
title: "Chapter 3: Attribute data operations"
subtitle: "Key Learnings from, and Solutions to the exercises in Chapter 3 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow."
date: "2024-11-08"
author: "Aditya Dahiya"
bibliography: references.bib
format:
  html:
    code-fold: true
editor_options: 
  chunk_output_type: console
execute: 
  error: false
  message: false
  warning: false
  eval: true
  cache: true
categories:
  - "Geocomputation with R"
  - "Textbook Solutions"
comments:
  giscus: 
    repo: Aditya-Dahiya/visage
filters:
  - social-share
  - custom-callout
custom-callout:    
  keylearning:
    icon: false
    title: "Relevant Topic"
    color: "#f0b3ff"
share:
  permalink: "https://aditya-dahiya.github.io/visage/geocomputation/chapter3.html"
  description: "Visualizing Information and Spatial Analysis with ggplot2 Extensions"
  twitter: true
  linkedin: true
  email: true
  mastodon: true
  facebook: true
---

### Prerequisites

-   `sf` for vector data manipulation ([link](https://r-spatial.github.io/sf/))
-   `terra` for raster data manipulation ([link](https://rspatial.org/terra/))
-   `dplyr` for data frame operations ([link](https://dplyr.tidyverse.org/))
-   `spData` for example datasets ([link](https://cran.r-project.org/web/packages/spData/index.html))

## 3.1 Introduction

-   **Attribute Data**: Non-spatial info tied to geographic data (e.g., bus stop name or elevation).
    -   **Vector Example**: A bus stop's location as POINT (-0.098 51.495) with attributes like its name.
    -   **Raster Example**: Pixel values represent attributes (e.g., elevation); location defined by matrix indices and resolution.
-   **Chapter Focus**:
    -   Manipulating geographic objects using attributes (e.g., names, elevations).
    -   Techniques: subsetting, aggregation, joining data, creating new variables.
    -   Vector and raster data operations are similar and interchangeable (e.g., subsetting, spatial joins).

```{r}
#| label: setup

library(sf)        # Handling Simple Features in R
library(terra)     # Handling Rasters in R
library(tidyverse) # Data Wrangling

library(spData)    # Spatial Data-sets
```

## 3.2 Vector Attribute Manipulation

-   **`sf` Package**:

    -   Extends base R's `data.frame` with a geometry column (`sfc` class) for spatial features (points, lines, polygons).
    -   Geometry column often named `geometry` or `geom`, but **customizable**.

-   **Manipulation Methods**:

    ```{r}
    #| label: tbl-methods-sf
    #| tbl-cap: "Methods available for the class 'sf' in R using {sf} package"

    methods(class = "sf") |> 
      as_tibble() |>
      rename(methods = x) |> 
      mutate(methods = str_replace_all(methods, ",sf", "  ")) |> 
      mutate(methods = str_replace_all(methods, ".sf", "  ")) |> 
      gt::gt() |> 
      gt::tab_header(
        title = "Methods available"
      ) |> 
      gt::opt_interactive()

    ```

    -   Methods like `aggregate()`, `cbind()`, `merge()`, and `rbind()` work seamlessly with `sf` objects.

    -   Compatible with tidyverse functions (`dplyr`, `tidyr`) and can be used with `data.table` (partial compatibility noted in issue [#2273](https://github.com/Rdatatable/data.table/issues/2273)).

    -   Dropping geometry (`st_drop_geometry()`) can speed up attribute data operations when spatial data is not required.

    ```{r}
    #| code-fold: false
    #| collapse: true

    # Original 'world' dataset
    dim(world)
    class(world)

    # Dropping the geometry column: Effects
    st_drop_geometry(world) |> 
      dim()
    st_drop_geometry(world) |> 
      class()
    ```

-   **Advantages**:

    -   `sf`'s integration with the tidyverse allows robust, efficient data manipulation.
    -   Compatible with tidyverse functions (e.g., `dplyr`), making it versatile for data analysis.

::: keylearning
**Major Pitfalls of Using Spatial Data with the Tidyverse**

1.  **Name Clashes**
    -   Functions like `select()` from [`dplyr`](https://dplyr.tidyverse.org/reference/select.html) can mask similar functions from the [`raster`](https://rspatial.github.io/raster/reference/select.html) package.
    -   Use fully qualified names (e.g., [`dplyr::select()`](https://dplyr.tidyverse.org/reference/select.html)) to avoid conflicts.
2.  **Compatibility Issues with `sp` Package**
    -   The older [`sp`](https://cran.r-project.org/web/packages/sp/index.html) package does not integrate well with tidyverse functions.
    -   Requires conversion between `sp` to [`sf`](https://r-spatial.github.io/sf/articles/sf1.html) object types using functions like [`st_as_sf()`](https://r-spatial.github.io/sf/reference/st_as_sf.html).
3.  **Handling Multipolygon Objects**
    -   Multiple geometries in objects can cause unexpected plotting results.
    -   Resolve issues by casting to simpler geometry types using `st_cast(to = "POLYGON")`.
4.  **Spatial Subsetting Challenges**
    -   Verbose syntax when using tidyverse functions like [`filter()`](https://dplyr.tidyverse.org/reference/filter.html) with spatial predicates like [`st_intersects()`](https://r-spatial.github.io/sf/reference/st_intersects.html).

    -   May result in altered row names, complicating joins and comparisons.

    -   Other option is spatial subsetting using base `R`

        ```{r}
        #| eval: false
        #| code-fold: false
        lnd_buff = lnd[1, ] %>% 
          st_transform(crs = 27700) %>%  # uk CRS
          st_buffer(500000) %>%
          st_transform(crs = 4326)
        near_lnd = world[lnd_buff, ]
        world_poly = world %>% 
          st_cast(to = "POLYGON")
        near_lnd_new = world_poly[lnd_buff, ]
        near_lnd_tidy = world %>% 
          filter(st_intersects(., lnd_buff, sparse = FALSE))
        ```
5.  **Row Name Alterations**
    -   Tidyverse operations may drop or alter row names, affecting joins and comparisons. See related discussion in [tidyverse/dplyr#366](https://github.com/tidyverse/dplyr/issues/366).
6.  **Attribute Alteration Pitfall**
    -   Results from tidyverse functions may differ from base R operations due to row name discrepancies.
    -   Example functions: [`filter()`](https://dplyr.tidyverse.org/reference/filter.html) vs base R subsetting (`[]`).
7.  **Issues with `bind_rows()`**
    -   [`bind_rows()`](https://dplyr.tidyverse.org/reference/bind.html) fails on spatial objects; use alternatives like setting geometries to NULL with [`st_set_geometry()`](https://r-spatial.github.io/sf/reference/st_set_geometry.html) before combining.
8.  **Limited Raster Data Support**
    -   Tidyverse integration with [`raster`](https://rspatial.github.io/raster/) data is minimal.
    -   Initial efforts like [`tabularaster`](https://cran.r-project.org/web/packages/tabularaster/index.html), [`sfraster`](https://cran.r-project.org/web/packages/sfraster/index.html), and [`stars`](https://r-spatial.github.io/stars/) aim to enhance support.
:::

### 3.2.1 Vector Attribute Sub-setting

-   **Base R Sub-setting**:
    -   Uses `[` operator and `subset()` function for rows and columns selection.

    -   Syntax: `object[i, j]` returns rows indexed by `i` and columns by `j`.
-   **`dplyr` Sub-setting Functions**:
    -   `filter()` and `slice()` for rows, `select()` for columns.

    -   **`select()`**: Subsets columns by name or position.

    -   Helper functions in `select()` like `contains()`, `starts_with()`, `num_range()`.
-   **Extracting a Single Column**:
    -   Use `pull()` (`dplyr`), `$`, or `[[` (base `R`).
-   **Row Selection**:
    -   **`slice()`**: Selects rows by index.

    -   **`filter()`**: Filters rows based on conditions.
-   **Comparison Operators**:
    -   Standard operators can be used in `filter()`: `<`, `>`, `<=`, `>=`, `==`, `!=`.

The `dplyr` functions (`filter()`, `select()`, `pull()`) are intuitive and integrate well with the tidyverse workflows.

### 3.2.2 Chaining Commands with Pipes

-   **Pipe Operator**:
    -   **`%>%`** (from the **`magrittr`** package) and native **`|>`** (from R 4.1.0 onwards) enable chaining commands, improving readability and flow of code.
    -   The output of one function becomes the input of the next.
    -   Alternative: Nested Function Calls: The same operation without pipes uses nested functions, which is harder to read.
-   **Splitting into Multiple Lines**:
    -   Useful for debugging and inspecting intermediate results but can clutter the environment.
-   **Key Packages**:
    -   [**`dplyr`**](https://dplyr.tidyverse.org/): Provides verbs like `filter()`, `select()`, `slice()`, and supports pipe workflows.
    -   [**`magrittr`**](https://magrittr.tidyverse.org/): Provides `%>%` operator for chaining functions.

### 3.2.3 Vector Attribute Aggregation

-   Aggregation is summarizing data using one or more grouping variables, often leading to a smaller dataset. It is useful for data reduction, especially when working with large datasets.
-   **Base R Approach**
    -   **Using `aggregate()`**:
        -   [**`aggregate()`**](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) groups data and applies a function (e.g., `sum`). Result: A non-spatial data frame with two columns (`continent`, `pop`).
    -   **Using `aggregate.sf()`**:
        -   For spatial objects (`sf`), use `aggregate()` with `by` argument. This results in an **`sf`** object with eight features representing continents.
-   **`dplyr` Approach**
    -   **Using `group_by()` and `summarize()`**:
        -   Equivalent to `aggregate()`, but offers flexibility and control:

            -   [**`group_by()`**](https://dplyr.tidyverse.org/reference/group_by.html) defines grouping variables.
            -   [**`summarize()`**](https://dplyr.tidyverse.org/reference/summarise.html) applies aggregation functions.

```{r}
#| eval: true

library(dplyr)
world |>
  group_by(continent) |>
  summarize(pop = sum(pop, na.rm = TRUE))
```

-   More details on grouped data and [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.html) from the **dplyr** package vignettes.

::: keylearning
**`dplyr`** functions are highly effective when applied to grouped data frames (`grouped_df` objects). Here are the main points covered:

-   **Grouping Data**: Use [**`group_by()`**](https://dplyr.tidyverse.org/reference/group_by.html) to create groups within a data frame based on one or more variables.

    -   To count rows in each group, use [**`tally()`**](https://dplyr.tidyverse.org/reference/tally.html).

-   **Accessing Group Metadata**:

    -   **`group_keys()`**: Shows underlying group data. [Details here](https://dplyr.tidyverse.org/reference/group_keys.html).
    -   **`group_vars()`**: Retrieves names of the grouping variables. [Details here](https://dplyr.tidyverse.org/reference/group_vars.html).

-   **Modifying Groups**:

    -   To overwrite or add grouping variables, use `.add = TRUE` with **`group_by()`**. [Read more](https://dplyr.tidyverse.org/reference/group_by.html).
    -   To remove groups, use [**`ungroup()`**](https://dplyr.tidyverse.org/reference/ungroup.html).

-   **Verbs and Grouping**:

    -   **`summarise()`**: Computes summary statistics per group. The `.groups` argument controls grouping structure. [More on `summarise()`](https://dplyr.tidyverse.org/reference/summarise.html).

-   **Column Manipulation**:

    -   **`select()`** retains grouping variables by default. [More on `select()`](https://dplyr.tidyverse.org/reference/select.html).
    -   **`rename()`** and **`relocate()`** function the same way for grouped and ungrouped data. [Details here](https://dplyr.tidyverse.org/reference/relocate.html).

-   **Sorting Groups**:

    -   **`arrange()`**: Sorts data, with `.by_group = TRUE` option to sort within groups. [More on `arrange()`](https://dplyr.tidyverse.org/reference/arrange.html).
:::

-   Check out [Chapter 5](https://r4ds.had.co.nz/transform.html) of [*R for Data Science*](https://r4ds.had.co.nz/).

### 3.2.4 Vector Attribute Joining

-   Joining involves combining tables based on a shared key variable. In R, `dplyr` functions like `left_join()` and `inner_join()` are commonly used for this purpose.

    -   The join functions in `dplyr` (`left_join`, `inner_join`, etc.) follow conventions from SQL, allowing easy and consistent data merging.
    -   These functions work similarly for both non-spatial (`data.frame`) and spatial (`sf`) objects. The geometry list column in `sf` objects is the key difference.

-   **When merging an `sf` object with a data.frame**

    -   The resulting object remains an `sf` object, keeping its spatial features intact while adding new columns for coffee production.

-   **Handling Key Variables**:

    -   If datasets have key variables with matching names (e.g., `name_long`), joining works automatically.
    -   If the key variables differ, either:
        -   Rename the variable to match, or
        -   Use the `by` argument to specify the joining variables explicitly.

-   **Inner Joins**:

    -   An **inner join** keeps only the rows with matching key variables in both datasets. This reduces the number of rows, depending on the overlap in key variables.

-   **Troubleshooting Joins**:

    -   If some rows are missing in the result (e.g., due to differing key names like "Congo, Dem. Rep. of"), identify mismatches using `setdiff()`.
    -   Use regex matching from the `stringr` package to identify correct key names for adjustments.

-   **Reversing Joins**:

    -   You can also join starting with a non-spatial dataset and adding spatial variables from an `sf` object.
    -   **The result will be a non-spatial `data.frame` (tibble), unless explicitly converted to an `sf` object using `st_as_sf()`.**

-   **Further Resources**:

    -   [Chapter 13](https://r4ds.had.co.nz/relational-data.html?q=join#relational-data) on Relational Data in [R for Data Science](https://r4ds.had.co.nz/relational-data.html?q=join#relational-data) by Grolemund and Wickham (2016)

    -   The [documentation](https://asardaes.github.io/table.express/articles/joins.html) describing joins with **`data.table`** package.

    -   The join [vignette](https://geocompx.github.io/geocompkg/articles/join.html) in the `geocompkg` package, which is summarized below: —

::: keylearning
**Spatial Joins Extended**

-   Spatial Joins: Combines attributes from different datasets based on a common key, useful for integrating non-spatial (attribute) data with spatial data.

#### Left Join

-   Adds attributes to all observations from the left dataset with matched values from the right.

#### Joining by Different Column Names

-   Case: If key columns have different names, use a named vector to specify the keys

-   Issue: Duplicate columns (e.g., `tbl_1_var.x` and `tbl_2_var.y`). Resolved by specifying all keys.

#### Joining with a Non-Spatial First Argument

-   Dropping Geometry: `st_drop_geometry()` removes spatial attributes, allowing joins with standard data frames.

#### Inner Join

-   Keeps only rows with matching keys in both datasets.
:::

### 3.2.5 Creating attributes and removing spatial information

-   **Creating new attributes**:
    -   Calculate a new attribute using `mutate()` from `dplyr`. Example: `population / area`.
    -   Use `mutate()` to add the new column without overwriting the geometry column.
-   **Combining columns**:
    -   Use [`unite()`](https://tidyr.tidyverse.org/reference/unite.html) from `tidyr` to merge two or more columns into one (e.g., `continent` and `region_un`).
    -   `unite()` allows setting a separator (e.g., `:`) and can optionally remove the original columns.
-   **Splitting columns**:
    -   Use [`separate_wider_position()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.html) and [`separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.html)from `tidyr` to split a combined column back into its original components.
-   **Renaming columns**:
    -   Use [`rename()`](https://dplyr.tidyverse.org/reference/rename.html) from `dplyr` for renaming specific columns.
    -   For renaming all columns, use [`setNames()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/setNames) with a character vector for new names.
-   **Removing geometry**:
    -   Use [`st_drop_geometry()`](https://r-spatial.github.io/sf/reference/st_geometry.html) to drop the spatial information while retaining the attributes in a non-spatial `data.frame`. This method is preferred over manually selecting non-geometry columns as it avoids unintended issues.

## 3.3 Manipulating Raster Objects

-   **Raster Data Model**:
    -   Represents continuous surfaces, unlike vector data which use discrete entities (points, lines, polygons).
    -   Useful for representing spatial phenomena like elevation, temperature, and land cover.
-   **Creating a Raster Object**:
    -   Use `rast()` function to create raster objects.
    -   The `vals` argument assigns numeric values to each cell.
-   **Categorical Raster Values**:
    -   Can hold logical or factor (categorical) values.
    -   Example: Creating a raster for soil types (`clay`, `silt`, `sand`).
-   **Raster Attribute Table (RAT)**:
    -   Stores additional information about raster values, accessible with `cats()`.
    -   Each layer's attribute data can be modified with `levels()`.
-   **Color Table**:
    -   Categorical rasters can store color information using a color table with RGB (Red, Green, Blue) or RGBA (Red, Green, Blue, Alpha) columns.
    -   Use `coltab()` to view or set color tables.
    -   Saving the raster (e.g., as GeoTIFF) includes the color table information.

### 3.3.1 Raster subsetting

-   **Raster Subsetting**:

    -   Involves selecting specific parts of a raster dataset using the base R subsetting operator `[ , ]`.
    -   **Subsetting Methods**:
        1.  **Row-Column Indexing**: Accesses cells using specific row and column coordinates.
        2.  **Cell IDs**: Accesses cells using unique numeric identifiers for each raster cell.
        3.  **Coordinates and Spatial Objects**: These methods are used for spatial subsetting, using another spatial object to subset a raster.

-   **Examples**:

    -   Accessing the top-left pixel value using row-column indexing:

```{r}
#| label: raster-1
#| collapse: true
#| eval: true

# A simple raster
  elev <- rast(
    nrows = 10, ncols = 10,
    xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,
    vals = 1:100
    ) 

# A raster with categorical levels
grain <- rast(
  nrows = 10, ncols = 10,
  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,
  vals = sample(
    x = c("Wheat", "Rice", "Maize", "Others"),
    size = 100,
    replace = TRUE
  )
)

    # Print the "elev" object to visualize the design
    print(elev)

    # Plot the raster object to visualize the matrix as an image
    plot(
      elev, 
      main = "Raster Object with a Sequential Pattern"
    )

    # Accessing using row number and column number
    elev[1, 1]

    elev[10,5]


    plot(
      grain,
      main = "Raster Object with 4 categorical levels"
    )

    # Accessing using row number and column number

    grain[1,1]

    grain[10, 10]

    # A multilayered raster - combining both
    two_layers <- c(elev, grain)

    print(two_layers)
    names(two_layers) <- c("Continuous variable", 
                           "Categorical variable")
    plot(
      two_layers
    )

```

-   Accessing the first cell using its Cell ID:

```{r}
#| eval: true
#| label: raster-2
#| collapse: true

# Accessing raster values using cell ID
elev[1]
elev[95]
```

-   **Subsetting Multi-layered Rasters**:

    -   For multi-layer raster objects (e.g., `two_layers = c(grain, elev)`), subsetting returns values from each layer:

```{r}
#| eval: true
#| code-fold: false

two_layers[1]

```

-   To extract all cell values from a raster:

```{r}
#| eval: true
#| code-fold: false

# Extracting all values - single layer raster
elev[][1:10]  

# It is Equivalent to using the values() function
values(elev)[1:10]

# Extracting all values - multi-layer raster
# It returns a data.frame
values(two_layers) |> 
  as_tibble()
```

-   **Modifying Raster Values**:

    -   Change specific cell values by combining subsetting with assignment:

```{r}
#| eval: true
#| code-fold: false

elev[5, 5] = 0  # Sets the value of the 1 central cells to 0

plot(elev)

```

-   Modify multiple cells simultaneously:

```{r}
#| eval: true
#| code-fold: false


elev[5, c(5,6)] = 0  # Sets the value of the central 2 cells to 0

plot(elev)

```

-   **Replacing Values in Multi-layered Rasters**:

    -   Modify cell values in a multi-layer raster using a matrix with corresponding layers and cell indices:

```{r}
#| eval: true
#| code-fold: false
# Assigns new values for Cell ID 1 in both layers
two_layers[45] = cbind(c(1), c(4))  

plot(two_layers)
```

This subsetting approach allows efficient extraction and manipulation of raster cell values, enabling the customization of raster datasets for specific analytical needs.

### 3.3.2 Summarizing Raster Objects

-   **Descriptive Statistics**:
    -   The **terra** package provides functions for summarizing raster objects.
    -   Printing a raster object directly shows the **minimum** and **maximum** values.
    -   The [`summary()`](https://rspatial.github.io/terra/reference/summary.html) function provides detailed statistics:
        -   For **continuous rasters**: Minimum, maximum, quartiles, and count of NAs.
        -   For **categorical rasters**: Counts of each unique class.

```{r}
#| eval: true
#| collapse: true
#| code-fold: false

summary(two_layers)
```

-   **Custom Summary Statistics**:
    -   The [`global()`](https://rspatial.github.io/terra/reference/global.html) function calculates additional statistics like **standard deviation** and can be used to apply custom summary statistics.

```{r}
#| eval: true
#| code-fold: false

global(two_layers, sum)

global(two_layers, mean)

```

-   **Frequency Table**:
    -   The [`freq()`](https://rspatial.github.io/terra/reference/freq.html) function generates a frequency table for categorical raster values, showing counts of each category.

```{r}
#| eval: true
#| tbl-cap: "Frequency table using freq() on raster objects"
#| label: tbl-freq-raster

freq(two_layers$`Categorical variable`) |> 
  gt::gt() |> 
  gtExtras::gt_theme_538()

```

-   **Visualization of Raster Statistics**:
    -   Several functions like [`hist()`](https://rspatial.github.io/terra/reference/hist.html), [`boxplot()`](https://rspatial.github.io/terra/reference/boxplot.html), and [`density()`](https://rspatial.github.io/terra/reference/density.html) work directly with raster objects to visualize statistics.
    -   If visualization functions do not support raster objects, values can be extracted using [`values()`](https://rspatial.github.io/terra/reference/values.html) for further plotting.
-   **Handling Function Name Clashes**:
    -   Some functions (e.g., `extract()`) exist in multiple packages like **terra** and **tidyr**, leading to conflicts.
    -   To avoid issues, call functions with full namespaces (e.g., `tidyr::extract()`).
        -   Use [`detach()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/detach.html) to unload conflicting packages, but be cautious as it may impact dependent packages.

## 3.4 Exercises

```{r}
#| code-fold: false
#| eval: true
#| echo: true

library(sf)
library(dplyr)
library(terra)
library(spData)
data(us_states)
data(us_states_df)

```

### E1

**Create a new object called `us_states_name` that contains only the `NAME` column from the `us_states` object using either base R (`[`) or tidyverse ([`select()`](https://dplyr.tidyverse.org/reference/select.html)) syntax. What is the class of the new object and what makes it geographic?**

```{r}
#| code-fold: false
#| eval: true

us_states_name <- us_states |> 
  select(NAME)

class(us_states_name)
```

The new object of the class `sf`, and the stickiness of the `geometry` column makes it a geographical dataset.

------------------------------------------------------------------------

### E2

**Select columns from the `us_states` object which contain population data. Obtain the same result using a different command (bonus: try to find three ways of obtaining the same result). Hint: try to use helper functions, such as `contains` or `matches` from dplyr (see [`?contains`](https://tidyselect.r-lib.org/reference/starts_with.html)).**

```{r}
#| code-fold: false
#| eval: true

us_states

```

------------------------------------------------------------------------

### E3

**Find all states with the following characteristics (bonus: find *and* plot them):**

-   **Belong to the Midwest region.**

-   **Belong to the West region, have an area below 250,000 km^2^*and* in 2015 a population greater than 5,000,000 residents (hint: you may need to use the function [`units::set_units()`](https://r-quantities.github.io/units/reference/units.html) or [`as.numeric()`](https://rdrr.io/r/base/numeric.html)).**

-   **Belong to the South region, had an area larger than 150,000 km^2^ and a total population in 2015 larger than 7,000,000 residents.**

------------------------------------------------------------------------

### E4

**What was the total population in 2015 in the `us_states` dataset? What was the minimum and maximum total population in 2015?**

------------------------------------------------------------------------

### E5

**How many states are there in each region?**

------------------------------------------------------------------------

### E6

**What was the minimum and maximum total population in 2015 in each region? What was the total population in 2015 in each region?**

------------------------------------------------------------------------

### E7

**Add variables from `us_states_df` to `us_states`, and create a new object called `us_states_stats`. What function did you use and why? Which variable is the key in both datasets? What is the class of the new object?**

------------------------------------------------------------------------

### E8

**`us_states_df` has two more rows than `us_states`. How can you find them? (Hint: try to use the [`dplyr::anti_join()`](https://dplyr.tidyverse.org/reference/filter-joins.html) function.)**

------------------------------------------------------------------------

### E9

**What was the population density in 2015 in each state? What was the population density in 2010 in each state?**

------------------------------------------------------------------------

### E10

**How much has population density changed between 2010 and 2015 in each state? Calculate the change in percentages and map them.**

------------------------------------------------------------------------

### E11

**Change the columns’ names in `us_states` to lowercase. (Hint: helper functions - [`tolower()`](https://rdrr.io/r/base/chartr.html) and [`colnames()`](https://rdrr.io/r/base/colnames.html) may help.)**

------------------------------------------------------------------------

### E12

**Using `us_states` and `us_states_df` create a new object called `us_states_sel`. The new object should have only two variables: `median_income_15` and `geometry`. Change the name of the `median_income_15` column to `Income`.**

------------------------------------------------------------------------

### E13

**Calculate the change in the number of residents living below the poverty level between 2010 and 2015 for each state. (Hint: See ?us_states_df for documentation on the poverty level columns.) Bonus: Calculate the change in the *percentage* of residents living below the poverty level in each state.**

------------------------------------------------------------------------

### E14

**What was the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region? Bonus: What is the region with the largest increase in people living below the poverty line?**

------------------------------------------------------------------------

### E15

**Create a raster from scratch, with nine rows and columns and a resolution of 0.5 decimal degrees (WGS84). Fill it with random numbers. Extract the values of the four corner cells.**

------------------------------------------------------------------------

### E16

**What is the most common class of our example raster `grain`?**

------------------------------------------------------------------------

### E17

**Plot the histogram and the boxplot of the `dem.tif` file from the spDataLarge package (`system.file("raster/dem.tif", package = "spDataLarge")`).**
