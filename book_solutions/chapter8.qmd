---
title: "Chapter 8: Geographic data I/O"
subtitle: "Key Learnings from, and Solutions to the exercises in Chapter 8 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow."
date: "2025-01-19"
author: "Aditya Dahiya"
bibliography: references.bib
format:
  html:
    code-fold: true
editor_options: 
  chunk_output_type: console
execute: 
  error: false
  message: false
  warning: false
  eval: false
  cache: false
categories:
  - "Geocomputation with R"
  - "Textbook Solutions"
comments:
  giscus: 
    repo: Aditya-Dahiya/visage
filters:
  - social-share
share:
  permalink: "https://aditya-dahiya.github.io/visage/book_solutions/chapter8.html"
  description: "Visualizing Information and Spatial Analysis with ggplot2 Extensions"
  twitter: true
  linkedin: true
  email: true
  mastodon: true
  facebook: true
---

```{r}
#| label: setup
#| eval: true

library(sf)        # Simple Features in R
library(terra)     # Handling rasters in R
library(tidyterra) # For plotting rasters in ggplot2
library(magrittr)  # Using pipes with raster objects
library(tidyverse) # All things tidy; Data Wrangling
library(spData)    # Spatial Datasets
library(patchwork) # Composing plots
library(gt)        # Display GT tables with R
```

## 8.1 Introduction

-   **Importance of Data I/O**: Geographic data input/output (I/O) is critical for geocomputation, ensuring accurate real-world applications and enabling data sharing.
-   **Impact of Errors**: Mistakes in data I/O (e.g., using outdated datasets) can cause significant issues later in projects.

## 8.2 File Formats

-   **Geographic data storage**: Stored as files or spatial databases. File formats can store either vector or raster data; databases can handle both, and the most common types are shown in @tbl-file-formats.

```{r}
# A Code to fetch icons of different file formats
# Get file icons for common file types
file_format = c(
  "Shapefile", "GeoJSON", "KML", "GPKG", "CSV", "DXF", "MapInfo File", "GML", 
  "PostGIS", "TopoJSON", "GeoTIFF", "NetCDF", "JPEG", "PNG", "HDF4", "HDF5", 
  "GRIB", "Erdas Imagine", "ASCII Grid", "MBTiles")

temp_df <- tibble(
  file_format = file_format,
  id = 1:20
)

# Get a custom google search engine and API key
# Tutorial: https://developers.google.com/custom-search/v1/overview
# Tutorial 2: https://programmablesearchengine.google.com/
# google_api_key <- "LOAD YOUR GOOGLE API KEY HERE"
# my_cx <- "GET YOUR CUSTOM SEARCH ENGINE ID HERE"


# Load necessary packages
library(httr)
library(magick)

# Define function to download and save movie poster
download_icons <- function(file_format_name, id) {
  
  api_key <- google_api_key
  cx <- my_cx
  
  # Build the API request URL
  url <- paste0("https://www.googleapis.com/customsearch/v1?q=", 
                URLencode(paste0(file_format_name, " file icon svg")), 
                "&cx=", cx, 
                "&searchType=image&key=", api_key)
  
  # Make the request
  response <- GET(url)
  result <- content(response, "parsed")
  
  # Get the URL of the first image result
  image_url <- result$items[[1]]$link
  
  im <- magick::image_read(image_url) |> 
    image_resize("x100")
  
  # set background as white
  image_write(
    image = im,
    path = here::here("book_solutions", "images", "temp_icons", 
                      paste0("temp_icon_", id,".png")),
    format = "png"
    )
}

for (i in 1:20) {
  download_icons(
    file_format_name = temp_df$file_format[i],
    id = i
  )
}


# for (i in c(1:3, 5:14, 16:17, 19)) {
#   download_icons(
#     file_format_name = temp_df$file_format[i],
#     id = i
#   )
# }

# Some custom work
image_url_4 <- "https://icons.veryicon.com/png/o/construction-tools/supermap-gis-product-color-system-function/postgis-workspace.png"

image_url_15 <- "https://cdn.iconscout.com/icon/premium/png-256-thumb/hdf-file-2538306-2129659.png"

image_url_18 <- "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQA0Pb2JqaMO5UGuYCgZzRi4BXQCw9lbmTDvg&s"

image_url_20 <- "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRlucEC8-sm9U0IXIfY-wh_c3nBFKLyg0JJdQ&s"

image_url_19 <- "https://cdn.iconscout.com/icon/premium/png-256-thumb/ascii-file-1934516-1634566.png?f=webp&w=256"

download_icon_custom <- function(id) {
  im <- magick::image_read(get(paste0("image_url_", id))) |>
    image_resize("x100")

  # set background as white
  image_write(
    image = im,
    path = here::here("book_solutions", "images", "temp_icons",
                      paste0("temp_icon_", id,".png")),
    format = "png"
    )
}

for (i in c(4, 15, 18, 20)) {
  download_icon_custom(i)
}

image_url_7 <- "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR0Zb1IW-Ui71fJQy4G5kj3Ue2zQop38Kn1mA&s"

image_url_12 <- "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTr8HP5xS8im3nK5Zm8l4iP8zDrGhoiakFbCA&s"

for (i in c(7, 12, 19)) {
  download_icon_custom(i)
}

image_url_11 <- "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSHPryNCuawMSnTpre5hHZZiGuWqAhRQsjWQg&s"

download_icon_custom(11)
```

```{r}
#| eval: true
#| label: tbl-file-formats
#| tbl-cap: "Different kinds of File Formats dealing with Geo-Spatial Data"

# Get file icons for common file types
file_format = c(
  "Shapefile", "GeoJSON", "KML", "GPKG", "CSV", "DXF", "MapInfo File", "GML", 
  "PostGIS", "TopoJSON", "GeoTIFF", "NetCDF", "JPEG", "PNG", "HDF4", "HDF5", 
  "GRIB", "Erdas Imagine", "ASCII Grid", "MBTiles")

temp_df <- tibble(
  file_format = file_format,
  id = 1:20
)


# Raster formats tibble
raster_formats <- tibble(
  Format = c(
    "GeoTIFF", "NetCDF", "JPEG", "PNG", "HDF4", "HDF5", 
    "GRIB", "Erdas Imagine", "ASCII Grid", "MBTiles"
  ),
  Description = c(
    "Tagged Image File Format for georeferenced raster data.",
    "Network Common Data Form for array-oriented scientific data.",
    "Compressed image format commonly used for photographic images.",
    "Portable Network Graphics format for raster graphics.",
    "Hierarchical Data Format v4 for scientific data.",
    "Hierarchical Data Format v5, successor to HDF4.",
    "Gridded Binary format for meteorological data.",
    "Raster format for Erdas Imagine software.",
    "ASCII representation of raster data.",
    "SQLite-based raster tile storage format."
  ),
  Extension = c(
    ".tif/.tiff", ".nc", ".jpg/.jpeg", ".png", ".hdf", 
    ".h5", ".grb/.grib", ".img", ".asc", ".mbtiles"
  ),
  GeoReferencing = c(
    "Yes", "Yes", "No", "No", "Yes", "Yes", 
    "Yes", "Yes", "Yes", "Yes"
  )
) |> 
  mutate(group = "Raster File Formats")

# Vector formats tibble
vector_formats <- tibble(
  Format = c("Shapefile", "GeoJSON", "KML", "GPKG", "CSV", "DXF", 
             "MapInfo File", "GML", "PostGIS", "TopoJSON"),
  Description = c(
    "Esri Shapefile format for vector geometries.",
    "GeoJSON format for encoding a variety of geographic data structures.",
    "Keyhole Markup Language for geographic data in XML.",
    "Geopackage format for spatial data storage.",
    "Comma-Separated Values for point data with attributes.",
    "Drawing Exchange Format for CAD data.",
    "MapInfo TAB format for vector geometries.",
    "Geography Markup Language for XML-based vector data.",
    "PostGIS spatial extension for PostgreSQL database.",
    "TopoJSON format for topology-preserving JSON data."
  ),
  Extension = c(".shp", ".geojson", ".kml", ".gpkg", ".csv", ".dxf", 
                ".tab", ".gml", "PostgreSQL", ".topojson"),
  GeoReferencing = c(
    "Yes", "Yes", "Yes", "Yes", "No", "No", 
    "Yes", "Yes", "Yes", "Yes"
  )
) |> 
  mutate(
    group = "Vector File Formats"
  )

# Display vector formats table
bind_rows(
  vector_formats,
  raster_formats
) |> 
  left_join(temp_df, by = join_by(Format == file_format)) |> 
  mutate(file_path = paste0("images/temp_icons/temp_icon_", id, ".png")) |> 
  select(-id) |> 
  group_by(group) |> 
  gt() |> 
  cols_label(
    Format = "File Format",
    Description = "Description",
    Extension = "File Extension",
    GeoReferencing = "Geo-referencing",
    file_path = "File Icon"
  ) |> 
  tab_footnote(
    md("_**Source**: GDAL documentation (https://gdal.org/)_")
  ) |> 
  tab_header(
    title = "Different kinds of file formats for geographical data"
  ) |> 
  gtExtras::gt_theme_538() |> 
  fmt_image(
    columns = file_path
  ) |> 
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      columns = Format
    )
  ) |> 
  tab_style(
    style = list(
      cell_text(color = "darkgreen", weight = "bold")
    ),
    locations = cells_body(
      rows = GeoReferencing == "Yes",
      columns = GeoReferencing
    )
  ) |> 
  tab_style(
    style = list(
      cell_text(color = "red", weight = "bold")
    ),
    locations = cells_body(
      rows = GeoReferencing == "No",
      columns = GeoReferencing
    )
  ) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(
      columns = c(Extension, GeoReferencing)
    )
  ) |> 
  tab_style(
    style = list(
      cell_text(align = "left")
    ),
    locations = cells_body(
      columns = Description
    )
  ) |> 
  tab_style(
    style = list(
      cell_fill(color = "lightgrey"),    
      cell_text(weight = "bold", align = "center")      
    ),
    locations = cells_row_groups()           
  ) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_title()
  )

```

-   **GDAL (Geospatial Data Abstraction Library)**:
    -   Unified library for reading/writing raster and vector formats since the year 2000.
    -   Powers GIS software like GRASS GIS, ArcGIS, and QGIS.
    -   Supports over 200 vector and raster formats.
-   **Common vector file formats**:
    -   ESRI Shapefile: Multi-file format; limited by 2GB size, 255 columns, and 10-character names.
    -   GeoJSON: JSON-based, supports coordinates; open format.
    -   KML/KMZ: XML-based; used for Google Earth.
    -   GPX: GPS data exchange.
    -   FlatGeobuf: Fast, single-file with streaming capabilities.
-   **Common raster file formats**:
    -   GeoTIFF: Popular raster format embedding CRS; supports COG (Cloud Optimized GeoTIFF) for efficient online access.
    -   Arc ASCII: Text-based raster format with header and cell values.
-   **Database formats**:
    -   SQLite/SpatiaLite: Lightweight relational database with spatial extensions.
    -   ESRI FileGDB: Proprietary database format supporting feature classes and topology.
    -   GeoPackage: Open standard SQLite-based lightweight spatial database for vector, raster, and non-spatial data.
-   **Open standards by OGC (Open Geospatial Consortium)**:
    -   Promotes transparency and user-driven development.
    -   Formats like GML, KML, and GeoPackage adhere to OGC standards.

::: callout-note
### ShapeFiles and their Limitations

ESRI Shapefiles have been a cornerstone in geospatial data exchange since their introduction in the early 1990s.

**Reasons for Shapefile Popularity:**

1.  Historical Prevalence: Introduced by ESRI in the early 1990s, Shapefiles became widely adopted due to their early entry into the GIS market.

2.  Simplicity and Compatibility: Shapefiles are straightforward to use and are supported by a vast array of GIS software, facilitating easy sharing and exchange of geographic information across different platforms.

3.  Open Specification: Despite being a proprietary format, ESRI published the technical specifications for Shapefiles, allowing other software developers to implement support for them, which contributed to their widespread adoption.

**Contents of a ShapeFile Folder**

-   **`.shp`:** Stores geometric shape data (points, lines, polygons).
-   **`.shx`:** Index file for quick spatial queries of shapes.
-   **`.dbf`:** Attribute table with associated data in tabular format.
-   **`.prj`:** Coordinate system and projection information.
-   **`.cpg`:** Encoding of character data (e.g., UTF-8).
-   **`.sbn/.sbx`:** Optional spatial index for faster searches.
-   **`.qpj`:** Alternative projection format used by some software.

**Limitations of Shapefiles:**

1.  Multi-File Structure: A single Shapefile consists of multiple files (e.g., `.shp`, `.shx`, `.dbf`), which can complicate file management and increase the risk of losing associated files.

2.  Attribute Constraints: Field names in the attribute table are limited to 10 characters, and the maximum number of fields is 255, restricting the complexity of attribute data that can be stored.

3.  File Size Limitation: Shapefiles have a maximum size limit of 2 GB, which can be restrictive for large datasets.

4.  Lack of Topological Information: Shapefiles do not store topological relationships between features, limiting their utility in analyses that require such information.

5.  Limited Data Types and Encoding: Shapefiles have poor support for Unicode, limiting international character representation, and they cannot store null values for numeric or text fields, which can lead to data inaccuracies.

**Emerging Alternatives:**

1.  **GeoPackage:** An open, standards-based format developed by the Open Geospatial Consortium (OGC), GeoPackage uses a single SQLite database file to store both vector and raster data, overcoming many of the limitations associated with Shapefiles.

2.  **File Geodatabase:** ESRI's File Geodatabase offers a more robust solution with no size limitations, support for complex data types, and improved performance, making it a suitable alternative for users within the ESRI ecosystem.

3.  **GeoJSON:** A format based on JavaScript Object Notation (JSON), GeoJSON is widely used for web applications and supports a variety of geometry types, making it a flexible alternative for sharing geospatial data, especially in web environments.

4.  **FlatGeobuf:** A modern, open format designed for performant reading and writing of geospatial data, FlatGeobuf supports spatial indexing and is suitable for web and cloud environments.
:::

-   **Other new emerging formats**:
    -   LAS/LAZ: For lidar point clouds.
    -   NetCDF/HDF: For multidimensional arrays.
    -   Emerging formats: GeoArrow, Zarr.
-   **Non-spatial formats**:
    -   Tabular formats (e.g., CSV, Excel) used for simple spatial data sharing.
    -   Lack support for complex geometries and spatial metadata like CRS.
-   **Additional resources**:
    -   [GDAL Documentation](https://gdal.org/) offers comprehensive details on supported [vector formats](https://gdal.org/en/stable/drivers/vector/index.html) and [raster formats](https://gdal.org/en/stable/drivers/raster/index.html).

### 8.3.1 Vector Data

-   **Spatial vector data formats:** Common formats include `.geojson`, `.gpkg`, `.shp`. Import these with [sf::read_sf()](https://r-spatial.github.io/sf/reference/read_sf.html) or [sf::st_read()](https://r-spatial.github.io/sf/reference/st_read.html), which rely on GDAL drivers.

-   **Driver overview:** Use [sf::st_drivers()](https://r-spatial.github.io/sf/reference/st_drivers.html) to see available GDAL drivers, their features, and file format capabilities (e.g., vector, raster support).

```{r}
#| tbl-cap: "The drivers available to GDAL, and therefore {sf}, in R, accessed using st_driver()"
#| label: tbl-8-3-1


st_drivers("vector") |> 
  as_tibble()

```

-   `read_sf()` arguments and their purposes: —

    -   **File input:**

        -   `dsn` parameter specifies file paths, folders, database credentials, or GeoJSON strings.
        -   Drivers are auto-detected from file extensions like `.gpkg` or `.shp`.

    -   **Multiple layers:** Some formats (e.g., `.gpkg`) support multiple data layers. Use the `layer` argument in `read_sf()` to specify the desired layer.

    -   **Subset data reading:**

        -   `query`: Use OGR SQL queries for conditional imports (e.g., filter rows by column values).
        -   `wkt_filter`: Filter geometries using Well-Known Text (WKT) spatial queries (e.g., buffers around a region).

-   **Driver-specific options:**

    -   Formats like `.csv` require specifying coordinate column names via the `options` parameter. Refer to [GDAL driver documentation](https://gdal.org/drivers/index.html) for details.

-   Coordinate Reference Systems (CRS): If missing, assign CRS using [`sf::st_set_crs()`](https://r-spatial.github.io/sf/reference/st_set_crs.html).

-   Other formats: `.kml`: Use [sf::st_layers()](https://r-spatial.github.io/sf/reference/st_layers.html) to list layers in KML files before reading specific layers.

-   **Alternative tools:** [duckdb](https://duckdb.org/), an R interface with spatial extension, offers additional options for data import and querying.

::: callout-note
**Integrating DuckDB's spatial extension with R and the `{sf}` package**

1.  Install and Load DuckDB's Spatial Extension: This setup enables geospatial data processing capabilities within DuckDB.

    ``` r
    library(DBI)
    con <- dbConnect(duckdb::duckdb())
    dbExecute(con, "INSTALL spatial;")
    dbExecute(con, "LOAD spatial;")
    ```

2.  Import Geospatial Data into DuckDB: This command reads the specified shapefile and creates a table named `spatial_data` containing the geospatial information.

    ``` sql
    CREATE TABLE spatial_data AS
    SELECT * FROM ST_Read('path/to/your/file.shp');
    ```

3.  Perform Spatial Queries in DuckDB: With the spatial extension, you can execute spatial functions such as `ST_Intersects`, `ST_Within`, and `ST_Contains` directly within DuckDB.

    ``` sql
    SELECT *
    FROM spatial_data
    WHERE ST_Within(geometry_column, ST_GeomFromText('POLYGON((...))'));
    ```

4.  Export Data to R for Use with `{sf}`: After processing, you can export the geospatial data back to R and convert it into an `{sf}` object for further analysis or visualization.

    ``` r
    spatial_df <- dbGetQuery(con, "SELECT * FROM spatial_data;")
    library(sf)
    sf_object <- st_as_sf(spatial_df, wkt = "geometry_column")
    ```
:::
