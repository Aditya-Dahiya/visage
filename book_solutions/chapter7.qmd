---
title: "Chapter 7: Reprojecting geographic data"
subtitle: "Key Learnings from, and Solutions to the exercises in Chapter 7 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow."
date: "2025-01-10"
author: "Aditya Dahiya"
bibliography: references.bib
format:
  html:
    code-fold: true
editor_options: 
  chunk_output_type: console
execute: 
  error: false
  message: false
  warning: false
  eval: false
  cache: false
categories:
  - "Geocomputation with R"
  - "Textbook Solutions"
comments:
  giscus: 
    repo: Aditya-Dahiya/visage
filters:
  - social-share
share:
  permalink: "https://aditya-dahiya.github.io/visage/book_solutions/chapter7.html"
  description: "Visualizing Information and Spatial Analysis with ggplot2 Extensions"
  twitter: true
  linkedin: true
  email: true
  mastodon: true
  facebook: true
---

```{r}
#| label: setup
#| eval: true

library(sf)        # Simple Features in R
library(terra)     # Handling rasters in R
library(tidyterra) # For plotting rasters in ggplot2
library(magrittr)  # Using pipes with raster objects
library(tidyverse) # All things tidy; Data Wrangling
library(spData)    # Spatial Datasets
library(patchwork) # Composing plots

greenland <- rnaturalearth::ne_countries(
  geounit = "Greenland",
  scale = "medium",
  returnclass = "sf"
  ) |> 
  select(admin, name, iso_a3, geometry)

sysfonts::font_add_google("Saira Condensed", "body_font")
showtext::showtext_auto()
theme_set(
  theme_minimal(
    base_family = "body_font",
    base_size = 14,
    base_line_size = 0.2
  ) +
    theme(
      text = element_text(
        colour = "grey20"
      ),
      plot.title = element_text(
        size = 24,
        margin = margin(0.1, 0.1, 0.1, 0.1, "lines")
      ),
      plot.subtitle = element_text(
        size = 16,
        margin = margin(0.1, 0.1, 0.1, 0.1, "lines")
      )
    )
)
```

::: callout-note
For the first few sections, I will use the map of Greenland as an example, since it is an extreme case (far away from equator, so a good use for CRS projections examples), as shown in @fig-7-1_1.
:::

### 7.1 Introduction

-   Coordinate Reference Systems (CRSs): Two main types:
    -   **Geographic CRS**: A reference system that defines locations on the Earth using a spherical or ellipsoidal model. It specifies positions in terms of latitude and longitude, with angular measurements relative to the Earth's center. Uses longitude/latitude (units in degrees)
    -   **Projected CRS**: A reference system that transforms the Earth's curved surface into a flat map. It uses linear units like meters and focuses on minimizing distortions in specific aspects such as distance, area, or shape, depending on the map's purpose. Uses meters from a datum (projected system).

+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Aspect**               | **Geographic CRS**                                                                  | **Projected CRS**                                                                                   |
+==========================+=====================================================================================+=====================================================================================================+
| **Definition**           | Represents locations on the Earth's surface using a spherical or ellipsoidal model. | Represents locations on a flat, two-dimensional surface using a projected system.                   |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Units of Measurement** | Uses angular units (degrees of longitude and latitude).                             | Uses linear units (meters, feet, etc.).                                                             |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Coordinate Axes**      | Longitude (x-axis) and Latitude (y-axis).                                           | X (east-west) and Y (north-south) in a flat plane.                                                  |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Purpose**              | Ideal for global-scale mapping and geodetic calculations.                           | Ideal for local or regional mapping, where accurate distances, angles, and areas are required.      |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Accuracy**             | Retains accurate angular relationships but distorts distances and areas.            | Distorts angular relationships but preserves distances, areas, or shapes (depending on projection). |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Examples**             | WGS84 (used in GPS), NAD83.                                                         | UTM (Universal Transverse Mercator), State Plane.                                                   |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Key Feature**          | Geocentric, based on Earth's shape as an ellipsoid.                                 | Flat, derived by projecting the Earth onto a 2D surface using a mathematical formula.               |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| **Applications**         | Satellite data, GPS, global navigation systems.                                     | Engineering projects, land use planning, local/regional maps.                                       |
+--------------------------+-------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+

-   **Focus of the Chapter:**

    -   Setting and transforming CRSs in geographic data.
    -   Highlighting issues caused by ignoring CRSs, especially with lon/lat data.

-   **Practical Relevance:**

    -   Many projects don't require conversion between CRSs but knowing whether your data is in a projected or geographic CRS is critical.
    -   Understanding CRSs prevents errors and ensures smooth handling of geographic data.

```{r}

g1 <- greenland |> 
  ggplot() +
  geom_sf() +
  labs(title = "WGS84 / EPSG:4326", subtitle = "Default geographic projection")

g2 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "EPSG:3857") +
  labs(title = "EPSG:3857", subtitle = "Web Mercator projection")

g3 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "ESRI:102004") +
  labs(title = "ESRI:102004", subtitle = "Lambert Conformal Conic")

g4 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "ESRI:54030") +
  labs(title = "ESRI:54030", subtitle = "Robinson projection")

g5 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "EPSG:3413") +
  labs(title = "EPSG:3413", subtitle = "North Pole Stereographic")

g <- g1 + g2 + g3 + g4 + g5 +
  plot_layout(nrow = 1) +
  plot_annotation(
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")"
    ) &
  theme(
    plot.tag = element_text(
      size = 40,
      face = "bold"
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-1_1.png"),
  height = 600,
  width = 2400,
  unit = "px",
  bg = "white"
)
```

![Map of Greenland, with different projections from (a) to (e)](images/chapter7-1_1.png){#fig-7-1_1}

### 7.2 Coordinate Reference Systems

-   **CRS**: Used to transform coordinates between systems.
-   **PROJ**: Core library for CRS transformations; integrated into R-spatial packages and QGIS.
-   **Ways to Describe CRSs**:
    1.  Simple statements: E.g., "lon/lat coordinates" (ambiguous).
    2.  Proj4 strings: E.g., `+proj=longlat +datum=WGS84` (outdated).
    3.  Authority:Code strings: E.g., `EPSG:4326` (recommended).
-   **Preferred Method**: Authority:Code, e.g., **EPSG:4326**:
    -   Understood by `sf`, `terra`, and other tools.
    -   Easy to remember and search online (e.g., [epsg.io](https://epsg.io/4326)).
    -   Machine-readable and unambiguous.
-   **Detailed CRS Representation**: WKT (Well-Known Text):
    -   Comprehensive format for CRS description (based on ISO 19111:2019).
    -   Used for precision and includes all CRS details (datum, ellipsoid, units, etc.).
    -   Example: `st_crs("EPSG:4326")` outputs full WKT string.
-   **Authority Identifiers**:
    -   **EPSG**: Most common authority; standardized CRSs list.
    -   Other authorities: E.g., `ESRI:54030` (Robinson projection).
    -   Identifiers are linked to detailed WKT strings for unambiguous use.
-   WKT vs Identifiers: **WKT Precedence**: In case of conflict, WKT values override identifiers.

::: callout-note
From the [INBO blog](https://inbo.github.io/tutorials/tutorials/spatial_crs_coding/) tutorial "***Goodbye PROJ.4! How to specify a coordinate reference system in R?***"

-   **Understanding CRS**:
    -   A CRS interprets numeric coordinates as actual point locations on Earth.
    -   Two main types:
        -   *Geodetic CRSs*: Locate coordinates relative to a 3D model of Earth's surface.
        -   *Projected CRSs*: Convert geodetic coordinates to a 2D map.
-   **Components of a CRS**:
    -   Coordinate system.
    -   Datum: Defines the position relative to Earth, including the ellipsoid.
    -   For projected CRSs: Parameters for converting geodetic to projected coordinates.
-   **CRS Identification**: CRSs are cataloged globally, notably in the EPSG dataset, with each assigned a unique EPSG code.
-   **Best Practices**:
    -   Adopt WKT representations for CRS definitions to ensure compatibility and future-proofing.
    -   Familiarize with the EPSG dataset for accurate CRS identification.
    -   Utilize R's `sf` package for handling spatial data and CRS specifications.
:::

```{r}
#| eval: true

st_crs("EPSG:4326")$WktPretty |> str_view()

st_crs("ESRI:102004")$WktPretty |> str_view()
```

### 7.3 Querying and Setting Coordinate Systems

-   **CRS in R spatial objects:** Coordinate Reference Systems (CRS) are queried and set in vector and raster geographic data using functions from the `sf` [@sf] and `terra` [@terra-2] packages.

-   **Vector data CRS handling:**

    -   Use [`st_crs()`](https://r-spatial.github.io/sf/reference/st_crs.html) to query CRS in vector objects (e.g., EPSG:4326 for WGS 84).
    -   CRS metadata includes `User input` (e.g., EPSG code, proj-string) and `wkt` (WKT string with complete CRS details).

-   Additional CRS details can be retrieved: The `st_crs()` function from the **sf** package in R provides detailed information about the Coordinate Reference System (CRS) of spatial objects.

+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| Attribute         | Description                                                                                    | Example Usage                      |
+===================+================================================================================================+====================================+
| **IsGeographic**  | Indicates if the CRS is geographic (TRUE) or projected (FALSE).                                | `st_crs(new_vector)$IsGeographic`  |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **units_gdal**    | Specifies the units of measurement used in the CRS, as recognized by GDAL.                     | `st_crs(new_vector)$units_gdal`    |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **srid**          | Provides the Spatial Reference System Identifier (SRID) associated with the CRS, if available. | `st_crs(new_vector)$srid`          |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **proj4string**   | Returns the PROJ.4 string representation of the CRS, offering a concise textual description.   | `st_crs(new_vector)$proj4string`   |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **WktPretty**     | Provides a formatted Well-Known Text (WKT) representation of the CRS for easier readability.   | `st_crs(new_vector)$WktPretty`     |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **InvFlattening** | Provides the inverse flattening value of the ellipsoid, indicating its compression.            | `st_crs(new_vector)$InvFlattening` |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **Name**          | Retrieves the official name of the CRS.                                                        | `st_crs(new_vector)$Name`          |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **epsg**          | Returns the EPSG code associated with the CRS, if available.                                   | `st_crs(new_vector)$epsg`          |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **yx**            | Indicates whether the axis order is latitude-longitude (TRUE) or longitude-latitude (FALSE).   | `st_crs(new_vector)$yx`            |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **ud_unit**       | Returns the units object associated with the CRS, or NULL if units are missing.                | `st_crs(new_vector)$ud_unit`       |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+
| **axes**          | Provides information about the axes of the CRS, including their names and units.               | `st_crs(new_vector)$axes`          |
+-------------------+------------------------------------------------------------------------------------------------+------------------------------------+

```{r}
#| eval: true
#| collapse: true

# The WGS 84 / EPSG 4326 projection (default projection in {rnaturalearth})
st_crs("EPSG:4326")$units_gdal
st_crs("EPSG:4326")$IsGeographic
st_crs("EPSG:4326")$proj4string
st_crs("EPSG:4326")$axes

# The EPSG:3857 Web Mercator Projection (used for maps and distances)
st_crs("EPSG:3857")$units_gdal
st_crs("EPSG:3857")$IsGeographic
st_crs("EPSG:3857")$proj4string
st_crs("EPSG:3857")$axes

# Robinson Projection ESRI:54030 
st_crs("ESRI:54030")$units_gdal
st_crs("ESRI:54030")$IsGeographic
st_crs("ESRI:54030")$proj4string
st_crs("ESRI:54030")$axes
```

-   **Use [`st_set_crs()`](https://r-spatial.github.io/sf/reference/st_set_crs.html) to manually set or correct a CRS.** Both `st_set_crs()` and the assignment method `st_crs(object) <- value` are used to define or modify the Coordinate Reference System (CRS) of spatial objects.

    -   `st_set_crs()` is a function call, which can be advantageous when using pipes (`|>`) in a workflow.

    -   Both methods assign CRS metadata to the spatial object without altering the actual coordinate values or geometries.

    -   To transform the coordinates to a different CRS, the `st_transform()` function should be used.

    -   Assigning a CRS is akin to labeling data with its existing coordinate system, whereas transforming reprojects the data into a new coordinate system.

```{r}

g1 <- greenland |> 
  st_set_crs("EPSG:4326") |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "EPSG:4326",
    subtitle = "The default CRS: a geographic CRS"
  )

g2 <- greenland |> 
  st_transform("EPSG:3857") |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "st_transform(`EPSG:3857`)",
    subtitle = "Correct usage; EPSG:3857 CRS: a projected CRS"
  )

g3 <- greenland |> 
  st_set_crs("EPSG:3857") |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "st_set_crs(`EPSG:3857`)",
    subtitle = "Wrong usage; distorts and assigns CRS values"
  )

g <- g1 + g2 + g3 +
  plot_layout(nrow = 1) +
  plot_annotation(
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")"
    ) &
  theme(
    plot.tag = element_text(
      size = 40,
      face = "bold"
    ),
    plot.margin = margin(0,7,0,7, "mm")
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-3_1.png"),
  height = 600,
  width = 2400,
  unit = "px"
)
```

![Explaining the difference between the st_set_crs() and st_transform(). The figures show (a) The default map of Greenland as obtained from {rnaturalearth} with the CRS WGS84 (i.e. EPSG:4326). (b) The transformation using `st_transform()` which produces correct transformation. (c) The incorrect method using `st_set_crs()` which simply retains all data, but assumes them to be in the new assigned CRS. This leads to wrong latitude and longitude numbers. Thus, the only use of `st_set_crs()` is for assigning a CRS to a raw data, which we know for sure from outside sources.](images/chapter7-3_1.png)

-   **Validate CRS with `st_is_longlat()`.**

    -   The function **`st_is_longlat()`** in the **sf** package is used to check whether the Coordinate Reference System (CRS) of a spatial object is based on a geographic coordinate system (latitude and longitude). It's Return Value can be: —

        -   TRUE: The object has a geographic CRS (e.g., EPSG:4326).

        -   FALSE: The object has a projected CRS.

        -   NA: The CRS is undefined (e.g., no metadata about the coordinate system is set).

-   **Raster data CRS handling:**

    -   Use `crs()` from the {terra} package to query and set CRS for raster objects.
    -   Outputs CRS as a WKT string.
    -   Set CRS with EPSG codes, WKT strings, or CRSs from other objects (e.g., `crs(my_raster) = "EPSG:26912"`).

-   **Important considerations:**

    -   `st_crs()` and `crs()` only set metadata; they do not modify coordinate values or geometries.
    -   Missing CRS in datasets (e.g., `NA` output in `st_is_longlat()`) indicates that CRS must be explicitly defined (e.g., using `st_set_crs()`).

-   CRS assumptions: R avoids assumptions about CRS (e.g., unlike GeoJSON which defaults to `EPSG:4326`).

### 7.4 Geometry Operations on Projected and Unprojected Data

-   The `sf` package integrates with:

    -   The [S2 spherical geometry engine](https://cran.r-project.org/web/packages/s2/) for **geographic CRS data** with longitude/latitude (lon/lat) CRSs.
    -   [GEOS](https://libgeos.org/) is used for **projected CRS or CRS-absent data**.
    -   **Default Behavior**: S2 is enabled by default for geographic data but can be disabled using [`sf::sf_use_s2(FALSE)`](https://r-spatial.github.io/sf/reference/sf_use_s2.html).

-   **CRS Importance in Buffers**: Buffers created on unprojected data (e.g., lon/lat) can result in distorted outputs (for example A.1 in @fig-7-4) unless spherical geometry (S2) is used. Better still, always use a projected CRS for accurate distance / buffers calculation (as C.1 in @fig-7-4).

-   Key Learnings:

    1.  **Incorrect buffer creation:** Buffers on geographic data (Long / Lat data) without a specified CRS (thus, using GEOS) result in outputs in degrees (as A.1 & A.3 in @fig-7-4). *Note: Lon/lat buffers without S2 or projection may appear elongated (e.g., along the north-south axis).*

    2.  **Correct buffer creation:** S2 buffers (with Geographic CRS, i.e. Long / Lat data) calculate accurate distances (as B.1 in @fig-7-4) but may create jagged boundaries (as B.3 in @fig-7-4) (this can be tuned with `max_cells` or `nQuadSegs`).

    3.  **Ideal buffer creation:** Use projected CRSs (as in C.1, C.2 & C.3 in @fig-7-4)) like British National Grid (`EPSG:27700`) for consistent distance-based operations, for example, in metres (m).

::: callout-note
*Note: S2 buffers improve results but remain less precise than using projected CRSs and GEOS.*
:::

-   **Visual Outcomes**:

    -   Buffers based on S2 and projected CRSs produce more accurate, equidistant boundaries compared to lon/lat inputs without S2.
    -   S2-derived buffers differ from projected GEOS buffers, and resolution depends on `max_cells` (default: 1000). (as B.3 in @fig-7-4)

-   **Best Practices**:

    -   Use `sf::st_crs()` to check the CRS and **verify units (e.g., degrees vs. meters) of the CRS**. Reproject data to a projected CRS using suitable EPSG codes for precise geometric operations.
    -   For distance-based operations like buffering, reproject data to a projected CRS.
    -   Adjust `max_cells` in S2 for performance versus resolution trade-offs. (as B.1 in @fig-7-4)

#### @fig-7-4 shows an example (buffer zone around London)

```{r}

overall_title <- "When and How to Use S2 and GEOS Engines for Spatial Operations"
overall_subtitle <- "GEOS handles projected or CRS-absent data; S2 defaults for geographic data but is optional."


bts <- 16     # Base Text Size

theme_set(
  theme_minimal(
    base_family = "body_font",
    base_size = bts,
    base_line_size = 0.2
  ) +
    theme(
      text = element_text(
        colour = "grey20"
      ),
      plot.title = element_text(
        size = 1.9 * bts,
        margin = margin(0.2, 0.1, 0.1, 0.1, "lines")
      ),
      plot.subtitle = element_text(
        size = 1.3 * bts,
        margin = margin(0.1, 0.1, 0.1, 0.1, "lines")
      ),
      plot.margin = margin(0,0,0,0, "mm"),
      axis.text = element_text(
        size = bts * 0.5
      ),
      axis.ticks.length = unit(0, "mm"),
      panel.background = element_rect(
        fill = "#caf0f8",
        colour = "#caf0f8"
      ),
      panel.grid = element_line(
        linewidth = 0.2,
        colour = "white",
        linetype = 3
      )
    )
)

# Create a London data point - the coordiantes in Latitude
# and Longitude of London, UK
london_sans_crs <- data.frame(lon = -0.1, lat = 51.5) |> 
  st_as_sf(coords = c("lon", "lat"))

# Adding the CRS to London data point: values stay same
london_with_crs <- london_sans_crs |> 
  st_set_crs("EPSG:4326")

# British National Grid
# st_crs("EPSG:27700")

# Using the British National Grid CRS: values get changed
london_british_crs <- london_sans_crs |> 
  st_set_crs("EPSG:4326") |> 
  st_transform("EPSG:27700")


# Create an approximate bounding box around 200 km around London
bbox_near_london <- london_sans_crs |> 
  st_set_crs("EPSG:4326") |> 
  st_buffer(dist = 200000) |> 
  st_bbox()

# Crop and keep coastline map around London
outline_map <- rnaturalearth::ne_countries(
  continent = "Europe",
  returnclass = "sf",
  scale = "large"
  ) |> 
  st_union() |> 
  st_as_sf() |> 
  st_crop(bbox_near_london)


base_plot <- ggplot() +
  geom_sf(
    data = outline_map,
    linewidth = 0.1,
    fill = alpha("white", 1)
  ) +
  geom_sf(
    data = london_with_crs,
    size = 3,
    colour = "#fb8500"
  ) +
  coord_sf(expand = FALSE)

# Without any CRS -------------------------------------------------

row_1_title <- "London Data, without any CRS"
row_1_subtitle <- "Data in Long / Lat, but without a specified CRS, leads {sf} to use GEOS engine, as in (a) and (c)"

g1 <- base_plot +
  geom_sf(
    data = st_buffer(london_sans_crs, 
                     dist = 1) |> 
            st_set_crs("EPSG:4326"),
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Using GEOS on Long/Lat data",
    subtitle = "st_buffer(london_sans_crs, dist = 1)"
  )

g2 <- base_plot +
  geom_sf(
    data = london_sans_crs |> 
            st_set_crs("EPSG:4326") |> 
            st_buffer(dist = 1),
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Using S2 but wrong Buffer units",
    subtitle = "london_sans_crs |> st_set_crs(`EPSG:4326`) |> st_buffer(dist = 1)"
  )

g3 <- base_plot +
  geom_sf(
    data = st_buffer(london_sans_crs, 
                     dist = 1,
                     nQuadSegs = 2) |> 
            st_set_crs("EPSG:4326"),
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Using GEOS with nQuadSegs",
    subtitle = "st_buffer(london_sans_crs, dist = 1, nQuadSegs = 3)"
  )


row_2_title <- "London with a Geographic CRS `EPSG:4326`"
row_2_subtitle <- "Data in Long/Lat, but with CRS speficied, leads {sf}to use S2 (spherical geometry). Distance is in metres, now."

sf_use_s2(TRUE)
g4 <- base_plot +
  geom_sf(
    data = st_buffer(london_with_crs, 
                     dist = 1e5,
                     max_cells = 300),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Correct: Buffer of 100 km using S2",
    subtitle = "Using S2 engine (spherical geometry); Notice jagged buffer line."
  )

sf_use_s2(FALSE)
g5 <- base_plot +
  geom_sf(
    data = st_buffer(london_with_crs, 
                     dist = 1,
                     max_cells = 500),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Buffer of 1 degree with GEOS",
    subtitle = "sf_use_s2(FALSE):  Using GEOS engine on geographic CRS."
  )

sf_use_s2(TRUE)
g6 <- base_plot +
  geom_sf(
    data = st_buffer(london_with_crs, 
                     dist = 1e5,
                     max_cells = 100),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Correct: Buffer of 100 km using S2",
    subtitle = "Reducing max_cells = 100 to save computation time."
  )

row_3_title <- "With a Projected CRS: British Grid (EPSG:27700)"
row_3_subtitle <- "Using London data in Projected CRS results in ideal outputs. Accurate results with GEOS engine."

g7 <- base_plot +
  geom_sf(
    data = st_buffer(london_british_crs, 
                     dist = 1e5),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Ideal: 100 km Buffer on projected CRS",
    subtitle = "london_british_crs |> st_buffer(dist = 1e5)"
  )

g8 <- base_plot +
  geom_sf(
    data = st_buffer(london_british_crs, 
                     dist = 1e5,
                     nQuadSegs = 1),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Distance in 4 directions only",
    subtitle = "nQuadSegs = 1  (Number of segments per quadrant)."
  )

g9 <- base_plot +
  geom_sf(
    data = st_buffer(london_british_crs, 
                     dist = 1e5,
                     nQuadSegs = 2),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Save Computation Time: 100 km Buffer",
    subtitle = "nQuadSegs = 2  (Number of segments per quadrant)."
  )

# A custom theme for each Row headings
theme_row <- function(...){
  theme(
    plot.title = element_text(
        margin = margin(5,0,1,0, "mm"),
        size = bts * 3.5,
        hjust = 0.5,
        face = "bold"
      ),
      plot.subtitle = element_text(
        margin = margin(0,0,1,0, "mm"),
        size = bts * 2.5,
        hjust = 0.5,
        face = "bold"
      ),
    ...
  )
}

theme_tag <- function(...){
  theme(
    plot.tag = element_text(
      margin = margin(0,0,0,0, "mm"),
      hjust = 0.5,
      face = "bold",
      size = bts * 1.5
    ),
    plot.tag.position = "top"
  )
}

# Compiling Plots for London data without CRS
ga <- g1 + g2 + g3 +
  plot_annotation(
    title = row_1_title,
    subtitle = row_1_subtitle,
    theme = theme_row(),
    tag_levels = "1",
    tag_prefix = "A."
  ) &
  theme_tag()

# Save the 3 plots for 1st Row
ggsave(
  plot = ga,
  filename = here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-1.png"),
  height = 1050,
  width = 2400,
  unit = "px",
  bg = "white"
)

# Compiling Plots for London data with a Geographic CRS
gb <-  g4 + g5 + g6 +
  plot_annotation(
    title = row_2_title,
    subtitle = row_2_subtitle,
    theme = theme_row(),
    tag_levels = "1",
    tag_prefix = "B."
  ) &
  theme_tag()


# Save the 3 plots for 2nd Row
ggsave(
  plot = gb,
  filename = here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-2.png"),
  height = 1050,
  width = 2400,
  unit = "px",
  bg = "white"
)


# Compiling Plots for Projected (British Grid) CRS

gc <-  g7 + g8 + g9 +
  plot_layout(
    tag_level = "new"
  ) +
  plot_annotation(
    title = row_3_title,
    subtitle = row_3_subtitle,
    theme = theme_row(),
    tag_levels = "1",
    tag_prefix = "C."
  ) &
  theme_tag()


# Save the 3 plots for 3rd Row
ggsave(
  plot = gc,
  filename = here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-3.png"),
  height = 1050,
  width = 2400,
  unit = "px",
  bg = "white"
)

# Compile the images
library(magick)
ga <- image_read(here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-1.png"))
gb <- image_read(here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-2.png"))
gc <- image_read(here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-3.png"))

image_append(c(ga, gb, gc), stack = TRUE) |> 
  image_write(path = here::here("book_solutions", 
                        "images", 
                        "chapter7-4.png"))

# Clean up the temporary files
unlink(here::here("book_solutions","images",
                  "temp_chapter7-4-1.png"))
unlink(here::here("book_solutions","images",
                  "temp_chapter7-4-2.png"))
unlink(here::here("book_solutions","images",
                  "temp_chapter7-4-3.png"))
```

![The different kinds of buffering - incorrect, correct and ideal using {sf} in R relying on two engines - Google's S2 spherical geometry, or GEOS engine.](images/chapter7-4.png){#fig-7-4}

::: callout-note
This code below calculates the distances between lines of longitude (meridians) and latitude at different geographic points to demonstrate the distortion inherent in geographic coordinate systems (lon/lat CRSs).

```{r}
#| eval: true
#| code-fold: false
#| collapse: true

# Load the required package
library(geosphere)

# 1. Distance between two meridians (longitude lines) at the equator (0° latitude)
# From (0°E, 0°N) to (1°E, 0°N)
distance_meridian_equator <- distGeo(c(0, 0), c(1, 0)) 
cat("Distance between meridians at the equator:", round(distance_meridian_equator/1000, 2), "km\n")


# 2. Distance between two meridians at the latitude of London (51.5°N)
# From (0°E, 51.5°N) to (1°E, 51.5°N)
distance_meridian_london <- distGeo(c(0, 51.5), c(1, 51.5)) 
cat("Distance between meridians at London's latitude:", round(distance_meridian_london/1e3, 2), "km\n")


# 3. Distance between two parallels (latitude lines) at any latitude
# From (0°E, 0°N) to (0°E, 1°N)
distance_latitude <- distGeo(c(0, 0), c(0, 1)) 
cat("Distance between latitudes:", round(distance_latitude/1e3, 2), "meters\n")

```

Thus, the distance between meridians varies with latitude, shrinking from approximately 111 km at the equator to zero at the poles, while lines of latitude remain equidistant.
:::

### 7.5 When to Reproject?

-   CRS Assignment: In practical daily work, CRSs are typically set automatically when data is read; hoever, if required, manual setting can be done using [`st_set_crs()`](https://r-spatial.github.io/sf/reference/st_set_crs.html).
-   The main task, in daily work, involves transforming objects between CRSs to enable specific tasks. Transformation Necessity:
    -   **Tranformation into a Geographic CRS**
        -   Essential when publishing online with packages like [`leaflet`](https://rstudio.github.io/leaflet/). [@leaflet]
        -   For projects with web mapping, we need to use `EPSG:4326` (a geographic CRS).
        -   For projects needing Spherical Geometry operations, use Geographic CRS.
    -   **Tranformation into another Projected CRS**
        -   Projects needing planar geometry operations, like creating buffer zones with smooth edges.
        -   Required when comparing or combining objects with different CRSs (e.g., using [`st_distance()`](https://r-spatial.github.io/sf/reference/st_distance.html)).
-   **CRS Selection**: Geographic CRS is best for global and spherical geometry operations. Projected CRS is ideal for local/regional planar geometry operations and analyses requiring precise distance and area calculations. Here’s a simple table summarizing when to use geographic versus projected CRSs:

+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| **Scenario**                               | **Use Geographic CRS**                                                                                     | **Use Projected CRS**                                                      |
+============================================+============================================================================================================+============================================================================+
| Global Mapping                             | Required for **displaying data on web maps (e.g., with [`leaflet`](https://rstudio.github.io/leaflet/)).** | Not recommended due to distortions at global scales.                       |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Great Circle Distances                     | **Use** **for accurate calculation of shortest paths on the Earth's surface.**                             | Distances may be inaccurate due to planar projections.                     |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Angular Bearings                           | **Essential for computing directions or angles between points.**                                           | Distortions in angles make it unsuitable for such tasks.                   |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Radius-based Proximity Queries (Spherical) | **Use for radius-based queries or geofencing on a global scale.**                                          | Results can be distorted for large distances.                              |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Local Area Analysis                        | Not typically recommended unless working with global-scale spherical models.                               | **Ideal for small-to-medium-scale analyses with minimal distortions.**     |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Buffer Creation                            | Not recommended for smooth edges.                                                                          | **Best for creating accurate and smooth planar buffers.**                  |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Overlay and Intersection Operations        | Limited to angular-based operations (e.g., great circle intersections).                                    | **Preferred for planar intersections and overlays for precise alignment.** |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Planar Geometry Operations                 | Not ideal for creating planar geometries like buffers or centroids.                                        | **Essential for tasks like buffering and centroids in local projections.** |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+
| Area and Length Calculation                | Use for global-scale spherical areas (with corrections).                                                   | Use for precise calculations in local or regional contexts.                |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------+

### 7.6 Which CRS to use?

-   No single 'best' CRS: All projections involve distortions; the choice depends on the task.
-   Switch CRSs for different tasks: Use a CRS that aligns with your analysis or visualization goals.
-   **Geographic CRS: most commonly, use WGS84 (EPSG:4326):**
    -   Common for web mapping, GPS datasets, and most vector - raster datasets.
    -   EPSG code: 4326 (useful for converting to a universal CRS).
-   **Projected CRS: Often dictated by local mapping agencies.**
    -   To ensure compatibility: Preferable to work in CRS (in which the data was provided)
    -   **UTM (Universal Transverse Mercator)**: a set of Projected CRSs

::: callout-note
The Universal Transverse Mercator (UTM) set of projections

+-----------------+------------------------------------------------------------------------------------------+
| **Feature**     | **Description**                                                                          |
+=================+==========================================================================================+
| Projection Name | Universal Transverse Mercator (UTM)                                                      |
+-----------------+------------------------------------------------------------------------------------------+
| Structure       | Divides the Earth into 60 longitudinal zones (6° wide each) and 20 latitudinal segments. |
+-----------------+------------------------------------------------------------------------------------------+
| CRS Type        | Projected CRS. Uses the Transverse Mercator projection for each zone.                    |
+-----------------+------------------------------------------------------------------------------------------+
| EPSG Codes      | **Northern Hemisphere**: 32601 to 32660.                                                 |
|                 |                                                                                          |
|                 | **Southern Hemisphere**: 32701 to 32760.                                                 |
+-----------------+------------------------------------------------------------------------------------------+
| Zone Numbering  | Zones numbered 1 to 60 (**longitude**).                                                  |
|                 |                                                                                          |
|                 | **Latitude** segments labeled A to V (excluding I and O).                                |
+-----------------+------------------------------------------------------------------------------------------+
| Example Zones   | Zone 60H: Northern New Zealand, EPSG: 32760.                                             |
|                 |                                                                                          |
|                 | Zone 30N: Covers London, EPSG: 32630.                                                    |
+-----------------+------------------------------------------------------------------------------------------+
| Key Features    | **Conformal projection**: Preserves angles and shapes locally.                           |
|                 |                                                                                          |
|                 | Suitable for small areas.                                                                |
+-----------------+------------------------------------------------------------------------------------------+
| Distortion      | Increases with distance from the zone's central meridian.                                |
+-----------------+------------------------------------------------------------------------------------------+
| Use Cases       | Small-scale mapping, local surveys, engineering, and construction projects.              |
+-----------------+------------------------------------------------------------------------------------------+
| Limitations     | Not suitable for regions spanning multiple zones.                                        |
+-----------------+------------------------------------------------------------------------------------------+

A mpa of the World with UTM projection Zones: —

```{r}
#| code-fold: false
#| eval: false 
lonlat2UTM = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if (lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}
```
:::

```{r}
# A code to plot UTM zones over the World Map in R

world_map <- rnaturalearth::ne_countries(
  scale = "small",
  returnclass = "sf"
) |> 
  select(name, geometry)

# Create a tibble for the UTM Zone breaks
utm_long_breaks <- tibble(
  Longitude_Start = seq(-180, 174, by = 6),
  Longitude_End = seq(-174, 180, by = 6),
  Zone_Number = seq(1, 60)
) |> 
  janitor::clean_names() |>
  mutate(
    mid_point_long = (longitude_start + longitude_end)/2
  )

utm_lat_breaks <- tibble(
  Latitude_Start = c(seq(-80, 72, by = 8)),
  Latitude_End = c(seq(-72, 72, by = 8), 84),
  Zone_Letter = LETTERS[!(LETTERS %in% c("A", "B", "I", "O", "Y", "Z"))]
) |> 
  janitor::clean_names() |>
  mutate(
    mid_point_lat = (latitude_start + latitude_end)/2
  )

bts = 24 # Base Text Size

g <- ggplot() +
  geom_hline(
    data = utm_lat_breaks,
    mapping = aes(
      yintercept = latitude_start
    ),
    linewidth = 0.2,
    linetype = 1,
    colour = "grey40",
    alpha = 0.3
  ) +
  geom_vline(
    data = utm_long_breaks,
    mapping = aes(
      xintercept = longitude_start
    ),
    linewidth = 0.2,
    linetype = 1,
    colour = "grey40",
    alpha = 0.3
  ) +

  # Longitude Labels
  geom_text(
    data = utm_long_breaks,
    mapping = aes(
      label = zone_number,
      y = 90,
      x = mid_point_long
    ),
    family = "body_font",
    size = bts / 2,
    colour = "grey20"
  ) +
  
  # Latitude Labels
  geom_text(
    data = utm_lat_breaks,
    mapping = aes(
      label = zone_letter,
      x = 184,
      y = mid_point_lat
    ),
    family = "body_font",
    size = bts,
    colour = "grey20"
  ) +
  geom_sf(
    data = world_map,
    alpha = 0.5,
    colour = alpha("#A8554EFF", 0.8),
    fill = alpha("#A8554EFF", 0.4)
  ) +
  scale_x_continuous(
    breaks = unique(utm_long_breaks$longitude_start,
                    utm_long_breaks$longitude_end)
  ) +
  labs(
    x = "Longitudanal Zones",
    y = "Latitudanal Segments",
    title = "UTM Projection Zones"
  ) +
  theme_minimal(
    base_family = "body_font",
    base_size = bts
  ) +
  theme(
    plot.title = element_text(
      size = bts * 8, 
      margin = margin(0,0,0,0, "mm"),
      hjust = 0.5,
      colour = "grey30"
    ),
    panel.background = element_rect(
      fill = "#FEF7C7FF",
      colour = "transparent"
    ),
    panel.grid = element_blank(),
    
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-6.png"),
  height = 240,
  width = 400,
  unit = "mm",
  bg = "white"
)
```

-   **Selecting CRSs with tools**:
    -   Use `crsuggest::suggest_crs()` [@crsuggest] for recommended CRSs based on spatial objects.
    -   Explore [CRS Explorer](https://crs-explorer.proj.org/) by [Javier Jimenez Shaw](https://javier.jimenezshaw.com/) for location-specific CRSs.
-   Projection Recommendations Table

+-----------------------------------------+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------+
| **Name of Projection Type**             | **When to Use**                                                                         | **When Not to Use**                                                   |
+=========================================+=========================================================================================+=======================================================================+
| **Lambert Azimuthal Equal-Area (LAEA)** | \- For custom local projections.\                                                       | \- When preserving shape or distance is critical.                     |
|                                         | - When preserving area is crucial, e.g., for statistical mapping.                       |                                                                       |
|                                         |                                                                                         | \- For areas extending thousands of kilometers.                       |
+-----------------------------------------+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------+
| **Azimuthal Equidistant (AEQD)**        | \- For accurate straight-line distances from a central point.\                          | \- For large-scale mapping beyond the immediate region of the center. |
|                                         | - Mapping distances for circular or radial features.                                    |                                                                       |
|                                         |                                                                                         | \- When shape or area preservation matters.                           |
+-----------------------------------------+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------+
| **Lambert Conformal Conic (LCC)**       | \- For regions spanning thousands of kilometers (e.g., continents or large countries).\ | \- For small-scale maps.                                              |
|                                         | - When preserving shape is important.                                                   |                                                                       |
|                                         |                                                                                         | \- When precise area calculations are required.                       |
+-----------------------------------------+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------+
| **Stereographic (STERE)**               | \- For polar regions.                                                                   | \- For large-scale maps extending thousands of kilometers.            |
|                                         |                                                                                         |                                                                       |
|                                         | \- When preserving shape for relatively small polar areas.                              | \- For accurate area or distance calculations.                        |
+-----------------------------------------+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------+

-   **Custom CRSs**:
    -   Suitable for local datasets, using center points for AEQD.
    -   Caution: Not compatible with other datasets; may lose accuracy for large areas.
-   Advanced options: Use [geodesic calculations](https://proj.org/geodesic.html) for fallback if no CRS fits.

### 7.7 Reprojecting Vector Geometries

-   **Reprojection**: Transforming the coordinates of vector geometries (points, lines, polygons). Example: Converting CRS of an object for accurate distance measurement.
-   Key Functionality in `sf` Package: Use [`st_transform()`](https://r-spatial.github.io/sf/reference/st_transform.html) to transform CRS.
-   **Querying and Setting CRS**:
    -   Retrieve CRS of `sf` objects using [`st_crs()`](https://r-spatial.github.io/sf/reference/st_crs.html).
    -   Output contains components like `User input` and `wkt`.
    -   CRS objects are lists containing elements like `Name`, `proj4string`, `epsg`, and `$wkt`, as shown in table in Section 7.3 above.
    -   `$wkt` serves as the ultimate source of CRS details, queried via PROJ.

::: callout-note
OGR Coordinate Reference Systems and Coordinate Transformation [tutorial](https://gdal.org/en/stable/tutorials/osr_api_tut.html) provides insights into handling coordinate reference systems (CRS) and performing transformations using GDAL's OGR library. Here's how key concepts from the tutorial translate to `{sf}` in R:

-   Defining a Geographic CRS:
    -   In `{sf}`, you can assign a CRS to an `sf` object using the `st_set_crs()` function.
-   Querying CRS Information:
    -   In `{sf}`, you can retrieve CRS information using the `st_crs()` function:
-   Transforming Coordinates Between CRSs:
    -   In `{sf}`, the `st_transform()` function is used to transform geometries to a different CRS. For example, to transform to EPSG:27700:
-   Handling Axis Order:
    -   In `{sf}`, you can control axis order interpretation using the `st_axis_order()` function. To set it to traditional GIS order (longitude, latitude):

        ``` r
        st_axis_order(FALSE)
        ```
:::

### 7.8 Reprojecting Raster Geometries

-   **Raster Reprojection**: Creates a new raster with potentially different dimensions. Involves two steps:

    1.  Extent Transformation: Adjusts raster extent (like vector reprojection).

    2.  Pixel Resampling: Re-estimates pixel values.

    -   Recommendation: Prefer vector reprojection over raster reprojection when both data types are used.

-   **Key Difference from vector re-projection:** Raster reprojection creates a new raster with modified attributes (e.g., columns, rows) rather than altering individual pixel coordinates like vectors.

-   **Two Processes of raster reprojection:**

    -   Transformation: Adjusts grid geometry without changing pixel values, performed with the [stars](https://cran.r-project.org/package=stars) package. Also called Extent Transformation: Similar to vector reprojection, adjusts raster extent. Can be done using {stars} package. [@stars]
    -   Warping: Reprojects raster using methods like `project()` from the [terra](https://cran.r-project.org/package=terra) package. Also called Pixel Resampling: Computes new pixel values using methods like nearest neighbor or bilinear re-sampling. Can be done with `terra::project()` from {terra} [@terra-3]

-   Categorical Raster: Method used is `nearest neighbor` which ensures categorical values remain unchanged during reprojection. Result: Changes in resolution, extent, and added NA values (not new categories). Example is shown in @fig-8-1 .

```{r}
cat_raster <- rast(system.file("raster/nlcd.tif", package = "spDataLarge"))

cat_raster1 <- cat_raster |> project("EPSG:4326", method = "near")
# crs(cat_raster) |> 
#   str_view()

# PROJCRS["NAD83 / UTM zone 12N",

g1 <- ggplot() +
  geom_spatraster(
    data = cat_raster
  ) +
  labs(
    title = "Original Categorical Raster",
    subtitle = "CRS: NAD83 / UTM zone 12N",
    fill = "Land Cover Type"
  )

g2 <- ggplot() +
  geom_spatraster(
    data = cat_raster1
  ) +
  labs(
    title = "Transformed Raster",
    subtitle = "CRS: WGS 84  (EPSG:4326)",
    fill = "Land Cover Type"
  )


g <- g1 + g2 +
  plot_layout(
    nrow = 1,
    guides = "collect"
  ) +
  plot_annotation(
    caption = "Land Cover for a small area in Utah, USA; National Land Cover Database 2011",
    theme = theme(
      plot.caption = element_text(
        hjust = 0
      )
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-8.png"),
  height = 800,
  width = 1200,
  unit = "px",
  bg = "white"
)
```

![**Warping or Re-sampling** categorical rasters (akin to reprojection) using `terra::project()` which uses near method - estimates re-sampled raster values using the value from the nearest original cell.](images/chapter7-8.png){#fig-8-1}

-   Continuous Raster: Method used is `bilinear`, computes pixel values as weighted averages of neighboring cells. Result: Modifications to mean values, resolution, and extent. Example is shown in @fig-8-2 .

```{r}
srtm <- rast(system.file("raster/srtm.tif", 
                              package = "spDataLarge"))

srtm1 <- srtm |> project("EPSG:32612", method = "bilinear")

g1 <- ggplot() +
  geom_spatraster(
    data = srtm
  ) +
  scale_fill_wiki_c() +
  labs(
    title = "Original Elevation Raster",
    subtitle = "Geographic CRS: WGS 84 (EPSG:4326)",
    fill = "Elevation (metres)"
  )

g2 <- ggplot() +
  geom_spatraster(
    data = srtm1
  ) +
  scale_fill_wiki_c() +
  labs(
    title = "Transformed Continuous Values Raster",
    subtitle = "Projected CRS: UTM zone 12N (EPSG:32612)",
    fill = "Elevation (metres)"
  )


g <- g1 + g2 +
  plot_layout(
    nrow = 1,
    guides = "collect"
  ) +
  plot_annotation(
    caption = "Elevation, above sea level in metres, from the Shuttle Radar Topography Mission (SRTM)",
    theme = theme(
      plot.caption = element_text(
        hjust = 0
      )
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-8_1.png"),
  height = 800,
  width = 1200,
  unit = "px",
  bg = "white"
)
```

![**Warping or Re-sampling** a continuous value raster (akin to reprojection) using `terra::project()` which uses bilinear method - estimates re-sampled raster values using distance weighted mean from nearest 4 cells.](images/chapter7-8_1.png){#fig-8-2}

-   Projection Selection: Depends on the task. Use equal-area projections for density calculations, such as points per grid cell or inhabitants per grid cell.
-   Key Functions:
    -   `project()` ([terra](https://cran.r-project.org/package=terra)): Reprojects rasters.
    -   `st_transform()` ([sf](https://cran.r-project.org/package=sf)): Reprojects vector data.
-   A more apparent example is shown in @fig-8-3 for Greenland's elevation data from {geodata} [@geodata-2] using `terra::project()`

```{r}
greenland_raster <- geodata::elevation_30s(
  country = "GRL",
  path = tempdir()
  )

greenland_raster1 <- greenland_raster |> 
  terra::project(
    "EPSG:3413",
    method = "bilinear"
  )

g1 <- ggplot() +
  geom_spatraster(
    data = greenland_raster
  ) +
  scale_fill_wiki_c() +
  labs(
    title = "Original Elevation Raster",
    subtitle = "Geographic CRS: WGS 84 (EPSG:4326)",
    fill = "Elevation (metres)"
  )

g2 <- ggplot() +
  geom_spatraster(
    data = greenland_raster1
  ) +
  scale_fill_wiki_c() +
  labs(
    title = "Transformed Continuous Values Raster",
    subtitle = "Projected CRS: EPSG:3413 (North Pole Stereographic)",
    fill = "Elevation (metres)"
  )


g <- g1 + g2 +
  plot_layout(
    nrow = 1,
    guides = "collect"
  ) +
  plot_annotation(
    caption = "Elevation, above sea level in metres from {geodata}",
    theme = theme(
      plot.caption = element_text(
        hjust = 0
      )
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-8_2.png"),
  height = 700,
  width = 1400,
  unit = "px",
  bg = "white"
)
```

![Warping or Re-sampling elevation data for Greenland (obtained from {geodata} package) using `terra::project()` which uses bilinear method - estimates re-sampled raster values using distance weighted mean from nearest 4 cells.](images/chapter7-8_2.png){#fig-8-3}

### 7.9 Custom Map Projections

-   Established CRSs (e.g., `EPSG:4326`) are widely used but may not always fit specific needs; custom CRSs are an alternative.
-   **Custom CRS Creation**: Modify existing WKT CRS definitions, example shown in @fig-9_1, with:
    -   For vector objects: `sf::st_crs()` and `sf::st_transform()`
    -   For raster objects: `terra::crs()` and `terra::project()`

```{r}
# Example creating a custom azimuthal equidistant (AEQD) CRS projection focussed on Greenland

# Deduce the centre of Greenland
greenland |> 
  st_centroid() |> 
  st_geometry() |> 
  st_as_text()
# "POINT (-41.81367 73.08122)"

st_crs(greenland)

g1 <- greenland |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "WGS 84 (Geographic) CRS",
    subtitle = "Default Geographic CRS in the data"
  )

custom_crs <- ('PROJCS["Custom_AEQD",
 GEOGCS["GCS_WGS_1984",
  DATUM["WGS_1984",
   SPHEROID["WGS_1984",6378137.0,298.257223563]],
  PRIMEM["Greenwich",0.0],
  UNIT["Degree",0.0174532925199433]],
 PROJECTION["Azimuthal_Equidistant"],
 PARAMETER["Central_Meridian",-41.81367],
 PARAMETER["Latitude_Of_Origin",73.08122],
 UNIT["Meter",1.0]]')

g2 <- greenland |> 
  ggplot() +
  geom_sf() +
  geom_sf(data = st_centroid(greenland), size = 1.5) +
  coord_sf(crs = custom_crs) +
  labs(
    title = "Custom AEQD CRS",
    subtitle = "Focussed around the centroid of Greenland (black dot)"
  )

g <- g1 + g2 +
  plot_layout(
    nrow = 1
  ) +
  plot_annotation(
    title = "Creating a custom AEQD CRS for Greenland",
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = 30)
    )
  ) &
  theme(
    plot.title.position = "plot",
    plot.tag = element_text(
      size = 24, 
      face = "bold"
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-9_1.png"),
  height = 700,
  width = 1400,
  unit = "px",
  bg = "white"
)
```

![An example creating a custom azimuthal equidistant (AEQD) CRS projection focussed on Greenland](images/chapter7-9_1.png){#fig-9_1}

-   **Projection Wizard**:
    -   Interactive tool for selecting spatial extents and distortion properties ([Projection Wizard](https://projectionwizard.org/)).
    -   Generates WKT definitions for re-projections.

::: callout-note
**Key Learnings from the Projection Wizard [Website](https://projectionwizard.org/#)**

-   Interactive Custom Projections: Simplifies the creation of custom map projections based on user-defined extents and purposes.
-   User Guidance: Recommends optimal projections for specific geographic areas to minimize distortions.
-   Multiple Criteria: Supports area, distance, direction, or local shape preservation in projections.
-   Export Options: Provides projection strings (e.g., WKT, PROJ) for direct use in GIS and programming tools.
-   Educational Resource: Visualizes distortions to enhance understanding of projection impacts.
:::

-   **PROJ Strings**:
    -   Create projections with `+proj=` strings ([PROJ documentation](https://proj.org/)) as shown in an example in @fig-9_2
    -   Common projections for World Maps:
        -   **Mollweide** (`+proj=moll`): Preserves area relationships.
        -   **Winkel Tripel** (`+proj=wintri`): Minimizes distortion across spatial properties.
        -   **Lambert Azimuthal Equal-Area** (`+proj=laea`): Centered with `+lon_0` and `+lat_0` parameters. The parameters can be changed to suit the location you want to focus on, as shown in example below.

```{r}
# An example to plot the World map focussed around 4 major cities

# Getting the World Map
world_map <- rnaturalearth::ne_countries(scale = "small")

# Create a tibble of major cities with their latitude and longitude
major_cities <- tibble::tibble(
  city = c("New York", "London", "Tokyo", "Sydney"),
  latitude = c(40.7128, 51.5074, 35.6895, -33.8688),
  longitude = c(-74.0060, -0.1278, 139.6917, 151.2093)
)

cities_geometry <- major_cities |> 
  st_as_sf(coords = c("longitude", "latitude")) |> 
  st_set_crs(value = "EPSG:4326")


custom_plot <- function(city_name){
  # Select the city
  city_df <- major_cities |> filter(city == city_name)
  # Create custom LAEA projection focussed around the city coordinates
  new_crs = paste0("+proj=laea +x_0=0 +y_0=0 +lon_0=", 
                   city_df$longitude, " +lat_0=", 
                   city_df$latitude)
  ggplot() +
    geom_sf(data = world_map) +
    geom_sf(
      data = cities_geometry |> filter(city == city_name),
      size = 2, 
      colour = "red"
    ) +
    coord_sf(crs = new_crs) +
    labs(
      title = city_name,
      subtitle = paste0("Custom LAEA projection centered around ", city_name)
    ) +
    theme(
      axis.text = element_blank()
    )
}

g1 <- ggplot() +
    geom_sf(data = world_map) +
    labs(
      title = "World Map",
      subtitle = "Default Geographic CRS: WGS 84"
    )
g6 <- ggplot() +
    geom_sf(data = st_transform(world_map, crs = "ESRI:54009")) +
    labs(
      title = "World Map (ESRI:54009)",
      subtitle = "Mollweide Projection"
    )

g2 <- custom_plot("New York")
g3 <- custom_plot("London")
g4 <- custom_plot("Tokyo")
g5 <- custom_plot("Sydney")

my_design <- ("
AAFF
BCDE
")

g <- wrap_plots(g1, g2, g3, g4, g5, g6) +
  plot_layout(
    design = my_design,
    heights = c(1.4, 1)
  ) +
  plot_annotation(
    title = "Creating custom projections with {sf} in R",
    subtitle = "Lambert azimuthal equal-area projection, customized to be centered on any City around the globe",
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = 60, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5, size = 30, face = "bold")
    )
  ) &
  theme(
    plot.title.position = "plot",
    plot.tag = element_text(
      size = 24, 
      face = "bold"
    ),
    plot.margin = margin(0,0,0,0, "pt")
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-9_2.png"),
  height = 1400,
  width = 2000,
  unit = "px",
  bg = "white"
)
```

![An array of maps to demonstrate the power of R and {sf} to create custom projections. Part **(a)** shows the world map in Geographic CRS, best used for web-mapping. Part **(b)** shows the Mollweide Projection, showing the global map. The parts **(c)**, **(d)**, **(e)** and **(f)** are world maps focussed around a city around the globe in the Lambert Azimuthal Equal-Area projection, created using a custom function with `coord_sf()` and `"+proj"` strings.](images/chapter7-9_2.png){#fig-9_2}

-   **Other Resources**:
    -   Learn about custom CRS definitions with **WKT strings** ([OGC documentation](https://www.ogc.org/)).
    -   Explore PROJ parameters and CRS modifications ([PROJ documentation](https://proj.org/)).

### **7.10 Exercises**

### E1.

**Create a new object called `nz_wgs` by transforming `nz` object into the WGS84 CRS.**

-   **Create an object of class `crs` for both and use this to query their CRSs.**

-   **With reference to the bounding box of each object, what units does each CRS use?**

-   **Remove the CRS from `nz_wgs` and plot the result: what is wrong with this map of New Zealand and why?**

The code chunk below shows the method to transform the CRS on `nz` object into `WGS84` and querying their CRS using `st_crs()$WktPretty |> str_view()`. The New Zealand Transverse Mercator 2000 projection uses 1 metre as a unit, and WGS84 uses 1 degree of longitude / latitude as a unit. The result of removing the CRS from the `nz_wgs` object is plotted, along with original `nz_wgs` object, in @fig-ex1 .

```{r}
#| eval: true
#| code-fold: false

data("nz")
nz_wgs <- nz |>
  st_transform(crs = "EPSG:4326")
st_crs(nz)$WktPretty |> str_view()
st_crs(nz_wgs)$WktPretty |> str_view()

st_crs(nz)$units
st_crs(nz_wgs)$units
```

```{r}
g1 <- ggplot(data = nz_wgs) +
  geom_sf() +
  labs(
    title = "WGS84 Projection (Geographic)",
    subtitle = "The map is shown in aspect ratio as per the projection."
  ) +
  theme(
    plot.title.position = "plot"
  )

nz_wgs1 <- nz_wgs
st_crs(nz_wgs1) <- NA

g2 <- ggplot(data = nz_wgs1) +
  geom_sf() +
  labs(
    title = "Same Map without projection (NA)",
    subtitle = "The map loses its fixed aspect ratio, and converts to equal axes spacing."
  ) +
  theme(
    plot.title.position = "plot"
  )

g <- g1 + g2 +
  plot_layout(
    nrow = 1
  ) +
  plot_annotation(
    title = "Removing the CRS from New Zealand Map",
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = 30)
    )
  ) &
  theme(
    plot.title.position = "plot",
    plot.tag = element_text(
      size = 24, 
      face = "bold"
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-ex1.png"),
  height = 700,
  width = 1400,
  unit = "px",
  bg = "white"
)
```

![Removing the CRS from a map causes coord_sf() to use coord_equal() instead of desirable aspect ratio prescribed in the original CRS displays.](images/chapter7-ex1.png){#fig-ex1}

### E2.

**Transform the `world` dataset to the transverse Mercator projection (`"+proj=tmerc"`) and plot the result. What has changed and why? Try to transform it back into WGS 84 and plot the new object. Why does the new object differ from the original one?**

The @fig-ex2 shows the entire result of transforming a Geographic CRS: map (a) in @fig-ex2, into Transverse Mercator Projection: map (b) in @fig-ex2, and then re-projecting it back into the same geographic CRS WGS84: map (c) in @fig-ex2 .

While geographic (GCS) and projected (PCS) systems allow versatile transformations, they are not perfectly reversible in real-world data due to floating-point precision limits and approximations inherent in projection algorithms. After transforming back to WGS 84, some distortions may appear because the process involves approximations during the transformation, especially if the intermediate PCS introduced distortion.

```{r}
world <- rnaturalearth::ne_countries(
    scale = "small", 
    returnclass = "sf"
  ) |> 
  select(name, geometry)
  # Removing Indonesia for easy plotting
  # filter(name != "Indonesia")

g1 <- ggplot(data = world) +
  geom_sf() +
  labs(
    title = "Original World Map",
    subtitle = "Geographic CRS: WGS84"
  )

g2 <- ggplot(data = world |> st_transform("+proj=tmerc")) +
  geom_sf() +
  labs(
    title = "Transverse Mercator Projection",
    subtitle = "Using st_crs(\"proj=tmerc\")"
  )

g3 <- ggplot(
  data = world |> 
    st_transform("+proj=tmerc") |> 
    st_transform("WGS84")
  ) +
  geom_sf() +
  labs(
    title = "Back to original CRS (WGS84)",
    subtitle = "Russian and Antarctica segments are distorted."
  )

g <- g1 + g2 + g3 +
  plot_layout(
    nrow = 1
  ) +
  plot_annotation(
    title = "Transforming, and reverting back from a Transverse Mercator to Geographic CRS",
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = 42)
    )
  ) &
  theme(
    plot.title.position = "plot",
    plot.tag = element_text(
      size = 24, 
      face = "bold"
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-ex2.png"),
  height = 700,
  width = 2400,
  unit = "px",
  bg = "white"
)
```

![The entire result of transforming a Geographic CRS: original map (a), into (b) Transverse Mercator Projection, and then (c) back into the same geographic CRS WGS84.](images/chapter7-ex2.png){#fig-ex2}

### E3.

**Transform the continuous raster (`con_raster`) into NAD83 / UTM zone 12N using the nearest neighbor interpolation method. What has changed? How does it influence the results?**

The code below, with the results shown in @fig-ex3, depicts an **original continuous raster** (`con_raster`) in part (a) of @fig-ex3, then the raster transformed into NAD83 / UTM Zone 12N with **nearest neighbour method** in part (b) of @fig-ex3, and finally, the raster transformed into NAD83 / UTM Zone 12N with **bilinear method** in part (c) of @fig-ex3 .

Changes:

1.  The spatial alignment and resolution may change depending on the target CRS and grid size.

2.  The edges of the raster may introduce distortions or artifacts, especially if the original CRS and UTM grid are significantly different.

Impact on Results:

1.  Advantages: Nearest neighbor preserves the exact original values, which is critical for discrete data.

2.  Disadvantages: For continuous rasters, it may introduce blocky artifacts, reducing the smoothness and potentially affecting analyses like slope or gradient computation.

```{r}
con_raster <- rast(system.file("raster/srtm.tif", package = "spDataLarge"))

g1 <- ggplot() +
  geom_spatraster(data = con_raster) +
  scale_fill_wiki_c() +
  labs(
    title = "Original Raster",
    subtitle = "Geographic CRS: WGS84",
    fill = "Elevation (m)"
  )

g2 <- ggplot() +
  geom_spatraster(
    data = con_raster |> 
      terra::project("EPSG:32612", method = "near")
  ) +
  scale_fill_wiki_c() +
  labs(
    title = "NAD83 / UTM zone 12N",
    subtitle = "Using method = \"near\"",
    fill = "Elevation (m)"
  )

g3 <- ggplot() +
  geom_spatraster(
    data = con_raster |> 
      terra::project("EPSG:32612", method = "bilinear")
  ) +
  scale_fill_wiki_c() +
  labs(
    title = "NAD83 / UTM zone 12N",
    subtitle = "Using method = \"bilinear\"",
    fill = "Elevation (m)"
  )

g <- g1 + g2 + g3 +
  plot_layout(
    nrow = 1,
    guides = "collect"
  ) +
  plot_annotation(
    title = "Transforming a continuous raster using the nearest neighbor interpolation method.",
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")",
    theme = theme(
      plot.title = element_text(hjust = 0.5, size = 42)
    )
  ) &
  theme(
    plot.title.position = "plot",
    plot.tag = element_text(
      size = 24, 
      face = "bold"
    ),
    legend.key.width = unit(5, "pt")
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-ex3.png"),
  height = 700,
  width = 1800,
  unit = "px",
  bg = "white"
)
```

![](images/chapter7-ex3.png){#fig-ex3}

### E4. 

**Transform the categorical raster (`cat_raster`) into WGS 84 using the bilinear interpolation method. What has changed? How does it influence the results?**
