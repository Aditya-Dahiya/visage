---
title: "Chapter 7: Reprojecting geographic data"
subtitle: "Key Learnings from, and Solutions to the exercises in Chapter 7 of the book Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow."
date: "2025-01-10"
author: "Aditya Dahiya"
bibliography: references.bib
format:
  html:
    code-fold: true
editor_options: 
  chunk_output_type: console
execute: 
  error: false
  message: false
  warning: false
  eval: false
  cache: false
categories:
  - "Geocomputation with R"
  - "Textbook Solutions"
comments:
  giscus: 
    repo: Aditya-Dahiya/visage
filters:
  - social-share
share:
  permalink: "https://aditya-dahiya.github.io/visage/book_solutions/chapter7.html"
  description: "Visualizing Information and Spatial Analysis with ggplot2 Extensions"
  twitter: true
  linkedin: true
  email: true
  mastodon: true
  facebook: true
---

```{r}
#| label: setup
#| eval: true

library(sf)        # Simple Features in R
library(terra)     # Handling rasters in R
library(tidyterra) # For plotting rasters in ggplot2
library(magrittr)  # Using pipes with raster objects
library(tidyverse) # All things tidy; Data Wrangling
library(spData)    # Spatial Datasets
library(patchwork) # Composing plots

greenland <- rnaturalearth::ne_countries(
  geounit = "Greenland",
  scale = "medium",
  returnclass = "sf"
  ) |> 
  select(admin, name, iso_a3, geometry)

sysfonts::font_add_google("Saira Condensed", "body_font")
showtext::showtext_auto()
theme_set(
  theme_minimal(
    base_family = "body_font",
    base_size = 14,
    base_line_size = 0.2
  ) +
    theme(
      text = element_text(
        colour = "grey20"
      ),
      plot.title = element_text(
        size = 24,
        margin = margin(0.1, 0.1, 0.1, 0.1, "lines")
      ),
      plot.subtitle = element_text(
        size = 16,
        margin = margin(0.1, 0.1, 0.1, 0.1, "lines")
      )
    )
)
```

::: callout-note
For the first few sections, I will use the map of Greenland as an example, since it is an extreme case (far away from equator, so a good use for CRS projections examples), as shown in @fig-7-1_1.
:::

### 7.1 Introduction

-   Coordinate Reference Systems (CRSs): Two main types:
    -   **Geographic CRS**: A reference system that defines locations on the Earth using a spherical or ellipsoidal model. It specifies positions in terms of latitude and longitude, with angular measurements relative to the Earth's center. Uses longitude/latitude (units in degrees)
    -   **Projected CRS**: A reference system that transforms the Earth's curved surface into a flat map. It uses linear units like meters and focuses on minimizing distortions in specific aspects such as distance, area, or shape, depending on the map's purpose. Uses meters from a datum (projected system).

| **Aspect** | **Geographic CRS** | **Projected CRS** |
|------------------|---------------------------|---------------------------|
| **Definition** | Represents locations on the Earth's surface using a spherical or ellipsoidal model. | Represents locations on a flat, two-dimensional surface using a projected system. |
| **Units of Measurement** | Uses angular units (degrees of longitude and latitude). | Uses linear units (meters, feet, etc.). |
| **Coordinate Axes** | Longitude (x-axis) and Latitude (y-axis). | X (east-west) and Y (north-south) in a flat plane. |
| **Purpose** | Ideal for global-scale mapping and geodetic calculations. | Ideal for local or regional mapping, where accurate distances, angles, and areas are required. |
| **Accuracy** | Retains accurate angular relationships but distorts distances and areas. | Distorts angular relationships but preserves distances, areas, or shapes (depending on projection). |
| **Examples** | WGS84 (used in GPS), NAD83. | UTM (Universal Transverse Mercator), State Plane. |
| **Key Feature** | Geocentric, based on Earth's shape as an ellipsoid. | Flat, derived by projecting the Earth onto a 2D surface using a mathematical formula. |
| **Applications** | Satellite data, GPS, global navigation systems. | Engineering projects, land use planning, local/regional maps. |

-   **Focus of the Chapter:**

    -   Setting and transforming CRSs in geographic data.
    -   Highlighting issues caused by ignoring CRSs, especially with lon/lat data.

-   **Practical Relevance:**

    -   Many projects don't require conversion between CRSs but knowing whether your data is in a projected or geographic CRS is critical.
    -   Understanding CRSs prevents errors and ensures smooth handling of geographic data.

```{r}

g1 <- greenland |> 
  ggplot() +
  geom_sf() +
  labs(title = "WGS84 / EPSG:4326", subtitle = "Default geographic projection")

g2 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "EPSG:3857") +
  labs(title = "EPSG:3857", subtitle = "Web Mercator projection")

g3 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "ESRI:102004") +
  labs(title = "ESRI:102004", subtitle = "Lambert Conformal Conic")

g4 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "ESRI:54030") +
  labs(title = "ESRI:54030", subtitle = "Robinson projection")

g5 <- greenland |> 
  ggplot() +
  geom_sf() +
  coord_sf(crs = "EPSG:3413") +
  labs(title = "EPSG:3413", subtitle = "North Pole Stereographic")

g <- g1 + g2 + g3 + g4 + g5 +
  plot_layout(nrow = 1) +
  plot_annotation(
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")"
    ) &
  theme(
    plot.tag = element_text(
      size = 40,
      face = "bold"
    )
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-1_1.png"),
  height = 600,
  width = 2400,
  unit = "px",
  bg = "white"
)
```

![Map of Greenland, with different projections from (a) to (e)](images/chapter7-1_1.png){#fig-7-1_1}

### 7.2 Coordinate Reference Systems

-   **CRS**: Used to transform coordinates between systems.
-   **PROJ**: Core library for CRS transformations; integrated into R-spatial packages and QGIS.
-   **Ways to Describe CRSs**:
    1.  Simple statements: E.g., "lon/lat coordinates" (ambiguous).
    2.  Proj4 strings: E.g., `+proj=longlat +datum=WGS84` (outdated).
    3.  Authority:Code strings: E.g., `EPSG:4326` (recommended).
-   **Preferred Method**: Authority:Code, e.g., **EPSG:4326**:
    -   Understood by `sf`, `terra`, and other tools.
    -   Easy to remember and search online (e.g., [epsg.io](https://epsg.io/4326)).
    -   Machine-readable and unambiguous.
-   **Detailed CRS Representation**: WKT (Well-Known Text):
    -   Comprehensive format for CRS description (based on ISO 19111:2019).
    -   Used for precision and includes all CRS details (datum, ellipsoid, units, etc.).
    -   Example: `st_crs("EPSG:4326")` outputs full WKT string.
-   **Authority Identifiers**:
    -   **EPSG**: Most common authority; standardized CRSs list.
    -   Other authorities: E.g., `ESRI:54030` (Robinson projection).
    -   Identifiers are linked to detailed WKT strings for unambiguous use.
-   WKT vs Identifiers: **WKT Precedence**: In case of conflict, WKT values override identifiers.

::: callout-note
From the [INBO blog](https://inbo.github.io/tutorials/tutorials/spatial_crs_coding/) tutorial "***Goodbye PROJ.4! How to specify a coordinate reference system in R?***"

-   **Understanding CRS**:
    -   A CRS interprets numeric coordinates as actual point locations on Earth.
    -   Two main types:
        -   *Geodetic CRSs*: Locate coordinates relative to a 3D model of Earth's surface.
        -   *Projected CRSs*: Convert geodetic coordinates to a 2D map.
-   **Components of a CRS**:
    -   Coordinate system.
    -   Datum: Defines the position relative to Earth, including the ellipsoid.
    -   For projected CRSs: Parameters for converting geodetic to projected coordinates.
-   **CRS Identification**: CRSs are cataloged globally, notably in the EPSG dataset, with each assigned a unique EPSG code.
-   **Best Practices**:
    -   Adopt WKT representations for CRS definitions to ensure compatibility and future-proofing.
    -   Familiarize with the EPSG dataset for accurate CRS identification.
    -   Utilize R's `sf` package for handling spatial data and CRS specifications.
:::

```{r}
#| eval: true

st_crs("EPSG:4326")$WktPretty |> str_view()

st_crs("ESRI:102004")$WktPretty |> str_view()
```

### 7.3 Querying and Setting Coordinate Systems

-   **CRS in R spatial objects:** Coordinate Reference Systems (CRS) are queried and set in vector and raster geographic data using functions from the `sf` [@sf] and `terra` [@terra-2] packages.

-   **Vector data CRS handling:**

    -   Use [`st_crs()`](https://r-spatial.github.io/sf/reference/st_crs.html) to query CRS in vector objects (e.g., EPSG:4326 for WGS 84).
    -   CRS metadata includes `User input` (e.g., EPSG code, proj-string) and `wkt` (WKT string with complete CRS details).

-   Additional CRS details can be retrieved: The `st_crs()` function from the **sf** package in R provides detailed information about the Coordinate Reference System (CRS) of spatial objects.

| Attribute | Description | Example Usage |
|------------------|--------------------------|----------------------------|
| **IsGeographic** | Indicates if the CRS is geographic (TRUE) or projected (FALSE). | `st_crs(new_vector)$IsGeographic` |
| **units_gdal** | Specifies the units of measurement used in the CRS, as recognized by GDAL. | `st_crs(new_vector)$units_gdal` |
| **srid** | Provides the Spatial Reference System Identifier (SRID) associated with the CRS, if available. | `st_crs(new_vector)$srid` |
| **proj4string** | Returns the PROJ.4 string representation of the CRS, offering a concise textual description. | `st_crs(new_vector)$proj4string` |
| **WktPretty** | Provides a formatted Well-Known Text (WKT) representation of the CRS for easier readability. | `st_crs(new_vector)$WktPretty` |
| **InvFlattening** | Provides the inverse flattening value of the ellipsoid, indicating its compression. | `st_crs(new_vector)$InvFlattening` |
| **Name** | Retrieves the official name of the CRS. | `st_crs(new_vector)$Name` |
| **epsg** | Returns the EPSG code associated with the CRS, if available. | `st_crs(new_vector)$epsg` |
| **yx** | Indicates whether the axis order is latitude-longitude (TRUE) or longitude-latitude (FALSE). | `st_crs(new_vector)$yx` |
| **ud_unit** | Returns the units object associated with the CRS, or NULL if units are missing. | `st_crs(new_vector)$ud_unit` |
| **axes** | Provides information about the axes of the CRS, including their names and units. | `st_crs(new_vector)$axes` |

```{r}
#| eval: true
#| collapse: true

# The WGS 84 / EPSG 4326 projection (default projection in {rnaturalearth})
st_crs("EPSG:4326")$units_gdal
st_crs("EPSG:4326")$IsGeographic
st_crs("EPSG:4326")$proj4string
st_crs("EPSG:4326")$axes

# The EPSG:3857 Web Mercator Projection (used for maps and distances)
st_crs("EPSG:3857")$units_gdal
st_crs("EPSG:3857")$IsGeographic
st_crs("EPSG:3857")$proj4string
st_crs("EPSG:3857")$axes

# Robinson Projection ESRI:54030 
st_crs("ESRI:54030")$units_gdal
st_crs("ESRI:54030")$IsGeographic
st_crs("ESRI:54030")$proj4string
st_crs("ESRI:54030")$axes
```

-   **Use [`st_set_crs()`](https://r-spatial.github.io/sf/reference/st_set_crs.html) to manually set or correct a CRS.** Both `st_set_crs()` and the assignment method `st_crs(object) <- value` are used to define or modify the Coordinate Reference System (CRS) of spatial objects.

    -   `st_set_crs()` is a function call, which can be advantageous when using pipes (`|>`) in a workflow.

    -   Both methods assign CRS metadata to the spatial object without altering the actual coordinate values or geometries.

    -   To transform the coordinates to a different CRS, the `st_transform()` function should be used.

    -   Assigning a CRS is akin to labeling data with its existing coordinate system, whereas transforming reprojects the data into a new coordinate system.

```{r}

g1 <- greenland |> 
  st_set_crs("EPSG:4326") |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "EPSG:4326",
    subtitle = "The default CRS: a geographic CRS"
  )

g2 <- greenland |> 
  st_transform("EPSG:3857") |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "st_transform(`EPSG:3857`)",
    subtitle = "Correct usage; EPSG:3857 CRS: a projected CRS"
  )

g3 <- greenland |> 
  st_set_crs("EPSG:3857") |> 
  ggplot() +
  geom_sf() +
  labs(
    title = "st_set_crs(`EPSG:3857`)",
    subtitle = "Wrong usage; distorts and assigns CRS values"
  )

g <- g1 + g2 + g3 +
  plot_layout(nrow = 1) +
  plot_annotation(
    tag_levels = "a",
    tag_prefix = "(",
    tag_suffix = ")"
    ) &
  theme(
    plot.tag = element_text(
      size = 40,
      face = "bold"
    ),
    plot.margin = margin(0,7,0,7, "mm")
  )

ggsave(
  plot = g,
  filename = here::here("book_solutions", "images", "chapter7-3_1.png"),
  height = 600,
  width = 2400,
  unit = "px"
)
```

![Explaining the difference between the st_set_crs() and st_transform(). The figures show (a) The default map of Greenland as obtained from {rnaturalearth} with the CRS WGS84 (i.e. EPSG:4326). (b) The transformation using `st_transform()` which produces correct transformation. (c) The incorrect method using `st_set_crs()` which simply retains all data, but assumes them to be in the new assigned CRS. This leads to wrong latitude and longitude numbers. Thus, the only use of `st_set_crs()` is for assigning a CRS to a raw data, which we know for sure from outside sources.](images/chapter7-3_1.png)

-   **Validate CRS with `st_is_longlat()`.**

    -   The function **`st_is_longlat()`** in the **sf** package is used to check whether the Coordinate Reference System (CRS) of a spatial object is based on a geographic coordinate system (latitude and longitude). It's Return Value can be: —

        -   TRUE: The object has a geographic CRS (e.g., EPSG:4326).

        -   FALSE: The object has a projected CRS.

        -   NA: The CRS is undefined (e.g., no metadata about the coordinate system is set).

-   **Raster data CRS handling:**

    -   Use `crs()` from the {terra} package to query and set CRS for raster objects.
    -   Outputs CRS as a WKT string.
    -   Set CRS with EPSG codes, WKT strings, or CRSs from other objects (e.g., `crs(my_raster) = "EPSG:26912"`).

-   **Important considerations:**

    -   `st_crs()` and `crs()` only set metadata; they do not modify coordinate values or geometries.
    -   Missing CRS in datasets (e.g., `NA` output in `st_is_longlat()`) indicates that CRS must be explicitly defined (e.g., using `st_set_crs()`).

-   CRS assumptions: R avoids assumptions about CRS (e.g., unlike GeoJSON which defaults to `EPSG:4326`).

### 7.4 Geometry Operations on Projected and Unprojected Data

-   The `sf` package integrates with:

    -   The [S2 spherical geometry engine](https://cran.r-project.org/web/packages/s2/) for **geographic CRS data** with longitude/latitude (lon/lat) CRSs.
    -   [GEOS](https://libgeos.org/) is used for **projected CRS or CRS-absent data**.
    -   **Default Behavior**: S2 is enabled by default for geographic data but can be disabled using [`sf::sf_use_s2(FALSE)`](https://r-spatial.github.io/sf/reference/sf_use_s2.html).

-   **CRS Importance in Buffers**: Buffers created on unprojected data (e.g., lon/lat) can result in distorted outputs (for example A.1 in @fig-7-4) unless spherical geometry (S2) is used. Better still, always use a projected CRS for accurate distance / buffers calculation (as C.1 in @fig-7-4).

-   Key Learnings:

    1.  **Incorrect buffer creation:** Buffers on geographic data (Long / Lat data) without a specified CRS (thus, using GEOS) result in outputs in degrees (as A.1 & A.3 in @fig-7-4). *Note: Lon/lat buffers without S2 or projection may appear elongated (e.g., along the north-south axis).*

    2.  **Correct buffer creation:** S2 buffers (with Geographic CRS, i.e. Long / Lat data) calculate accurate distances (as B.1 in @fig-7-4) but may create jagged boundaries (as B.3 in @fig-7-4) (this can be tuned with `max_cells` or `nQuadSegs`).

    3.  **Ideal buffer creation:** Use projected CRSs (as in C.1, C.2 & C.3 in @fig-7-4)) like British National Grid (`EPSG:27700`) for consistent distance-based operations, for example, in metres (m).

::: callout-note
*Note: S2 buffers improve results but remain less precise than using projected CRSs and GEOS.*
:::

-   **Visual Outcomes**:

    -   Buffers based on S2 and projected CRSs produce more accurate, equidistant boundaries compared to lon/lat inputs without S2.
    -   S2-derived buffers differ from projected GEOS buffers, and resolution depends on `max_cells` (default: 1000). (as B.3 in @fig-7-4)

-   **Best Practices**:

    -   Use `sf::st_crs()` to check the CRS and **verify units (e.g., degrees vs. meters) of the CRS**. Reproject data to a projected CRS using suitable EPSG codes for precise geometric operations.
    -   For distance-based operations like buffering, reproject data to a projected CRS.
    -   Adjust `max_cells` in S2 for performance versus resolution trade-offs. (as B.1 in @fig-7-4)

#### @fig-7-4 shows an example (buffer zone around London)

```{r}

overall_title <- "When and How to Use S2 and GEOS Engines for Spatial Operations"
overall_subtitle <- "GEOS handles projected or CRS-absent data; S2 defaults for geographic data but is optional."


bts <- 16     # Base Text Size

theme_set(
  theme_minimal(
    base_family = "body_font",
    base_size = bts,
    base_line_size = 0.2
  ) +
    theme(
      text = element_text(
        colour = "grey20"
      ),
      plot.title = element_text(
        size = 1.9 * bts,
        margin = margin(0.2, 0.1, 0.1, 0.1, "lines")
      ),
      plot.subtitle = element_text(
        size = 1.3 * bts,
        margin = margin(0.1, 0.1, 0.1, 0.1, "lines")
      ),
      plot.margin = margin(0,0,0,0, "mm"),
      axis.text = element_text(
        size = bts * 0.5
      ),
      axis.ticks.length = unit(0, "mm"),
      panel.background = element_rect(
        fill = "#caf0f8",
        colour = "#caf0f8"
      ),
      panel.grid = element_line(
        linewidth = 0.2,
        colour = "white",
        linetype = 3
      )
    )
)

# Create a London data point - the coordiantes in Latitude
# and Longitude of London, UK
london_sans_crs <- data.frame(lon = -0.1, lat = 51.5) |> 
  st_as_sf(coords = c("lon", "lat"))

# Adding the CRS to London data point: values stay same
london_with_crs <- london_sans_crs |> 
  st_set_crs("EPSG:4326")

# British National Grid
# st_crs("EPSG:27700")

# Using the British National Grid CRS: values get changed
london_british_crs <- london_sans_crs |> 
  st_set_crs("EPSG:4326") |> 
  st_transform("EPSG:27700")


# Create an approximate bounding box around 200 km around London
bbox_near_london <- london_sans_crs |> 
  st_set_crs("EPSG:4326") |> 
  st_buffer(dist = 200000) |> 
  st_bbox()

# Crop and keep coastline map around London
outline_map <- rnaturalearth::ne_countries(
  continent = "Europe",
  returnclass = "sf",
  scale = "large"
  ) |> 
  st_union() |> 
  st_as_sf() |> 
  st_crop(bbox_near_london)


base_plot <- ggplot() +
  geom_sf(
    data = outline_map,
    linewidth = 0.1,
    fill = alpha("white", 1)
  ) +
  geom_sf(
    data = london_with_crs,
    size = 3,
    colour = "#fb8500"
  ) +
  coord_sf(expand = FALSE)

# Without any CRS -------------------------------------------------

row_1_title <- "London Data, without any CRS"
row_1_subtitle <- "Data in Long / Lat, but without a specified CRS, leads {sf} to use GEOS engine, as in (a) and (c)"

g1 <- base_plot +
  geom_sf(
    data = st_buffer(london_sans_crs, 
                     dist = 1) |> 
            st_set_crs("EPSG:4326"),
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Using GEOS on Long/Lat data",
    subtitle = "st_buffer(london_sans_crs, dist = 1)"
  )

g2 <- base_plot +
  geom_sf(
    data = london_sans_crs |> 
            st_set_crs("EPSG:4326") |> 
            st_buffer(dist = 1),
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Using S2 but wrong Buffer units",
    subtitle = "london_sans_crs |> st_set_crs(`EPSG:4326`) |> st_buffer(dist = 1)"
  )

g3 <- base_plot +
  geom_sf(
    data = st_buffer(london_sans_crs, 
                     dist = 1,
                     nQuadSegs = 2) |> 
            st_set_crs("EPSG:4326"),
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Using GEOS with nQuadSegs",
    subtitle = "st_buffer(london_sans_crs, dist = 1, nQuadSegs = 3)"
  )


row_2_title <- "London with a Geographic CRS `EPSG:4326`"
row_2_subtitle <- "Data in Long/Lat, but with CRS speficied, leads {sf}to use S2 (spherical geometry). Distance is in metres, now."

sf_use_s2(TRUE)
g4 <- base_plot +
  geom_sf(
    data = st_buffer(london_with_crs, 
                     dist = 1e5,
                     max_cells = 300),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Correct: Buffer of 100 km using S2",
    subtitle = "Using S2 engine (spherical geometry); Notice jagged buffer line."
  )

sf_use_s2(FALSE)
g5 <- base_plot +
  geom_sf(
    data = st_buffer(london_with_crs, 
                     dist = 1,
                     max_cells = 500),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Incorrect: Buffer of 1 degree with GEOS",
    subtitle = "sf_use_s2(FALSE):  Using GEOS engine on geographic CRS."
  )

sf_use_s2(TRUE)
g6 <- base_plot +
  geom_sf(
    data = st_buffer(london_with_crs, 
                     dist = 1e5,
                     max_cells = 100),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Correct: Buffer of 100 km using S2",
    subtitle = "Reducing max_cells = 100 to save computation time."
  )

row_3_title <- "With a Projected CRS: British Grid (EPSG:27700)"
row_3_subtitle <- "Using London data in Projected CRS results in ideal outputs. Accurate results with GEOS engine."

g7 <- base_plot +
  geom_sf(
    data = st_buffer(london_british_crs, 
                     dist = 1e5),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Ideal: 100 km Buffer on projected CRS",
    subtitle = "london_british_crs |> st_buffer(dist = 1e5)"
  )

g8 <- base_plot +
  geom_sf(
    data = st_buffer(london_british_crs, 
                     dist = 1e5,
                     nQuadSegs = 1),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Distance in 4 directions only",
    subtitle = "nQuadSegs = 1  (Number of segments per quadrant)."
  )

g9 <- base_plot +
  geom_sf(
    data = st_buffer(london_british_crs, 
                     dist = 1e5,
                     nQuadSegs = 2),
    linewidth = 1,
    fill = alpha("#ffb703", 0.5),
    colour = "#ffb703"
  ) +
  labs(
    title = "Save Computation Time: 100 km Buffer",
    subtitle = "nQuadSegs = 2  (Number of segments per quadrant)."
  )

# A custom theme for each Row headings
theme_row <- function(...){
  theme(
    plot.title = element_text(
        margin = margin(5,0,1,0, "mm"),
        size = bts * 3.5,
        hjust = 0.5,
        face = "bold"
      ),
      plot.subtitle = element_text(
        margin = margin(0,0,1,0, "mm"),
        size = bts * 2.5,
        hjust = 0.5,
        face = "bold"
      ),
    ...
  )
}

theme_tag <- function(...){
  theme(
    plot.tag = element_text(
      margin = margin(0,0,0,0, "mm"),
      hjust = 0.5,
      face = "bold",
      size = bts * 1.5
    ),
    plot.tag.position = "top"
  )
}

# Compiling Plots for London data without CRS
ga <- g1 + g2 + g3 +
  plot_annotation(
    title = row_1_title,
    subtitle = row_1_subtitle,
    theme = theme_row(),
    tag_levels = "1",
    tag_prefix = "A."
  ) &
  theme_tag()

# Save the 3 plots for 1st Row
ggsave(
  plot = ga,
  filename = here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-1.png"),
  height = 1050,
  width = 2400,
  unit = "px",
  bg = "white"
)

# Compiling Plots for London data with a Geographic CRS
gb <-  g4 + g5 + g6 +
  plot_annotation(
    title = row_2_title,
    subtitle = row_2_subtitle,
    theme = theme_row(),
    tag_levels = "1",
    tag_prefix = "B."
  ) &
  theme_tag()


# Save the 3 plots for 2nd Row
ggsave(
  plot = gb,
  filename = here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-2.png"),
  height = 1050,
  width = 2400,
  unit = "px",
  bg = "white"
)


# Compiling Plots for Projected (British Grid) CRS

gc <-  g7 + g8 + g9 +
  plot_layout(
    tag_level = "new"
  ) +
  plot_annotation(
    title = row_3_title,
    subtitle = row_3_subtitle,
    theme = theme_row(),
    tag_levels = "1",
    tag_prefix = "C."
  ) &
  theme_tag()


# Save the 3 plots for 3rd Row
ggsave(
  plot = gc,
  filename = here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-3.png"),
  height = 1050,
  width = 2400,
  unit = "px",
  bg = "white"
)

# Compile the images
library(magick)
ga <- image_read(here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-1.png"))
gb <- image_read(here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-2.png"))
gc <- image_read(here::here("book_solutions", 
                        "images", 
                        "temp_chapter7-4-3.png"))

image_append(c(ga, gb, gc), stack = TRUE) |> 
  image_write(path = here::here("book_solutions", 
                        "images", 
                        "chapter7-4.png"))

# Clean up the temporary file
unlink(here::here("book_solutions","images",
                  "temp_chapter7-4-1.png"))
unlink(here::here("book_solutions","images",
                  "temp_chapter7-4-2.png"))
unlink(here::here("book_solutions","images",
                  "temp_chapter7-4-3.png"))
```

![The different kinds of buffering - incorrect, correct and ideal using {sf} in R relying on two engines - Google's S2 spherical geometry, or GEOS engine.](images/chapter7-4.png){#fig-7-4}

::: callout-note
This code below calculates the distances between lines of longitude (meridians) and latitude at different geographic points to demonstrate the distortion inherent in geographic coordinate systems (lon/lat CRSs).

```{r}
#| eval: true
#| code-fold: false
#| collapse: true

# Load the required package
library(geosphere)

# 1. Distance between two meridians (longitude lines) at the equator (0° latitude)
# From (0°E, 0°N) to (1°E, 0°N)
distance_meridian_equator <- distGeo(c(0, 0), c(1, 0)) 
cat("Distance between meridians at the equator:", round(distance_meridian_equator/1000, 2), "km\n")


# 2. Distance between two meridians at the latitude of London (51.5°N)
# From (0°E, 51.5°N) to (1°E, 51.5°N)
distance_meridian_london <- distGeo(c(0, 51.5), c(1, 51.5)) 
cat("Distance between meridians at London's latitude:", round(distance_meridian_london/1e3, 2), "km\n")


# 3. Distance between two parallels (latitude lines) at any latitude
# From (0°E, 0°N) to (0°E, 1°N)
distance_latitude <- distGeo(c(0, 0), c(0, 1)) 
cat("Distance between latitudes:", round(distance_latitude/1e3, 2), "meters\n")

```

Thus, the distance between meridians varies with latitude, shrinking from approximately 111 km at the equator to zero at the poles, while lines of latitude remain equidistant.
:::
